From 874c2bc71dc3bc1c51c3ae6cdeb01131014aed7d Mon Sep 17 00:00:00 2001
From: mrodriguez <mrodriguez@ridgerun.com>
Date: Fri, 6 Nov 2009 09:20:22 -0600
Subject: [PATCH] Add support for davinci display driver


Signed-off-by: mrodriguez <mrodriguez@ridgerun.com>
---
 arch/arm/Kconfig                               |    4 +-
 arch/arm/mach-davinci/board-dm355-evm.c        |   14 +
 arch/arm/mach-davinci/board-dm355-leopard.c    |   13 +
 arch/arm/mach-davinci/dm355.c                  |  101 +
 arch/arm/mach-davinci/include/mach/cpu.h       |    7 +
 arch/arm/mach-davinci/include/mach/mux.h       |  164 ++
 drivers/media/video/Kconfig                    |   78 +
 drivers/media/video/davinci/Makefile           |   12 +
 drivers/media/video/davinci/avnetlcd_encoder.c |  373 +++
 drivers/media/video/davinci/davinci_display.c  | 1868 +++++++++++++
 drivers/media/video/davinci/davinci_enc_mngr.c | 1166 ++++++++
 drivers/media/video/davinci/davinci_osd.c      | 2434 ++++++++++++++++
 drivers/media/video/davinci/davinci_platform.c | 1295 +++++++++
 drivers/media/video/davinci/logicpd_encoder.c  |  413 +++
 drivers/media/video/davinci/vpbe_encoder.c     |  886 ++++++
 drivers/media/video/davinci/vpfe_capture.c     |    4 +-
 drivers/media/video/davinci/vpss.c             |  690 +++++
 drivers/video/davincifb.c                      | 3513 ++++++++++++++----------
 drivers/video/modedb.c                         |    2 +
 include/media/davinci/avnetlcd_encoder.h       |   55 +
 include/media/davinci/davinci_display.h        |  177 ++
 include/media/davinci/davinci_enc.h            |  248 ++
 include/media/davinci/davinci_enc_mngr.h       |   56 +
 include/media/davinci/davinci_platform.h       |   45 +
 include/media/davinci/logicpd_encoder.h        |   55 +
 include/media/davinci/vid_encoder_if.h         |  287 ++
 include/media/davinci/vid_encoder_types.h      |  233 ++
 include/media/davinci/vpbe_encoder.h           |   49 +
 include/media/davinci/vpss.h                   |  146 +
 include/video/davinci_osd.h                    |  910 ++++++
 include/video/davinci_vpbe.h                   |  551 ++++
 include/video/davincifb.h                      |  486 +---
 include/video/davincifb_ioctl.h                |  175 ++
 33 files changed, 14685 insertions(+), 1825 deletions(-)
 create mode 100644 drivers/media/video/davinci/avnetlcd_encoder.c
 create mode 100644 drivers/media/video/davinci/davinci_display.c
 create mode 100644 drivers/media/video/davinci/davinci_enc_mngr.c
 create mode 100644 drivers/media/video/davinci/davinci_osd.c
 create mode 100644 drivers/media/video/davinci/davinci_platform.c
 create mode 100644 drivers/media/video/davinci/logicpd_encoder.c
 create mode 100644 drivers/media/video/davinci/vpbe_encoder.c
 create mode 100644 drivers/media/video/davinci/vpss.c
 create mode 100644 include/media/davinci/avnetlcd_encoder.h
 create mode 100644 include/media/davinci/davinci_display.h
 create mode 100644 include/media/davinci/davinci_enc.h
 create mode 100644 include/media/davinci/davinci_enc_mngr.h
 create mode 100644 include/media/davinci/davinci_platform.h
 create mode 100644 include/media/davinci/logicpd_encoder.h
 create mode 100644 include/media/davinci/vid_encoder_if.h
 create mode 100644 include/media/davinci/vid_encoder_types.h
 create mode 100644 include/media/davinci/vpbe_encoder.h
 create mode 100644 include/media/davinci/vpss.h
 create mode 100644 include/video/davinci_osd.h
 create mode 100644 include/video/davinci_vpbe.h
 create mode 100644 include/video/davincifb_ioctl.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index e76bb59..fc6e194 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -715,8 +715,8 @@ source "arch/arm/common/Kconfig"
 
 config FORCE_MAX_ZONEORDER
 	int
-	depends on SA1111
-	default "9"
+	default "9" if SA1111
+	default "13" if ARCH_DAVINCI
 
 menu "Bus support"
 
diff --git a/arch/arm/mach-davinci/board-dm355-evm.c b/arch/arm/mach-davinci/board-dm355-evm.c
index 7189cb8..7151ed5 100644
--- a/arch/arm/mach-davinci/board-dm355-evm.c
+++ b/arch/arm/mach-davinci/board-dm355-evm.c
@@ -324,9 +324,23 @@ static struct vpfe_capture_input vpfe_capture_inputs = {
 	},
 };
 
+static u64 davinci_fb_dma_mask = DMA_32BIT_MASK;
+
+static struct platform_device davinci_fb_device = {
+	.name		= "davincifb",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &davinci_fb_dma_mask,
+		.coherent_dma_mask      = DMA_32BIT_MASK,
+	},
+	.num_resources = 0,
+};
+
+
 static struct platform_device *davinci_evm_devices[] __initdata = {
 	&dm355evm_dm9000,
 	&davinci_nand_device,
+	&davinci_fb_device,
 };
 
 static struct davinci_uart_config uart_config __initdata = {
diff --git a/arch/arm/mach-davinci/board-dm355-leopard.c b/arch/arm/mach-davinci/board-dm355-leopard.c
index 45623dc..51b7b01 100644
--- a/arch/arm/mach-davinci/board-dm355-leopard.c
+++ b/arch/arm/mach-davinci/board-dm355-leopard.c
@@ -239,10 +239,23 @@ static struct vpfe_capture_input vpfe_capture_inputs = {
 		.routing_supported = 1,
 	},
 };
+/*
+static u64 davinci_fb_dma_mask = DMA_32BIT_MASK;
+
+static struct platform_device davinci_fb_device = {
+	.name		= "davincifb",
+	.id		= -1,
+	.dev = {
+		.dma_mask		= &davinci_fb_dma_mask,
+		.coherent_dma_mask      = DMA_32BIT_MASK,
+	},
+	.num_resources = 0,
+};*/
 
 static struct platform_device *davinci_leopard_devices[] __initdata = {
 	&dm355leopard_dm9000,
 	&davinci_nand_device,
+	//&davinci_fb_device,
 };
 
 static struct davinci_uart_config uart_config __initdata = {
diff --git a/arch/arm/mach-davinci/dm355.c b/arch/arm/mach-davinci/dm355.c
index e2612dd..c5b0de7 100644
--- a/arch/arm/mach-davinci/dm355.c
+++ b/arch/arm/mach-davinci/dm355.c
@@ -15,6 +15,8 @@
 #include <linux/dma-mapping.h>
 
 #include <linux/spi/spi.h>
+#include <video/davinci_osd.h>
+#include <video/davinci_vpbe.h>
 
 #include <mach/dm355.h>
 #include <mach/clock.h>
@@ -102,6 +104,7 @@ static struct clk vpss_dac_clk = {
 	.name = "vpss_dac",
 	.parent = &pll1_sysclk3,
 	.lpsc = DM355_LPSC_VPSS_DAC,
+	.flags = ALWAYS_ENABLED,
 };
 
 static struct clk vpss_master_clk = {
@@ -464,6 +467,12 @@ EVT_CFG(DM355,  EVT8_ASP1_TX,	      0,    1,    0,     false)
 EVT_CFG(DM355,  EVT9_ASP1_RX,	      1,    1,    0,     false)
 EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
 
+MUX_CFG(DM355, VOUT_FIELD,     1,   18,    3,    1,     false)
+MUX_CFG(DM355, VOUT_FIELD_G70, 1,   18,    3,    0,     false)
+MUX_CFG(DM355, VOUT_HVSYNC,    1,   16,    1,    0,     false)
+MUX_CFG(DM355, VOUT_COUTL_EN,  1,   0,     0xff, 0x55,  false)
+MUX_CFG(DM355, VOUT_COUTH_EN,  1,   8,     0xff, 0x55,  false)
+
 MUX_CFG(DM355,	VIN_PCLK,	0,   14,    1,    1,	 false)
 MUX_CFG(DM355,	VIN_CAM_WEN,	0,   13,    1,    1,	 false)
 MUX_CFG(DM355,	VIN_CAM_VD,	0,   12,    1,    1,	 false)
@@ -528,6 +537,31 @@ static struct platform_device dm355_edma_device = {
 	.resource		= edma_resources,
 };
 
+static struct resource dm355_vpss_resources[] = {
+	{
+		/* VPSS BL Base address */
+		.name		= "vpss",
+		.start          = 0x01c70800,
+		.end            = 0x01c70800 + 0xff,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		/* VPSS CLK Base address */
+		.name		= "vpss",
+		.start          = 0x01c70000,
+		.end            = 0x01c70000 + 0xf,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device dm355_vpss_device = {
+	.name			= "vpss",
+	.id			= -1,
+	.dev.platform_data	= "dm355_vpss",
+	.num_resources		= ARRAY_SIZE(dm355_vpss_resources),
+	.resource		= dm355_vpss_resources,
+};
+
 static struct resource vpfe_resources[] = {
 	{
 		.start          = IRQ_VDINT0,
@@ -565,6 +599,63 @@ static struct platform_device vpfe_capture_dev = {
 	},
 };
 
+static u64 dm355_osd_dma_mask = DMA_BIT_MASK(32);
+static struct davinci_osd_platform_data dm355_osd_pdata = {
+       .type = DM355,
+};
+
+static struct resource dm355_osd_resources[] = {
+       {
+               .start          = IRQ_VENCINT,
+               .end            = IRQ_VENCINT,
+               .flags          = IORESOURCE_IRQ,
+       },
+       {
+               .start          = DM355_OSD_REG_BASE,
+               .end            = DM355_OSD_REG_BASE + 0x180,
+               .flags          = IORESOURCE_MEM,
+       },
+};
+
+static struct platform_device dm355_osd_dev = {
+       .name           = "davinci_osd",
+       .id             = -1,
+       .num_resources  = ARRAY_SIZE(dm355_osd_resources),
+       .resource       = dm355_osd_resources,
+       .dev = {
+               .dma_mask               = &dm355_osd_dma_mask,
+               .coherent_dma_mask      = DMA_BIT_MASK(32),
+               .platform_data          = &dm355_osd_pdata,
+       },
+};
+
+static u64 dm355_venc_dma_mask = DMA_BIT_MASK(32);
+
+static struct davinci_venc_platform_data dm355_venc_pdata = {
+       .soc = DM35x,
+};
+
+
+static struct resource dm355_venc_resources[] = {
+       {
+               .start          = DM355_VENC_REG_BASE,
+               .end            = DM355_VENC_REG_BASE + 0x180,
+               .flags          = IORESOURCE_MEM,
+       },
+};
+
+static struct platform_device dm355_venc_dev = {
+       .name           = "davinci_venc",
+       .id             = -1,
+       .num_resources  = ARRAY_SIZE(dm355_venc_resources),
+       .resource       = dm355_venc_resources,
+       .dev = {
+               .dma_mask               = &dm355_venc_dma_mask,
+               .coherent_dma_mask      = DMA_BIT_MASK(32),
+               .platform_data          = &dm355_venc_pdata,
+       },
+};
+
 void setup_vpfe_input_config(struct vpfe_capture_input *input_config)
 {
 	vpfe_capture_dev.dev.platform_data = input_config;
@@ -578,6 +669,7 @@ void __init dm355_init(void)
 }
 
 #define DM355_VPSSCLK_CLKCTRL_REG	0x1c70004
+
 static int __init dm355_init_devices(void)
 {
 	void __iomem *base = IO_ADDRESS(DM355_VPSSCLK_CLKCTRL_REG);
@@ -598,7 +690,16 @@ static int __init dm355_init_devices(void)
 	davinci_cfg_reg(DM355_VIN_YIN_EN);
 	davinci_cfg_reg(DM355_VIN_CINL_EN);
 	davinci_cfg_reg(DM355_VIN_CINH_EN);
+	
+	platform_device_register(&dm355_vpss_device);
 	platform_device_register(&vpfe_capture_dev);
+
+       /* Register OSD device */
+       platform_device_register(&dm355_osd_dev);
+
+       /* Register VENC device */
+       platform_device_register(&dm355_venc_dev);
+
 	return 0;
 }
 postcore_initcall(dm355_init_devices);
diff --git a/arch/arm/mach-davinci/include/mach/cpu.h b/arch/arm/mach-davinci/include/mach/cpu.h
index 99c73da..6858f02 100644
--- a/arch/arm/mach-davinci/include/mach/cpu.h
+++ b/arch/arm/mach-davinci/include/mach/cpu.h
@@ -27,6 +27,7 @@ static inline int is_davinci_dm ##type(void)	        \
 IS_DAVINCI_CPU(644x, 0x6446)
 IS_DAVINCI_CPU(646x, 0x6467)
 IS_DAVINCI_CPU(355, 0x355)
+IS_DAVINCI_CPU(365, 0x365)
 
 #ifdef CONFIG_ARCH_DAVINCI_DM644x
 #define cpu_is_davinci_dm644x() is_davinci_dm644x()
@@ -46,4 +47,10 @@ IS_DAVINCI_CPU(355, 0x355)
 #define cpu_is_davinci_dm355() 0
 #endif
 
+#ifdef CONFIG_ARCH_DAVINCI_DM365
+#define cpu_is_davinci_dm365() is_davinci_dm365()
+#else
+#define cpu_is_davinci_dm365() 0
+#endif
+
 #endif
diff --git a/arch/arm/mach-davinci/include/mach/mux.h b/arch/arm/mach-davinci/include/mach/mux.h
index cbc80f5..8bce02c 100644
--- a/arch/arm/mach-davinci/include/mach/mux.h
+++ b/arch/arm/mach-davinci/include/mach/mux.h
@@ -167,6 +167,16 @@ enum davinci_dm355_index {
 	DM355_EVT9_ASP1_RX,
 	DM355_EVT26_MMC0_RX,
 
+	/* VPSS muxing */
+	DM355_VOUT_HVSYNC,
+	DM355_VOUT_FIELD,
+	DM355_VOUT_FIELD_G70,
+	DM355_VOUT_COUTL_EN,
+	DM355_VOUT_COUTH_EN,
+
+	DM355_GPIO16,
+	DM355_GPIO17,
+
 	/* Video In Pin Mux */
 	DM355_VIN_PCLK,
 	DM355_VIN_CAM_WEN,
@@ -177,6 +187,160 @@ enum davinci_dm355_index {
 	DM355_VIN_CINH_EN,
 };
 
+ enum davinci_dm365_index {
+ 
+   /* MMC/SD 0 */
+   DM365_MMCSD0,
+   
+    /* MMC/SD 1 */
+    DM365_SD1_CLK,
+    DM365_SD1_CMD,
+    DM365_SD1_DATA3,
+    DM365_SD1_DATA2,
+     DM365_SD1_DATA1,
+     DM365_SD1_DATA0,
+     
+     /* I2C */
+      DM365_I2C_SDA,
+       DM365_I2C_SCL,
+       
+       /* AEMIF */
+       DM365_AEMIF_AR,
+       DM365_AEMIF_A3,
+       DM365_AEMIF_A7,
+       DM365_AEMIF_D15_8,
+       DM365_AEMIF_CE0,
+       
+       /* ASP0 function */
+       DM365_MCBSP0_BDX,
+       DM365_MCBSP0_X,
+       DM365_MCBSP0_BFSX,
+       DM365_MCBSP0_BDR,
+       DM365_MCBSP0_R,
+       DM365_MCBSP0_BFSR,
+       
+       /* SPI0 */
+       DM365_SPI0_SCLK,
+        DM365_SPI0_SDI,
+        DM365_SPI0_SDO,
+        DM365_SPI0_SDENA0,
+        DM365_SPI0_SDENA1,
+        
+        /* UART */
+        DM365_UART0_RXD,
+        DM365_UART0_TXD,
+        DM365_UART1_RXD,
+        DM365_UART1_TXD,
+        DM365_UART1_RTS,
+        DM365_UART1_CTS,
+        
+        /* EMAC */
+        DM365_EMAC_TX_EN,
+        DM365_EMAC_TX_CLK,
+        DM365_EMAC_COL,
+        DM365_EMAC_TXD3,
+        DM365_EMAC_TXD2,
+        DM365_EMAC_TXD1,
+        DM365_EMAC_TXD0,
+        DM365_EMAC_RXD3,
+        DM365_EMAC_RXD2,
+        DM365_EMAC_RXD1,
+        DM365_EMAC_RXD0,
+        DM365_EMAC_RX_CLK,
+        DM365_EMAC_RX_DV,
+        DM365_EMAC_RX_ER,
+        DM365_EMAC_CRS,
+        DM365_EMAC_MDIO,
+        DM365_EMAC_MDCLK,
+        
+        /* Keypad */
+        DM365_KEYPAD,
+        
+        /* PWM */
+        DM365_PWM0,
+        DM365_PWM0_G23,
+        DM365_PWM1,
+         DM365_PWM1_G25,
+          DM365_PWM2_G87,
+          DM365_PWM2_G88,
+           DM365_PWM2_G89,
+           DM365_PWM2_G90,
+           DM365_PWM3_G80,
+           DM365_PWM3_G81,
+           DM365_PWM3_G85,
+           DM365_PWM3_G86,
+            
+            /* SPI1 */
+            DM365_SPI1_SCLK,
+            DM365_SPI1_SDO,
+            DM365_SPI1_SDI,
+            DM365_SPI1_SDENA0,
+            DM365_SPI1_SDENA1,
+            
+             /* SPI2 */
+             DM365_SPI2_SCLK,
+             DM365_SPI2_SDO,
+             DM365_SPI2_SDI,
+             DM365_SPI2_SDENA0,
+             DM365_SPI2_SDENA1,
+             
+              /* SPI3 */
+              DM365_SPI3_SCLK,
+              DM365_SPI3_SDO,
+              DM365_SPI3_SDI,
+              DM365_SPI3_SDENA0,
+              DM365_SPI3_SDENA1,
+              
+               /* SPI4 */
+               DM365_SPI4_SCLK,
+               DM365_SPI4_SDO,
+               DM365_SPI4_SDI,
+               DM365_SPI4_SDENA0,
+               DM365_SPI4_SDENA1,
+               
+                /* GPIO */
+                 DM365_GPIO20,
+                 DM365_GPIO33,
+                 DM365_GPIO40,
+                  
+                  /* Video */
+                  DM365_VOUT_FIELD,
+                  DM365_VOUT_FIELD_G81,
+                  DM365_VOUT_HVSYNC,
+                  DM365_VOUT_COUTL_EN,
+                  DM365_VOUT_COUTH_EN,
+                  DM365_VIN_CAM_WEN,
+                  DM365_VIN_CAM_VD,
+                  DM365_VIN_CAM_HD,
+                  DM365_VIN_YIN4_7_EN,
+                  DM365_VIN_YIN0_3_EN,
+                  
+                  /* IRQ muxing */
+                  DM365_INT_EDMA_CC,
+                  DM365_INT_EDMA_TC0_ERR,
+                  DM365_INT_EDMA_TC1_ERR,
+                  DM365_INT_EDMA_TC2_ERR,
+                  DM365_INT_EDMA_TC3_ERR,
+                  DM365_INT_PRTCSS,
+                  DM365_INT_EMAC_RXTHRESH,
+                  DM365_INT_EMAC_RXPULSE,
+                  DM365_INT_EMAC_TXPULSE,
+                  DM365_INT_EMAC_MISCPULSE,
+                  DM365_INT_IMX0_ENABLE,
+                  DM365_INT_IMX0_DISABLE,
+                  DM365_INT_HDVICP_ENABLE,
+                  DM365_INT_HDVICP_DISABLE,
+                  DM365_INT_IMX1_ENABLE,
+                  DM365_INT_IMX1_DISABLE,
+                  DM365_INT_NSF_ENABLE,
+                  DM365_INT_NSF_DISABLE,
+                  
+                  /* EDMA event muxing */
+                  DM365_EVT2_ASP_TX,
+                  DM365_EVT3_ASP_RX,
+                  DM365_EVT26_MMC0_RX,
+                  };
+
 #ifdef CONFIG_DAVINCI_MUX
 /* setup pin muxing */
 extern void davinci_mux_init(void);
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 7ce2a41..333ace0 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -506,6 +506,77 @@ config VIDEO_DAVINCI_VPIF
           To compile this driver as a module, choose M here: the
           module will be called vpif.
 
+config VIDEO_DAVINCI_DISPLAY
+	tristate "Davinci V4L2 Video Display"
+	depends on VIDEO_DEV && ARCH_DAVINCI
+	select VIDEOBUF_VMALLOC
+	select DAVINCI_OSD
+	help
+	  V4L2 Display driver support for davinci.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called davinci_display.
+
+config DAVINCI_ENC_MNGR
+	tristate "Davinci Encoder Manager support"
+	depends on ARCH_DAVINCI
+	default y
+	help
+	  Enable support for the DaVinci Encoder Manager. This is responsible
+	  for managing output and video/graphics modes for davinci video drivers.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called davinci_enc_mngr
+
+config ENC_MNGR_MAX_CHANNELS
+	int "Max number of channels for Encoder Manager"
+	depends on DAVINCI_ENC_MNGR
+	default "1"
+	help
+	  Used to give max number of channels supported by encoder manager
+	  driver.
+
+config DAVINCI_OSD
+	tristate "Davinci Display Manager"
+	help
+	  Support for Davinci On-Screen Display Manager.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called davinci_osd.
+
+config DAVINCI_VPBE_ENCODER
+	tristate "Davinci VPBE Encoder support"
+	depends on DAVINCI_ENC_MNGR
+	default y
+	help
+	  Enable support for the DaVinci VPBE internal encoder. DaVinci VPBE
+	  has internal VENC and DAC to output analog SD outputs (composite,
+	  S-Video and Component video outputs).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpbe_encoder.
+
+config DAVINCI_LOGICPD_ENCODER
+	tristate "Logic PD Encoder support"
+	depends on (DAVINCI_ENC_MNGR)
+	default y
+	help
+	  Enable support for the Logic PD encoder.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called logicpd_encoder.
+
+config DAVINCI_AVNET_ENCODER
+	tristate "AVNET LCD Encoder support"
+	depends on (DAVINCI_ENC_MNGR)
+	default y
+	help
+	  Enable support for the DaVinci AVNET LCD encoder. It uses a Toshiba LTA070A321F
+	  800x480 WVGA LCD module.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called avnetlcd_encoder.
+
 config VIDEO_VIVI
 	tristate "Virtual Video Driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
@@ -518,6 +589,13 @@ config VIDEO_VIVI
 	  Say Y here if you want to test video apps or debug V4L devices.
 	  In doubt, say N.
 
+config VIDEO_VPSS_SYSTEM
+	tristate "VPSS System module driver"
+	depends on ARCH_DAVINCI
+	help
+	  Support for vpss system module for video driver
+	default y
+
 config VIDEO_VPFE_CAPTURE
 	tristate "VPFE Video Capture Driver"
 	depends on VIDEO_V4L2 && ARCH_DAVINCI
diff --git a/drivers/media/video/davinci/Makefile b/drivers/media/video/davinci/Makefile
index 45edcde..f08b5f7 100644
--- a/drivers/media/video/davinci/Makefile
+++ b/drivers/media/video/davinci/Makefile
@@ -1,6 +1,8 @@
 #
 # Makefile for the davinci video device drivers.
 #
+# Capture: DM6446, DM355, DM365
+obj-$(CONFIG_VIDEO_VPSS_SYSTEM) += vpss.o
 
 # Capture: DaVinci and DM355
 obj-$(CONFIG_VIDEO_DAVINCI_CCDC) += ccdc_davinci.o
@@ -16,3 +18,13 @@ obj-$(CONFIG_VIDEO_DAVINCI_VPIF) += vpif.o
 
 #DM646x EVM Display driver
 obj-$(CONFIG_DISPLAY_DAVINCI_DM646X_EVM) += vpif_display.o
+
+# DaVinci Encoder/Display Manager and Encoders
+obj-$(CONFIG_DAVINCI_OSD)		+= davinci_osd.o davinci_platform.o
+obj-$(CONFIG_DAVINCI_ENC_MNGR)		+= davinci_enc_mngr.o
+
+obj-$(CONFIG_DAVINCI_LOGICPD_ENCODER)	+= logicpd_encoder.o
+obj-$(CONFIG_DAVINCI_AVNET_ENCODER)	+= avnetlcd_encoder.o
+obj-$(CONFIG_DAVINCI_VPBE_ENCODER)	+= vpbe_encoder.o
+
+obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY)	+= davinci_display.o
diff --git a/drivers/media/video/davinci/avnetlcd_encoder.c b/drivers/media/video/davinci/avnetlcd_encoder.c
new file mode 100644
index 0000000..e4065f7
--- /dev/null
+++ b/drivers/media/video/davinci/avnetlcd_encoder.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* logicpd_encoder.c. This is just a place holder for hardcoding all supported
+   modes timing. LogicPD timing signals are programmed by the encoder manager
+   based on this data.
+ */
+
+/* Kernel Specific header files */
+
+#include <linux/kernel.h>
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/avnetlcd_encoder.h>
+
+/* Function prototypes */
+static int avnetlcd_encoder_initialize(struct vid_encoder_device *enc,
+				       int flag);
+static int avnetlcd_encoder_deinitialize(struct vid_encoder_device *enc);
+
+static int avnetlcd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				    struct vid_encoder_device *enc);
+static int avnetlcd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				    struct vid_encoder_device *enc);
+
+static int avnetlcd_encoder_setoutput(char *output,
+				      struct vid_encoder_device *enc);
+static int avnetlcd_encoder_getoutput(char *output,
+				      struct vid_encoder_device *enc);
+
+static int avnetlcd_encoder_enumoutput(int index,
+				       char *output,
+				       struct vid_encoder_device *enc);
+
+static struct avnetlcd_encoder_config avnetlcd_encoder_configuration = {
+	.no_of_outputs = AVNETLCD_ENCODER_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_LCD1,
+		      .no_of_standard = AVNETLCD_ENCODER_GRAPHICS_NUM_STD,
+		      .standards[0] = {
+				       .name = VID_ENC_STD_800x480,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 800,
+				       .yres = 480,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 32,
+				       .lower_margin = 11,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 0},
+		      },	/* hsync -ve, vsync -ve */
+};
+
+static struct avnetlcd_encoder_channel avnetlcd_encoder_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_800x480,
+	.enc_device = NULL
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = AVNETLCD_ENCODER_MAX_NO_OUTPUTS,
+	.enumoutput = avnetlcd_encoder_enumoutput,
+	.setoutput = avnetlcd_encoder_setoutput,
+	.getoutput = avnetlcd_encoder_getoutput
+};
+
+static struct vid_enc_mode_ops modes_ops = {
+	.setmode = avnetlcd_encoder_setmode,
+	.getmode = avnetlcd_encoder_getmode,
+};
+
+static struct vid_encoder_device avnetlcd_encoder_dev = {
+	.name = "AVNETLCD_ENCODER",
+	.capabilities = 0,
+	.initialize = avnetlcd_encoder_initialize,
+	.mode_ops = &modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = NULL,
+	.deinitialize = avnetlcd_encoder_deinitialize,
+};
+
+/*
+ * This function is called by the encoder manager to initialize
+ * avnetlcd encoder driver.
+ */
+static int avnetlcd_encoder_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0, outindex;
+	char *std, *output;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	avnetlcd_encoder_channel_info.enc_device = (struct encoder_device *)enc;
+
+	/* call set standard */
+	std = avnetlcd_encoder_channel_info.params.mode;
+	outindex = avnetlcd_encoder_channel_info.params.outindex;
+	output = avnetlcd_encoder_configuration.output[outindex].output_name;
+	err |= avnetlcd_encoder_setoutput(output, enc);
+	if (err < 0) {
+		err = -EINVAL;
+		printk(KERN_ERR "Error occured in setoutput\n");
+		avnetlcd_encoder_deinitialize(enc);
+		return err;
+	}
+	printk(KERN_DEBUG "Avnetlcd Encoder initialized\n");
+	return err;
+}
+
+/* Function to de-initialize the encoder */
+static int avnetlcd_encoder_deinitialize(struct vid_encoder_device *enc)
+{
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	avnetlcd_encoder_channel_info.enc_device = NULL;
+	printk(KERN_DEBUG "Avnetlcd Encoder de-initialized\n");
+	return 0;
+}
+
+/* Following function is used to set the mode*/
+static int avnetlcd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				    struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i;
+	char *mode;
+	struct vid_enc_mode_info *my_mode_info = NULL;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	mode = mode_info->name;
+	if (NULL == mode) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "Start of avnetlcd_encoder_setmode..\n");
+	outindex = avnetlcd_encoder_channel_info.params.outindex;
+
+	if (mode_info->std) {
+		char *mymode = NULL;
+		/* This is a standard mode */
+		for (i = 0;
+		     i <
+		     avnetlcd_encoder_configuration.output[outindex].
+		     no_of_standard; i++) {
+			if (!strcmp
+			    (avnetlcd_encoder_configuration.output[outindex].
+			     standards[i].name, mode)) {
+				mymode =
+				    avnetlcd_encoder_configuration.
+				    output[outindex].standards[i].name;
+				break;
+			}
+		}
+		if ((i ==
+		     avnetlcd_encoder_configuration.output[outindex].
+		     no_of_standard) || (NULL == mymode)) {
+			printk(KERN_ERR "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of avnetlcd_encoder */
+		avnetlcd_encoder_channel_info.params.mode = mymode;
+		return 0;
+	} else {
+		/* Non- Standard mode. Check if we support it. If so
+		   save the timing info and return */
+		for (i = 0; i < AVNETLCD_ENCODER_GRAPHICS_NUM_STD; i++) {
+			if (!strcmp
+			    (avnetlcd_encoder_configuration.output[outindex].
+			     standards[i].name, VID_ENC_STD_NON_STANDARD)) {
+				my_mode_info =
+				    &avnetlcd_encoder_configuration.
+				    output[outindex].standards[i];
+				break;
+			}
+		}
+		if (my_mode_info) {
+			/* We support. So save timing info and return success
+			   interface type is same as what is currently is active
+			 */
+			my_mode_info->interlaced = mode_info->interlaced;
+			my_mode_info->xres = mode_info->xres;
+			my_mode_info->yres = mode_info->yres;
+			my_mode_info->fps = mode_info->fps;
+			my_mode_info->left_margin = mode_info->left_margin;
+			my_mode_info->right_margin = mode_info->right_margin;
+			my_mode_info->upper_margin = mode_info->upper_margin;
+			my_mode_info->lower_margin = mode_info->lower_margin;
+			my_mode_info->hsync_len = mode_info->hsync_len;
+			my_mode_info->vsync_len = mode_info->vsync_len;
+			my_mode_info->flags = mode_info->flags;
+			/*
+       * If we need to configure something in the encoder module,
+       * we need to do this here
+			 */
+			return 0;
+		}
+		printk(KERN_ERR "Mode not supported..\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</avnetlcd_encoder_setmode>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected mode.*/
+static int avnetlcd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				    struct vid_encoder_device *enc)
+{
+	int err = 0, i, outindex;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<avnetlcd_encoder_getmode>\n");
+	outindex = avnetlcd_encoder_channel_info.params.outindex;
+	for (i = 0; i < AVNETLCD_ENCODER_GRAPHICS_NUM_STD; i++) {
+		if (!strcmp(avnetlcd_encoder_channel_info.params.mode,
+			    avnetlcd_encoder_configuration.output[outindex].
+			    standards[i].name)) {
+			memcpy(mode_info,
+			       &avnetlcd_encoder_configuration.output[outindex].
+			       standards[i], sizeof(struct vid_enc_mode_info));
+			break;
+		}
+	}
+	if (i == AVNETLCD_ENCODER_GRAPHICS_NUM_STD) {
+		printk(KERN_ERR "Wiered. No mode info\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</avnetlcd_encoder_getmode>\n");
+	return err;
+}
+
+/* For Avnetlcd, we have only one output, called LCD, we
+   always set this to this at init
+*/
+static int avnetlcd_encoder_setoutput(char *output,
+				      struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	printk(KERN_DEBUG "<avnetlcd_encoder_setoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output: NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Just check if the default output match with this output name */
+	if (strcmp
+	    (avnetlcd_encoder_configuration.output[0].output_name, output)) {
+		printk(KERN_ERR "no matching output found.\n");
+		return -EINVAL;
+	}
+	avnetlcd_encoder_channel_info.params.mode
+	    = avnetlcd_encoder_configuration.output[0].standards[0].name;
+
+	my_mode_info = &avnetlcd_encoder_configuration.output[0].standards[0];
+	err |= avnetlcd_encoder_setmode(my_mode_info, enc);
+	if (err < 0) {
+		printk(KERN_ERR "Error in setting default mode\n");
+		return err;
+	}
+	printk(KERN_DEBUG "</avnetlcd_encoder_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get output name of current output.*/
+static int avnetlcd_encoder_getoutput(char *output,
+				      struct vid_encoder_device *enc)
+{
+	int err = 0, index, len;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<avnetlcd_encoder_getoutput>\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = avnetlcd_encoder_channel_info.params.outindex;
+	len = strlen(avnetlcd_encoder_configuration.output[index].output_name);
+	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
+		len = VID_ENC_NAME_MAX_CHARS - 1;
+	strncpy(output,
+		avnetlcd_encoder_configuration.output[index].output_name, len);
+	output[len] = '\0';
+	printk(KERN_DEBUG "</avnetlcd_encoder_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information in the output. */
+static int avnetlcd_encoder_enumoutput(int index, char *output,
+				       struct vid_encoder_device *enc)
+{
+	int err = 0;
+
+	printk(KERN_DEBUG "<avnetlcd_encoder_enumoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= avnetlcd_encoder_configuration.no_of_outputs)
+		return -EINVAL;
+
+	strncpy(output,
+		avnetlcd_encoder_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	printk(KERN_DEBUG "</avnetlcd_encoder_enumoutput>\n");
+	return err;
+}
+
+/* This function used to initialize the Avnetlcd encoder driver */
+static int avnetlcd_encoder_init(void)
+{
+	int err = 0;
+
+	err = vid_enc_register_encoder(&avnetlcd_encoder_dev);
+	printk(KERN_NOTICE "Avnetlcd encoder initialized\n");
+	return err;
+}
+
+/* Function used to cleanup Avnetlcd encoder driver */
+static void avnetlcd_encoder_cleanup(void)
+{
+	vid_enc_unregister_encoder(&avnetlcd_encoder_dev);
+}
+
+subsys_initcall_sync(avnetlcd_encoder_init);
+module_exit(avnetlcd_encoder_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/davinci/davinci_display.c b/drivers/media/video/davinci/davinci_display.c
new file mode 100644
index 0000000..1c1e845
--- /dev/null
+++ b/drivers/media/video/davinci/davinci_display.c
@@ -0,0 +1,1868 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-device.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <asm/pgtable.h>
+#include <mach/cpu.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/davinci_display.h>
+
+#define DAVINCI_DISPLAY_DRIVER "davinci_v4l2"
+#define DM355_EVM_CARD  "DM355 EVM"
+#define DM644X_EVM_CARD "DM644X EVM"
+#define DM365_EVM_CARD  "DM365 EVM"
+
+static u32 video2_numbuffers = 3;
+static u32 video3_numbuffers = 3;
+
+#define DAVINCI_DISPLAY_HD_BUF_SIZE (1280*720*2)
+#define DAVINCI_DISPLAY_SD_BUF_SIZE (720*576*2)
+
+static u32 video2_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+static u32 video3_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+
+module_param(video2_numbuffers, uint, S_IRUGO);
+module_param(video3_numbuffers, uint, S_IRUGO);
+
+module_param(video2_bufsize, uint, S_IRUGO);
+module_param(video3_bufsize, uint, S_IRUGO);
+
+#define DAVINCI_DEFAULT_NUM_BUFS 3
+static struct buf_config_params display_buf_config_params = {
+	.min_numbuffers = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[0] = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[1] = DAVINCI_DEFAULT_NUM_BUFS,
+	.min_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.min_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.layer_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+};
+
+static int davinci_display_nr[] = { 2, 3 };
+
+/* global variables */
+static struct davinci_display davinci_dm;
+
+struct device *davinci_display_dev = NULL;
+
+static struct v4l2_capability davinci_display_videocap = {
+	.driver = DAVINCI_DISPLAY_DRIVER,
+	.bus_info = "Platform",
+	.version = DAVINCI_DISPLAY_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING
+};
+
+static struct v4l2_fract ntsc_aspect = DAVINCI_DISPLAY_PIXELASPECT_NTSC;
+static struct v4l2_fract pal_aspect = DAVINCI_DISPLAY_PIXELASPECT_PAL;
+static struct v4l2_fract sp_aspect = DAVINCI_DISPLAY_PIXELASPECT_SP;
+
+static struct v4l2_rect ntsc_bounds = DAVINCI_DISPLAY_WIN_NTSC;
+static struct v4l2_rect pal_bounds = DAVINCI_DISPLAY_WIN_PAL;
+static struct v4l2_rect vga_bounds = DAVINCI_DISPLAY_WIN_640_480;
+static struct v4l2_rect hd_720p_bounds = DAVINCI_DISPLAY_WIN_720P;
+static struct v4l2_rect hd_1080i_bounds = DAVINCI_DISPLAY_WIN_1080I;
+
+/*
+ * davinci_uservirt_to_phys()
+ * This inline function is used to convert user space virtual address
+ * to physical address.
+ */
+static inline u32 davinci_uservirt_to_phys(u32 virtp)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long physp = 0;
+	struct vm_area_struct *vma;
+
+	vma = find_vma(mm, virtp);
+
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET)
+		physp = virt_to_phys((void *)virtp);
+	else if (vma && (vma->vm_flags & VM_IO) && (vma->vm_pgoff))
+		/* this will catch, kernel-allocated, mmaped-to-usermode addr */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages)
+			physp = __pa(page_address(&pages[0]) +
+				     (virtp & ~PAGE_MASK));
+		else {
+			dev_dbg(davinci_display_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+	return physp;
+}
+
+/*
+ * davinci_buffer_prepare()
+ * This is the callback function called from videobuf_qbuf() function
+ * the buffer is prepared and user space virtual address is converted into
+ * physical address
+ */
+static int davinci_buffer_prepare(struct videobuf_queue *q,
+				  struct videobuf_buffer *vb,
+				  enum v4l2_field field)
+{
+	unsigned long addr;
+	int ret = 0;
+
+	dev_dbg(davinci_display_dev, "<davinci_buffer_prepare>\n");
+
+	/* If buffer is not initialized, initialize it */
+	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+		vb->width = davinci_dm.mode_info.xres;
+		vb->height = davinci_dm.mode_info.yres;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+
+		ret = videobuf_iolock(q, vb, NULL);
+		if (ret < 0)
+			goto buf_align_exit;
+
+		addr = videobuf_to_dma_contig(vb);
+
+		if (q->streaming) {
+			if (!ISALIGNED(addr)) {
+				dev_err(davinci_display_dev, "buffer_prepare:offset is \
+					not aligned to 32 bytes\n");
+				goto buf_align_exit;
+			}
+		}
+		vb->state = VIDEOBUF_PREPARED;
+	}
+
+	return 0;
+
+buf_align_exit:
+	return -EINVAL;
+}
+/*
+ * davinci_buffer_setup()
+ * This function allocates memory for the buffers
+ */
+static int davinci_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+				unsigned int *size)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "<davinci_buffer_setup>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory)
+		return 0;
+
+	/* Calculate the size of the buffer */
+	*size = display_buf_config_params.layer_bufsize[layer->device_id];
+	/* Store number of buffers allocated in numbuffer member */
+	if (*count < display_buf_config_params.min_numbuffers)
+		*count = layer->numbuffers = display_buf_config_params.numbuffers[layer->device_id];
+	dev_dbg(davinci_display_dev, "</davinci_buffer_setup>\n");
+	return 0;
+}
+
+/*
+ * davinci_buffer_queue()
+ * This function adds the buffer to DMA queue
+ */
+static void davinci_buffer_queue(struct videobuf_queue *q,
+				 struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_queue>\n");
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &layer->dma_queue);
+	/* Change state of the buffer */
+	vb->state = VIDEOBUF_QUEUED;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_queue>\n");
+}
+
+/*
+ * davinci_buffer_release()
+ * This function is called from the videobuf layer to free memory allocated to
+ * the buffers
+ */
+static void davinci_buffer_release(struct videobuf_queue *q,
+				   struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int buf_size = 0;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_release>\n");
+
+	if (V4L2_MEMORY_USERPTR != layer->memory)
+		videobuf_dma_contig_free(q, vb);
+
+	vb->state = VIDEOBUF_NEEDS_INIT;
+
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory)
+		return;
+	/* Calculate the size of the buffer */
+	buf_size = display_buf_config_params.layer_bufsize[layer->device_id];
+
+	dev_dbg(davinci_display_dev, "</davinci_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = davinci_buffer_setup,
+	.buf_prepare = davinci_buffer_prepare,
+	.buf_queue = davinci_buffer_queue,
+	.buf_release = davinci_buffer_release,
+};
+
+static u8 layer_first_int = 1;
+
+/* davinci_display_isr()
+ * ISR function. It changes status of the displayed buffer, takes next buffer
+ * from the queue and sets its address in VPBE registers
+ */
+static void davinci_display_isr(unsigned int event, void *dispObj)
+{
+	unsigned long jiffies_time = get_jiffies_64();
+	struct timeval timevalue;
+	int i, fid;
+	unsigned long addr = 0;
+	struct display_obj *layer = NULL;
+	struct davinci_display *dispDevice = (struct davinci_display *)dispObj;
+
+	/* Convert time represention from jiffies to timeval */
+	jiffies_to_timeval(jiffies_time, &timevalue);
+
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		layer = dispDevice->dev[i];
+		/* If streaming is started in this layer */
+		if (!layer->started)
+			continue;
+		/* Check the field format */
+		if ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&
+		    (!list_empty(&layer->dma_queue)) &&
+		    (event & DAVINCI_DISP_END_OF_FRAME)) {
+			/* Progressive mode */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				continue;
+			} else {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it
+				 */
+				layer->curFrm->ts = timevalue;
+				layer->curFrm->state = VIDEOBUF_DONE;
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				layer->curFrm = layer->nextFrm;
+			}
+			/* Get the next buffer from buffer queue */
+			layer->nextFrm =
+			    list_entry(layer->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&layer->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			layer->nextFrm->state = VIDEOBUF_ACTIVE;
+			
+			addr = videobuf_to_dma_contig(layer->nextFrm);
+			davinci_disp_start_layer(layer->layer_info.id,
+						 addr,
+						 davinci_dm.cbcr_ofst);
+		} else {
+			/* Interlaced mode
+			 * If it is first interrupt, ignore it
+			 */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				return;
+			}
+
+			layer->field_id ^= 1;
+			if (event & DAVINCI_DISP_FIRST_FIELD)
+				fid = 0;
+			else if (event & DAVINCI_DISP_SECOND_FIELD)
+				fid = 1;
+			else
+				return;
+
+			/* If field id does not match with stored
+			 * field id
+			 */
+			if (fid != layer->field_id) {
+				/* Make them in sync */
+				if (0 == fid) {
+					layer->field_id = fid;
+				}
+				return;
+			}
+			/* device field id and local field id are
+			 * in sync. If this is even field
+			 */
+			if (0 == fid) {
+				if (layer->curFrm == layer->nextFrm)
+					continue;
+				/* one frame is displayed If next frame is
+				 * available, release curFrm and move on
+				 * Copy frame display time
+				 */
+				layer->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				layer->curFrm->state = VIDEOBUF_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to
+				 * nextFrm
+				 */
+				layer->curFrm = layer->nextFrm;
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&layer->dma_queue)
+				    || (layer->curFrm != layer->nextFrm))
+					continue;
+
+				/* one field is displayed configure
+				 * the next frame if it is available
+				 * otherwise hold on current frame
+				 * Get next from the buffer queue
+				 */
+				layer->nextFrm = list_entry(layer->
+							    dma_queue.
+							    next, struct
+							    videobuf_buffer,
+							    queue);
+
+				/* Remove that from the
+				 * buffer queue
+				 */
+				list_del(&layer->nextFrm->queue);
+
+				/* Mark state of the frame
+				 * to active
+				 */
+				layer->nextFrm->state = VIDEOBUF_ACTIVE;
+
+				addr = videobuf_to_dma_contig(layer->nextFrm);
+				davinci_disp_start_layer(layer->layer_info.id,
+							addr,
+							davinci_dm.cbcr_ofst);
+			}
+		}
+	}
+}
+
+static struct display_obj*
+_davinci_disp_get_other_win(struct display_obj *layer)
+{
+	enum davinci_display_device_id thiswin, otherwin;
+	thiswin = layer->device_id;
+
+	otherwin = (thiswin == DAVINCI_DISPLAY_DEVICE_0) ?
+		DAVINCI_DISPLAY_DEVICE_1 : DAVINCI_DISPLAY_DEVICE_0;
+	return davinci_dm.dev[otherwin];
+}
+
+static int davinci_config_layer(enum davinci_display_device_id id);
+
+static int davinci_set_video_display_params(struct display_obj *layer)
+{
+	unsigned long addr;
+
+	addr = videobuf_to_dma_contig(layer->curFrm);
+	/* Set address in the display registers */
+	davinci_disp_start_layer(layer->layer_info.id,
+				 addr,
+				 davinci_dm.cbcr_ofst);
+	davinci_disp_enable_layer(layer->layer_info.id, 0);
+	/* Enable the window */
+	layer->layer_info.enable = 1;
+	if (layer->layer_info.config.pixfmt == PIXFMT_NV12) {
+		struct display_obj *otherlayer =
+			_davinci_disp_get_other_win(layer);
+		davinci_disp_enable_layer(otherlayer->layer_info.id, 1);
+		otherlayer->layer_info.enable = 1;
+	}
+	return 0;
+}
+
+static void davinci_disp_calculate_scale_factor(struct display_obj *layer,
+						int expected_xsize,
+						int expected_ysize)
+{
+	struct display_layer_info *layer_info = &layer->layer_info;
+	struct v4l2_pix_format *pixfmt = &layer->pix_fmt;
+	int h_scale = 0, v_scale = 0, h_exp = 0, v_exp = 0, temp;
+	/* Application initially set the image format. Current display
+	 * size is obtained from the encoder manager. expected_xsize
+	 * and expected_ysize are set through S_CROP ioctl. Based on this,
+	 * driver will calculate the scale factors for vertical and
+	 * horizontal direction so that the image is displayed scaled
+	 * and expanded. Application uses expansion to display the image
+	 * in a square pixel. Otherwise it is displayed using displays
+	 * pixel aspect ratio.It is expected that application chooses
+	 * the crop coordinates for cropped or scaled display. if crop
+	 * size is less than the image size, it is displayed cropped or
+	 * it is displayed scaled and/or expanded.
+	 *
+	 * to begin with, set the crop window same as expected. Later we
+	 * will override with scaled window size
+	 */
+	layer->layer_info.config.xsize = pixfmt->width;
+	layer->layer_info.config.ysize = pixfmt->height;
+	layer_info->h_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->v_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->h_exp = H_EXP_OFF;	/* no horizontal zoom */
+	layer_info->v_exp = V_EXP_OFF;	/* no horizontal zoom */
+
+	if (pixfmt->width < expected_xsize) {
+		h_scale = davinci_dm.mode_info.xres / pixfmt->width;
+		if (h_scale < 2)
+			h_scale = 1;
+		else if (h_scale >= 4)
+			h_scale = 4;
+		else
+			h_scale = 2;
+		layer->layer_info.config.xsize *= h_scale;
+		if (layer->layer_info.config.xsize < expected_xsize) {
+			if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)
+			    || !strcmp(davinci_dm.mode_info.name,
+				       VID_ENC_STD_PAL)) {
+				temp =
+				    (layer->layer_info.config.xsize *
+				     DAVINCI_DISPLAY_H_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_H_EXP_RATIO_D;
+				if (temp <= expected_xsize) {
+					h_exp = 1;
+					layer->layer_info.config.xsize = temp;
+				}
+			}
+		}
+		if (h_scale == 2)
+			layer_info->h_zoom = ZOOM_X2;
+		else if (h_scale == 4)
+			layer_info->h_zoom = ZOOM_X4;
+		if (h_exp)
+			layer_info->h_exp = H_EXP_9_OVER_8;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.xsize = expected_xsize;
+	}
+
+	if (pixfmt->height < expected_ysize) {
+		v_scale = expected_ysize / pixfmt->height;
+		if (v_scale < 2)
+			v_scale = 1;
+		else if (v_scale >= 4)
+			v_scale = 4;
+		else
+			v_scale = 2;
+		layer->layer_info.config.ysize *= v_scale;
+		if (layer->layer_info.config.ysize < expected_ysize) {
+			if (!strcmp(davinci_dm.mode_info.name, "PAL")) {
+				temp =
+				    (layer->layer_info.config.ysize *
+				     DAVINCI_DISPLAY_V_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_V_EXP_RATIO_D;
+				if (temp <= expected_ysize) {
+					v_exp = 1;
+					layer->layer_info.config.ysize = temp;
+				}
+			}
+		}
+		if (v_scale == 2)
+			layer_info->v_zoom = ZOOM_X2;
+		else if (v_scale == 4)
+			layer_info->v_zoom = ZOOM_X4;
+		if (v_exp)
+			layer_info->h_exp = V_EXP_6_OVER_5;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.ysize = expected_ysize;
+	}
+	dev_dbg(davinci_display_dev,
+		"crop display xsize = %d, ysize = %d\n",
+		layer->layer_info.config.xsize, layer->layer_info.config.ysize);
+}
+
+static void davinci_disp_adj_position(struct display_obj *layer, int top,
+				      int left)
+{
+	layer->layer_info.config.xpos = 0;
+	layer->layer_info.config.ypos = 0;
+	if (left + layer->layer_info.config.xsize <= davinci_dm.mode_info.xres)
+		layer->layer_info.config.xpos = left;
+	if (top + layer->layer_info.config.ysize <= davinci_dm.mode_info.yres)
+		layer->layer_info.config.ypos = top;
+	dev_dbg(davinci_display_dev,
+		"new xpos = %d, ypos = %d\n",
+		layer->layer_info.config.xpos, layer->layer_info.config.ypos);
+}
+
+static int davinci_disp_check_window_params(struct v4l2_rect *c)
+{
+	if ((c->width == 0)
+	    || ((c->width + c->left) > davinci_dm.mode_info.xres)
+	    || (c->height == 0)
+	    || ((c->height + c->top) > davinci_dm.mode_info.yres)) {
+		dev_err(davinci_display_dev, "Invalid crop values\n");
+		return -1;
+	}
+	if ((c->height & 0x1) && (davinci_dm.mode_info.interlaced)) {
+		dev_err(davinci_display_dev,
+			"window height must be even for interlaced display\n");
+		return -1;
+	}
+	return 0;
+}
+
+/* vpbe_try_format()
+ * If user application provides width and height, and have bytesperline set
+ * to zero, driver calculates bytesperline and sizeimage based on hardware
+ * limits. If application likes to add pads at the end of each line and
+ * end of the buffer , it can set bytesperline to line size and sizeimage to
+ * bytesperline * height of the buffer. If driver fills zero for active
+ * video width and height, and has requested user bytesperline and sizeimage,
+ * width and height is adjusted to maximum display limit or buffer width
+ * height which ever is lower
+ */
+static int vpbe_try_format(struct v4l2_pix_format *pixfmt, int check)
+{
+	struct vid_enc_mode_info *mode_info;
+	int min_sizeimage, bpp, min_height = 1, min_width = 32,
+		max_width, max_height, user_info = 0;
+
+	mode_info = &davinci_dm.mode_info;
+	davinci_enc_get_mode(0, mode_info);
+
+	if ((pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) &&
+	    (pixfmt->pixelformat != V4L2_PIX_FMT_NV12))
+		/* choose default as V4L2_PIX_FMT_UYVY */
+		pixfmt->pixelformat = V4L2_PIX_FMT_UYVY;
+
+	if (pixfmt->field == V4L2_FIELD_ANY) {
+		if (mode_info->interlaced)
+			pixfmt->field = V4L2_FIELD_INTERLACED;
+		else
+			pixfmt->field = V4L2_FIELD_NONE;
+	}
+
+	if (pixfmt->field == V4L2_FIELD_INTERLACED)
+		min_height = 2;
+
+	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)
+		bpp = 1;
+	else
+		bpp = 2;
+
+	max_width = mode_info->xres;
+	max_height = mode_info->yres;
+
+	min_width /= bpp;
+
+	if (!pixfmt->width && !pixfmt->bytesperline) {
+		dev_err(davinci_display_dev, "bytesperline and width"
+			" cannot be zero\n");
+		return -EINVAL;
+	}
+
+	/* if user provided bytesperline, it must provide sizeimage as well */
+	if (pixfmt->bytesperline && !pixfmt->sizeimage) {
+		dev_err(davinci_display_dev,
+			"sizeimage must be non zero, when user"
+			" provides bytesperline\n");
+		return -EINVAL;
+	}
+
+	/* adjust bytesperline as per hardware - multiple of 32 */
+	if (!pixfmt->width)
+		pixfmt->width = pixfmt->bytesperline / bpp;
+
+	if (!pixfmt->bytesperline)
+		pixfmt->bytesperline = pixfmt->width * bpp;
+	else
+		user_info = 1;
+	pixfmt->bytesperline = ((pixfmt->bytesperline + 31) & ~31);
+
+	if (pixfmt->width < min_width) {
+		if (check) {
+			dev_err(davinci_display_dev,
+				"height is less than minimum,"
+				"input width = %d, min_width = %d \n",
+				pixfmt->width, min_width);
+			return -EINVAL;
+		}
+		pixfmt->width = min_width;
+	}
+
+	if (pixfmt->width > max_width) {
+		if (check) {
+			dev_err(davinci_display_dev,
+				"width is more than maximum,"
+				"input width = %d, max_width = %d\n",
+				pixfmt->width, max_width);
+			return -EINVAL;
+		}
+		pixfmt->width = max_width;
+	}
+
+	/* If height is zero, then atleast we need to have sizeimage
+	 * to calculate height
+	 */
+	if (!pixfmt->height) {
+		if (user_info) {
+			if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12) {
+				/* for NV12 format, sizeimage is y-plane size
+				 * + CbCr plane which is half of y-plane
+				 */
+				pixfmt->height = pixfmt->sizeimage /
+						(pixfmt->bytesperline +
+						(pixfmt->bytesperline >> 1));
+			} else
+				pixfmt->height = pixfmt->sizeimage/
+						pixfmt->bytesperline;
+		}
+	}
+
+	if (pixfmt->height > max_height) {
+		if (check && !user_info) {
+			dev_err(davinci_display_dev,
+				"height is more than maximum,"
+				"input height = %d, max_height = %d\n",
+				pixfmt->height, max_height);
+			return -EINVAL;
+		}
+		pixfmt->height = max_height;
+	}
+
+	if (pixfmt->height < min_height) {
+		if (check && !user_info) {
+			dev_err(davinci_display_dev,
+				"width is less than minimum,"
+				"input height = %d, min_height = %d\n",
+				pixfmt->height, min_height);
+			return -EINVAL;
+		}
+		pixfmt->height = min_width;
+	}
+
+	/* if user has not provided bytesperline calculate it based on width */
+	if (!user_info)
+		pixfmt->bytesperline = (((pixfmt->width * bpp) + 31) & ~31);
+
+	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)
+		min_sizeimage = pixfmt->bytesperline * pixfmt->height +
+				(pixfmt->bytesperline * pixfmt->height >> 1);
+	else
+		min_sizeimage = pixfmt->bytesperline * pixfmt->height;
+
+	if (pixfmt->sizeimage < min_sizeimage) {
+		if (check && user_info) {
+			dev_err(davinci_display_dev, "sizeimage is less, %d\n",
+				min_sizeimage);
+			return -EINVAL;
+		}
+		pixfmt->sizeimage = min_sizeimage;
+	}
+	return 0;
+}
+
+static int vpbe_g_priority(struct file *file, void *priv,
+				enum v4l2_priority *p)
+{
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	*p = v4l2_prio_max(&layer->prio);
+
+	return 0;
+}
+
+static int vpbe_s_priority(struct file *file, void *priv,
+				enum v4l2_priority p)
+{
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+	int ret;
+
+	ret = v4l2_prio_change(&layer->prio, &fh->prio, p);
+
+	return ret;
+}
+
+static int vpbe_querycap(struct file *file, void  *priv,
+			       struct v4l2_capability *cap)
+{
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_QUERYCAP, layer id = %d\n",
+			layer->device_id);
+	
+	memset(cap, 0, sizeof(*cap));
+	*cap = davinci_display_videocap;
+
+	return 0;
+}
+
+static int vpbe_s_crop(struct file *file, void *priv,
+			     struct v4l2_crop *crop)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev,
+				"VIDIOC_S_CROP, layer id = %d\n",
+				layer->device_id);
+
+	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		struct v4l2_rect *rect = &crop->c;
+
+		if (rect->top < 0 || rect->left < 0) {
+			dev_err(davinci_display_dev,
+					"Error in S_CROP params"
+					" Negative values for"
+					" top/left" );
+			return -EINVAL;
+
+		}
+
+		if (davinci_disp_check_window_params(rect)) {
+			dev_err(davinci_display_dev,
+					"Error in S_CROP params\n");
+					return -EINVAL;
+		}
+		ret = mutex_lock_interruptible(&davinci_dm.lock);
+		if (ret)
+			return ret;
+				
+		davinci_disp_get_layer_config(layer->layer_info.id,
+						&layer->layer_info.config);
+
+		davinci_disp_calculate_scale_factor(layer, rect->width,
+							rect->height);
+
+		davinci_disp_adj_position(layer, rect->top, rect->left);
+
+		if (davinci_disp_set_layer_config(layer->layer_info.id,
+			&layer->layer_info.config)) {
+		
+			dev_err(davinci_display_dev,
+					"Error in S_CROP params\n");
+			mutex_unlock(&davinci_dm.lock);
+			return -EINVAL;
+		}
+
+		/* apply zooming and h or v expansion */
+		davinci_disp_set_zoom(layer->layer_info.id,
+				     layer->layer_info.h_zoom,
+				     layer->layer_info.v_zoom);
+
+		davinci_disp_set_vid_expansion(layer->layer_info.h_exp,
+						layer->layer_info.v_exp);
+
+		if ((layer->layer_info.h_zoom != ZOOM_X1) ||
+			(layer->layer_info.v_zoom != ZOOM_X1) ||
+			(layer->layer_info.h_exp != H_EXP_OFF) ||
+			(layer->layer_info.v_exp != V_EXP_OFF))
+				/* Enable expansion filter */
+				davinci_disp_set_interpolation_filter(1);
+		else
+				davinci_disp_set_interpolation_filter(0);
+				mutex_unlock(&davinci_dm.lock);
+	} else {
+		dev_err(davinci_display_dev, "Invalid buf type \n");
+		return -EINVAL;
+	}
+	
+	return ret;
+}
+
+static int vpbe_g_crop(struct file *file, void *priv,
+			     struct v4l2_crop *crop)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+	
+	dev_dbg(davinci_display_dev, "VIDIOC_G_CROP, layer id = %d\n",
+			layer->device_id);
+
+	if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		struct v4l2_rect *rect = &crop->c;
+		ret = mutex_lock_interruptible(&davinci_dm.lock);
+		if (ret)
+			return ret;
+				
+		davinci_disp_get_layer_config(layer->layer_info.id,
+						&layer->layer_info.config);
+		rect->top = layer->layer_info.config.ypos;
+		rect->left = layer->layer_info.config.xpos;
+		rect->width = layer->layer_info.config.xsize;
+		rect->height = layer->layer_info.config.ysize;
+		mutex_unlock(&davinci_dm.lock);
+	} else {
+		dev_err(davinci_display_dev,"Invalid buf type \n");
+		ret = -EINVAL;
+	}
+	
+	return ret;
+}
+
+static int vpbe_cropcap(struct file *file, void *priv,
+			      struct v4l2_cropcap *cropcap)
+{
+	int ret = 0;
+
+	dev_dbg(davinci_display_dev, "\nStart of VIDIOC_CROPCAP ioctl");
+			
+	if (davinci_enc_get_mode(0, &davinci_dm.mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode"
+			" from enc mngr\n");
+		return -EINVAL;
+	}
+			
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+			
+	cropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)) {
+		cropcap->bounds = cropcap->defrect = ntsc_bounds;
+		cropcap->pixelaspect = ntsc_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_PAL)) {
+		cropcap->bounds = cropcap->defrect = pal_bounds;
+		cropcap->pixelaspect = pal_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name,VID_ENC_STD_640x480)) {
+		cropcap->bounds = cropcap->defrect = vga_bounds;
+		cropcap->pixelaspect = sp_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_640x400)) {
+		cropcap->bounds = cropcap->defrect = vga_bounds;
+		cropcap->bounds.height = cropcap->defrect.height = 400;
+		cropcap->pixelaspect = sp_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_640x350)) {
+		cropcap->bounds = cropcap->defrect = vga_bounds;
+		cropcap->bounds.height = cropcap->defrect.height = 350;
+		cropcap->pixelaspect = sp_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_720P_60)) {
+		cropcap->bounds = cropcap->defrect = hd_720p_bounds;
+		cropcap->pixelaspect = sp_aspect;
+	} else if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_1080I_30)) {
+		cropcap->bounds = cropcap->defrect = hd_1080i_bounds;
+		cropcap->pixelaspect = sp_aspect;
+	} else {
+		dev_err(davinci_display_dev, "Unknown encoder display mode\n");
+		return -EINVAL;
+	}
+	
+	mutex_unlock(&davinci_dm.lock);
+	dev_dbg(davinci_display_dev, "\nEnd of VIDIOC_CROPCAP ioctl");
+
+	return ret;
+}
+
+static int vpbe_streamoff(struct file *file, void *priv,
+			  enum v4l2_buf_type buf_type)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_STREAMOFF,layer id = %d\n",
+		layer->device_id);
+	/* If io is allowed for this file handle, return error */
+	if (!fh->io_allowed) {
+		dev_err(davinci_display_dev, "No io_allowed\n");
+		return -EACCES;
+	}
+			
+	/* If streaming is not started, return error */
+	if (!layer->started) {
+		dev_err(davinci_display_dev, "streaming not started in layer"
+			" id = %d\n", layer->device_id);
+		return -EINVAL;
+	}
+			
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+	davinci_disp_disable_layer(layer->layer_info.id);
+	layer->started = 0;
+	mutex_unlock(&davinci_dm.lock);
+	ret = videobuf_streamoff(&layer->buffer_queue);
+
+	return ret;
+}
+
+static int vpbe_streamon(struct file *file, void *priv,
+			 enum v4l2_buf_type buf_type)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_STREAMON, layer id = %d\n",
+			layer->device_id);
+	/* If file handle is not allowed IO, return error */
+	if (!fh->io_allowed) {
+		dev_err(davinci_display_dev, "No io_allowed\n");
+		return -EACCES;
+	}
+	/* If Streaming is already started, return error */
+	if (layer->started) {
+		dev_err(davinci_display_dev, "layer is already streaming\n");
+		return -EBUSY;
+	}
+
+	/*
+	 * Call videobuf_streamon to start streaming
+	 * in videobuf
+	 */
+	ret = videobuf_streamon(&layer->buffer_queue);
+	if (ret) {
+		dev_err(davinci_display_dev,
+		"error in videobuf_streamon\n");
+		return ret;
+	}
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+	/* If buffer queue is empty, return error */
+	if (list_empty(&layer->dma_queue)) {
+		dev_err(davinci_display_dev, "buffer queue is empty\n");
+		mutex_unlock(&davinci_dm.lock);
+		return -EIO;
+	}
+	/* Get the next frame from the buffer queue */
+	layer->nextFrm = layer->curFrm = list_entry(layer->dma_queue.next,
+				struct videobuf_buffer, queue);
+	/* Remove buffer from the buffer queue */
+	list_del(&layer->curFrm->queue);
+	/* Mark state of the current frame to active */
+	layer->curFrm->state = VIDEOBUF_ACTIVE;
+	/* Initialize field_id and started member */
+
+	layer->field_id = 0;
+
+	/* Set parameters in OSD and VENC */
+	ret = davinci_set_video_display_params(layer);
+	if (ret < 0) {
+		mutex_unlock(&davinci_dm.lock);
+		return ret;
+	}
+	/* if request format is yuv420 semiplanar, need to
+	 * enable both video windows
+	 */
+
+	layer->started = 1;
+	dev_dbg(davinci_display_dev, "Started streaming on layer id = %d,"
+		" ret = %d\n", layer->device_id, ret);
+			
+	layer_first_int = 1;
+	mutex_unlock(&davinci_dm.lock);
+
+	return ret;
+}
+
+static int vpbe_dqbuf(struct file *file, void *priv,
+		      struct v4l2_buffer *buf)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_DQBUF, layer id = %d\n",
+			layer->device_id);
+
+	/* If this file handle is not allowed to do IO, return error */
+	if (!fh->io_allowed) {
+		dev_err(davinci_display_dev, "No io_allowed\n");
+		return -EACCES;
+	}
+	if (file->f_flags & O_NONBLOCK)
+		/* Call videobuf_dqbuf for non blocking mode */
+		ret = videobuf_dqbuf(&layer->buffer_queue, buf, 1);
+	else
+		/* Call videobuf_dqbuf for blocking mode */
+		ret = videobuf_dqbuf(&layer->buffer_queue, buf, 0);
+
+	return ret;
+}
+
+static int vpbe_qbuf(struct file *file, void *priv,
+		     struct v4l2_buffer *p)
+{
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_QBUF, layer id = %d\n",
+		layer->device_id);
+
+	/* If this file handle is not allowed to do IO, return error */
+	if (!fh->io_allowed) {
+		dev_err(davinci_display_dev, "No io_allowed\n");
+		return -EACCES;
+	}
+
+	return videobuf_qbuf(&layer->buffer_queue, p);
+}
+
+static int vpbe_querybuf(struct file *file, void *priv,
+			 struct v4l2_buffer *buf)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_QUERYBUF, layer id = %d\n",
+			layer->device_id);
+
+	/* Call videobuf_querybuf to get information */
+	ret = videobuf_querybuf(&layer->buffer_queue, buf);
+
+	return ret;
+}
+
+static int vpbe_reqbufs(struct file *file, void *priv,
+			struct v4l2_requestbuffers *req_buf)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_REQBUFS, count= %d, type = %d,"
+			"memory = %d\n",
+			req_buf->count, req_buf->type, req_buf->memory);
+
+	/* If io users of the layer is not zero, return error */
+	if (0 != layer->io_usrs) {
+		dev_err(davinci_display_dev, "not IO user\n");
+		return -EBUSY;
+	}
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+	/* Initialize videobuf queue as per the buffer type */
+			
+	videobuf_queue_dma_contig_init(&layer->buffer_queue,
+					    &video_qops, davinci_display_dev,
+					    &layer->irqlock,
+					    V4L2_BUF_TYPE_VIDEO_OUTPUT,
+					    layer->pix_fmt.field,
+					    sizeof(struct videobuf_buffer), fh);
+
+	/* Set io allowed member of file handle to TRUE */
+	fh->io_allowed = 1;
+	/* Increment io usrs member of layer object to 1 */
+	layer->io_usrs = 1;
+	/* Store type of memory requested in layer object */
+	layer->memory = req_buf->memory;
+	/* Initialize buffer queue */
+	INIT_LIST_HEAD(&layer->dma_queue);
+	/* Allocate buffers */
+	ret = videobuf_reqbufs(&layer->buffer_queue, req_buf);
+	mutex_unlock(&davinci_dm.lock);
+
+	return ret;
+}
+
+static int vpbe_s_fmt(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_S_FMT, layer id = %d\n",
+			layer->device_id);
+
+	/* If streaming is started, return error */
+	if (layer->started) {
+		dev_err(davinci_display_dev, "Streaming is started\n");
+		return -EBUSY;
+	}
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+		/* Check for valid field format */
+		ret = vpbe_try_format(pixfmt, 1);
+		if (ret)
+			return ret;
+
+	/* YUV420 is requested, check availability of the other video window */
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+
+	layer->pix_fmt = *pixfmt;
+	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12 &&
+		cpu_is_davinci_dm365()) {
+		struct display_obj *otherlayer =
+			_davinci_disp_get_other_win(layer);
+
+		/* if other layer is available, only
+		 * claim it, do not configure it
+		 */
+		if (davinci_disp_request_layer(otherlayer->layer_info.id)) {
+			/* Couldn't get layer */
+			dev_err(davinci_display_dev,
+						"Display Manager"
+						" failed to allocate"
+						" the other layer:"
+						"vidwin %d\n",
+						otherlayer->
+						layer_info.id);
+			mutex_unlock(&davinci_dm.lock);
+			return -EBUSY;
+		}
+	}
+				
+	/* store the pixel format in the layer object */
+	davinci_disp_get_layer_config(layer->layer_info.id,
+		&layer->layer_info.config);
+
+	layer->layer_info.config.xsize = pixfmt->width;
+	layer->layer_info.config.ysize = pixfmt->height;
+	layer->layer_info.config.line_length = pixfmt->bytesperline;
+	layer->layer_info.config.ypos = 0;
+	layer->layer_info.config.xpos = 0;
+	layer->layer_info.config.interlaced =
+			davinci_dm.mode_info.interlaced;
+
+	/* change of the default pixel format for both vid windows */
+	if (V4L2_PIX_FMT_NV12 == pixfmt->pixelformat) {
+		struct display_obj *otherlayer;
+		layer->layer_info.config.pixfmt = PIXFMT_NV12;
+		otherlayer = _davinci_disp_get_other_win(layer);
+		otherlayer->layer_info.config.pixfmt = PIXFMT_NV12;
+	}
+
+	if (davinci_disp_set_layer_config(layer->layer_info.id,
+					&layer->layer_info.config)) {
+		dev_err(davinci_display_dev, "Error in S_FMT params:\n");
+		mutex_unlock(&davinci_dm.lock);
+		return -EINVAL;
+	}
+
+	/* readback and fill the local copy of current pix format */
+	davinci_disp_get_layer_config(layer->layer_info.id,
+					&layer->layer_info.config);
+		
+	/* verify if readback values are as expected */
+	if (layer->pix_fmt.width != layer->layer_info.config.xsize ||
+		layer->pix_fmt.height != layer->layer_info.config.ysize ||
+		layer->pix_fmt.bytesperline != layer->layer_info.config.line_length ||
+		(layer->layer_info.config.interlaced && layer->pix_fmt.field !=
+		V4L2_FIELD_INTERLACED) || (!layer->layer_info.config.interlaced &&
+		layer->pix_fmt.field != V4L2_FIELD_NONE)) {
+		dev_err(davinci_display_dev, "mismatch with layer config"
+				" params:\n");
+		dev_err(davinci_display_dev, "layer->layer_info.config.xsize ="
+				"%d layer->pix_fmt.width = %d\n",
+				layer->layer_info.config.xsize,
+				layer->pix_fmt.width);
+		dev_err(davinci_display_dev,
+				"layer->layer_info.config.ysize ="
+				"%d layer->pix_fmt.height = %d\n",
+				layer->layer_info.config.ysize,
+				layer->pix_fmt.height);
+		dev_err(davinci_display_dev, "layer->layer_info.config."
+				"line_length= %d layer->pix_fmt"
+				".bytesperline = %d\n",
+				layer->layer_info.config.line_length,
+				layer->pix_fmt.bytesperline);
+		dev_err(davinci_display_dev, "layer->layer_info.config."
+				"interlaced =%d layer->pix_fmt."
+				"field = %d\n", layer->layer_info.config.interlaced,
+				layer->pix_fmt.field);
+		mutex_unlock(&davinci_dm.lock);
+		return -EFAULT;
+	}
+
+		dev_notice(davinci_display_dev,
+				"Before finishing with S_FMT:\n"
+				"layer.pix_fmt.bytesperline = %d,\n"
+				" layer.pix_fmt.width = %d, \n"
+				" layer.pix_fmt.height = %d, \n"
+				" layer.pix_fmt.sizeimage =%d\n",
+				layer->pix_fmt.bytesperline,
+				layer->pix_fmt.width,
+				layer->pix_fmt.height,
+				layer->pix_fmt.sizeimage);
+
+		dev_notice(davinci_display_dev,
+				"pixfmt->width = %d,\n"
+				" layer->layer_info.config.line_length"
+				"= %d\n",
+				pixfmt->width,
+				layer->layer_info.config.line_length);
+
+		mutex_unlock(&davinci_dm.lock);
+	} else {
+		dev_err(davinci_display_dev, "invalid type\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int vpbe_try_fmt(struct file *file, void *priv,
+				  struct v4l2_format *fmt)
+{
+	int ret = 0;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_TRY_FMT\n");
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+		/* Check for valid field format */
+		ret = vpbe_try_format(pixfmt, 0);
+	} else {
+		dev_err(davinci_display_dev, "invalid type\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int vpbe_enum_fmt(struct file *file, void  *priv,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int index = 0;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_ENUM_FMT, layer id = %d\n",
+		layer->device_id);
+	if (fmt->index > 0) {
+		dev_err(davinci_display_dev,
+			"Invalid format index\n");
+		return -EINVAL;
+	}
+	/* Fill in the information about format */
+
+	index = fmt->index;
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (index == 0) {
+		strcpy(fmt->description, "YUV 4:2:2 - UYVY");
+		fmt->pixelformat = V4L2_PIX_FMT_UYVY;
+	} else if (index == 1) {
+		strcpy(fmt->description, "Y/CbCr 4:2:0");
+		fmt->pixelformat = V4L2_PIX_FMT_NV12;
+	}
+
+	return ret;
+}
+
+static int vpbe_g_fmt(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "VIDIOC_G_FMT, layer id = %d\n",
+			layer->device_id);
+
+	/* If buffer type is video output */
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+		/* Fill in the information about format */
+		ret = mutex_lock_interruptible(&davinci_dm.lock);
+		if (!ret) {
+			*pixfmt = layer->pix_fmt;
+			mutex_unlock(&davinci_dm.lock);
+		}
+	} else {
+		dev_err(davinci_display_dev, "invalid type\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static long vpbe_param_handler(struct file *file, void *priv,
+		int cmd, void *param)
+{
+	int ret = 0;
+
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+
+	switch (cmd) {
+	case VIDIOC_S_COFST:
+		davinci_dm.cbcr_ofst = *((unsigned long *) param);
+		mutex_unlock(&davinci_dm.lock);
+	
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/*
+ * davinci_mmap()
+ * It is used to map kernel space buffers into user spaces
+ */
+static int davinci_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+	int err = 0;
+	dev_dbg(davinci_display_dev, "<davinci_mmap>\n");
+
+	err = videobuf_mmap_mapper(&layer->buffer_queue, vma);
+	dev_dbg(davinci_display_dev, "</davinci_mmap>\n");
+	return err;
+}
+
+/* davinci_poll(): It is used for select/poll system call
+ */
+static unsigned int davinci_poll(struct file *filep, poll_table *wait)
+{
+	int err = 0;
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "<davinci_poll>");
+
+	if (layer->started)
+		err = videobuf_poll_stream(filep, &layer->buffer_queue, wait);
+	dev_dbg(davinci_display_dev, "</davinci_poll>");
+	return err;
+}
+
+static int davinci_config_layer(enum davinci_display_device_id id)
+{
+	int err = 0;
+	struct davinci_layer_config *layer_config;
+	struct vid_enc_mode_info *mode_info;
+	struct display_obj *layer = davinci_dm.dev[id];
+
+	/* First claim the layer for this device */
+	if (davinci_disp_request_layer(layer->layer_info.id)) {
+		/* Couldn't get layer */
+		dev_err(davinci_display_dev,
+			"Display Manager failed to allocate layer\n");
+		return -EBUSY;
+	}
+
+	/* get the current video display mode from encoder manager */
+	mode_info = &davinci_dm.mode_info;
+	if (davinci_enc_get_mode(0, mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode from enc mngr\n");
+		return -1;
+	}
+
+	layer_config = &layer->layer_info.config;
+	/* Set the default image and crop values */
+	layer_config->pixfmt = PIXFMT_YCbCrI;
+	layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
+	layer->pix_fmt.bytesperline = layer_config->line_length =
+	    mode_info->xres * 2;
+
+	layer->pix_fmt.width = layer_config->xsize = mode_info->xres;
+	layer->pix_fmt.height = layer_config->ysize = mode_info->yres;
+	layer->pix_fmt.sizeimage =
+	    layer->pix_fmt.bytesperline * layer->pix_fmt.height;
+	layer_config->xpos = 0;
+	layer_config->ypos = 0;
+	layer_config->interlaced = mode_info->interlaced;
+
+	/* turn off ping-pong buffer and field inversion to fix
+	 * the image shaking problem in 1080I mode
+	 */
+
+	if (layer->layer_info.config.interlaced)
+		layer->pix_fmt.field = V4L2_FIELD_INTERLACED;
+	else
+		layer->pix_fmt.field = V4L2_FIELD_NONE;
+	davinci_disp_set_layer_config(layer->layer_info.id, layer_config);
+	return err;
+}
+
+/*
+ * davinci_open()
+ * It creates object of file handle structure and stores it in private_data
+ * member of filepointer
+ */
+static int davinci_open(struct file *filep)
+{
+	int minor = iminor(filep->f_path.dentry->d_inode);
+	int found = -1;
+	int i = 0;
+	struct display_obj *layer;
+	struct davinci_fh *fh = NULL;
+
+	/* Check for valid minor number */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		if (minor == layer->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(davinci_display_dev, "device not found\n");
+		return -ENODEV;
+	}
+
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct davinci_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(davinci_display_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	dev_dbg(davinci_display_dev, "<davinci open> plane = %d\n",
+		layer->device_id);
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->layer = layer;
+
+	if (!layer->usrs) {
+		/* Configure the default values for the layer */
+		if (davinci_config_layer(layer->device_id)) {
+			dev_err(davinci_display_dev,
+				"Unable to configure video layer for id = %d\n",
+				layer->device_id);
+			return -EINVAL;
+		}
+	}
+
+	/* Increment layer usrs counter */
+	layer->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&layer->prio, &fh->prio);
+	dev_dbg(davinci_display_dev, "</davinci_open>\n");
+	return 0;
+}
+
+/*
+ * davinci_release()
+ * This function deletes buffer queue, frees the buffers and the davinci
+ * display file * handle
+ */
+static int davinci_release(struct file *filep)
+{
+	int ret = 0;
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "<davinci_release>\n");
+	/* If this is doing IO and other layer are not closed */
+	if ((layer->usrs != 1) && fh->io_allowed) {
+		dev_err(davinci_display_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on layer object */
+	ret = mutex_lock_interruptible(&davinci_dm.lock);
+	if (ret)
+		return ret;
+
+	/* if this instance is doing IO */
+	if (fh->io_allowed) {
+		/* Reset io_usrs member of layer object */
+		layer->io_usrs = 0;
+		davinci_disp_disable_layer(layer->layer_info.id);
+		layer->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&layer->buffer_queue);
+		videobuf_mmap_free(&layer->buffer_queue);
+	}
+
+	/* Decrement layer usrs counter */
+	layer->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (!layer->usrs) {
+		if (layer->layer_info.config.pixfmt == PIXFMT_NV12) {
+			struct display_obj *otherlayer;
+			otherlayer = _davinci_disp_get_other_win(layer);
+			davinci_disp_disable_layer(otherlayer->layer_info.id);
+			davinci_disp_release_layer(otherlayer->layer_info.id);
+		}
+		davinci_disp_disable_layer(layer->layer_info.id);
+		davinci_disp_release_layer(layer->layer_info.id);
+	}
+
+	/* Close the priority */
+	v4l2_prio_close(&layer->prio, &fh->prio);
+	filep->private_data = NULL;
+
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+	/* unlock mutex on layer object */
+	mutex_unlock(&davinci_dm.lock);
+
+	davinci_dm.cbcr_ofst = 0;
+
+	dev_dbg(davinci_display_dev, "</davinci_release>\n");
+	return 0;
+}
+
+static void davinci_platform_release(struct device
+				     *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct v4l2_file_operations vpbe_fops = {
+	.owner = THIS_MODULE,
+	.open = davinci_open,
+	.release = davinci_release,
+	.ioctl = video_ioctl2,
+	.mmap = davinci_mmap,
+	.poll = davinci_poll
+};
+
+/* vpbe capture ioctl operations */
+static const struct v4l2_ioctl_ops vpbe_ioctl_ops = {
+	.vidioc_querycap	 = vpbe_querycap,
+	.vidioc_g_fmt_vid_out    = vpbe_g_fmt,
+	.vidioc_enum_fmt_vid_out = vpbe_enum_fmt,
+	.vidioc_s_fmt_vid_out    = vpbe_s_fmt,
+	.vidioc_try_fmt_vid_out  = vpbe_try_fmt,
+	.vidioc_reqbufs		 = vpbe_reqbufs,
+	.vidioc_querybuf	 = vpbe_querybuf,
+	.vidioc_qbuf		 = vpbe_qbuf,
+	.vidioc_dqbuf		 = vpbe_dqbuf,
+	.vidioc_streamon	 = vpbe_streamon,
+	.vidioc_streamoff	 = vpbe_streamoff,
+	.vidioc_cropcap		 = vpbe_cropcap,
+	.vidioc_g_crop		 = vpbe_g_crop,
+	.vidioc_s_crop		 = vpbe_s_crop,
+	.vidioc_g_priority	 = vpbe_g_priority,
+	.vidioc_s_priority	 = vpbe_s_priority,
+	.vidioc_default		 = vpbe_param_handler,
+};
+
+/*
+ * davinci_probe()
+ * This function creates device entries by register itself to the V4L2 driver
+ * and initializes fields of each layer objects
+ */
+static __init int davinci_probe(struct device *device)
+{
+	int i, j = 0, k, err = 0;
+	struct video_device *vbd = NULL;
+	struct display_obj *layer = NULL;
+	struct platform_device *pdev;
+
+	davinci_display_dev = device;
+
+	dev_dbg(davinci_display_dev, "<davinci_probe>\n");
+
+	/* First request memory region for io */
+	pdev = to_platform_device(device);
+	if (pdev->num_resources != 0) {
+		dev_err(davinci_display_dev, "probed for an unknown device\n");
+		return -ENODEV;
+	}
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		/* Allocate memory for video device */
+		vbd = video_device_alloc();
+		if (ISNULL(vbd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release
+				    (davinci_dm.dev[j]->video_dev);
+			}
+			dev_err(davinci_display_dev, "ran out of memory\n");
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		vbd->dev = *device;
+		vbd->release 		= video_device_release;
+		vbd->fops		= &vpbe_fops;
+		vbd->ioctl_ops		= &vpbe_ioctl_ops;
+		vbd->minor		= -1;
+		vbd->current_norm	= V4L2_STD_NTSC;
+
+		snprintf(vbd->name, sizeof(vbd->name),
+			 "DaVinci_VPBEDisplay_DRIVER_V%d.%d.%d",
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 16)
+			 & 0xff,
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 8) &
+			 0xff, (DAVINCI_DISPLAY_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		layer->video_dev = vbd;
+		layer->device_id = i;
+		layer->layer_info.id =
+		    ((i == DAVINCI_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);
+		if (display_buf_config_params.numbuffers[i] == 0)
+			layer->memory = V4L2_MEMORY_USERPTR;
+		else
+			layer->memory = V4L2_MEMORY_MMAP;
+		/* Initialize field of the layer objects */
+		layer->usrs = layer->io_usrs = 0;
+		layer->started = 0;
+
+		/* Initialize prio member of layer object */
+		v4l2_prio_init(&layer->prio);
+
+		/* register video device */
+		printk(KERN_NOTICE
+		       "Trying to register davinci display video device.\n");
+		printk(KERN_NOTICE "layer=%x,layer->video_dev=%x\n", (int)layer,
+		       (int)&layer->video_dev);
+
+		err = video_register_device(layer->
+					    video_dev,
+					    VFL_TYPE_GRABBER,
+					    davinci_display_nr[i]);
+		if (err)
+			goto probe_out;
+	}
+	/* Initialize mutex */
+	mutex_init(&davinci_dm.lock);
+	return 0;
+
+probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[k];
+		/* Unregister video device */
+		video_unregister_device(layer->video_dev);
+		/* Release video device */
+		video_device_release(layer->video_dev);
+		layer->video_dev = NULL;
+	}
+	return err;
+}
+
+/*
+ * davinci_remove()
+ * It un-register hardware planes from V4L2 driver
+ */
+static int davinci_remove(struct device *device)
+{
+	int i;
+	struct display_obj *plane;
+	dev_dbg(davinci_display_dev, "<davinci_remove>\n");
+	/* un-register device */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		plane = davinci_dm.dev[i];
+		/* Unregister video device */
+		video_unregister_device(plane->video_dev);
+
+		plane->video_dev = NULL;
+	}
+
+	dev_dbg(davinci_display_dev, "</davinci_remove>\n");
+	return 0;
+}
+
+static struct device_driver davinci_driver = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.bus = &platform_bus_type,
+	.probe = davinci_probe,
+	.remove = davinci_remove,
+};
+static struct platform_device _davinci_display_device = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.id = 1,
+	.dev = {
+		.release = davinci_platform_release,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		}
+};
+
+/*
+ * davinci_display_init()
+ * This function registers device and driver to the kernel, requests irq
+ * handler and allocates memory for layer objects
+ */
+static __init int davinci_display_init(void)
+{
+	int err = 0, i, j;
+	int free_layer_objects_index;
+	int free_buffer_layer_index;
+	int free_buffer_index;
+
+
+	printk(KERN_DEBUG "<davinci_display_init>\n");
+
+	/* Default number of buffers should be 3 */
+	if ((video2_numbuffers > 0) &&
+	    (video2_numbuffers < display_buf_config_params.min_numbuffers))
+		video2_numbuffers = display_buf_config_params.min_numbuffers;
+	if ((video3_numbuffers > 0) &&
+	    (video3_numbuffers < display_buf_config_params.min_numbuffers))
+		video3_numbuffers = display_buf_config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (video2_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_0])
+		video2_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_0];
+
+	if (video3_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_1])
+		video3_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_1];
+
+	/* set number of buffers, they could come from boot/args */
+	display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_0] =
+		video2_numbuffers;
+	display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_1] =
+		video3_numbuffers;
+
+	if (cpu_is_davinci_dm355()) {
+		strcpy(davinci_display_videocap.card, DM355_EVM_CARD);
+	} else if (cpu_is_davinci_dm365())
+		strcpy(davinci_display_videocap.card, DM365_EVM_CARD);
+	else
+		strcpy(davinci_display_videocap.card, DM644X_EVM_CARD);
+
+
+	/* Allocate memory for four plane display objects */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		davinci_dm.dev[i] =
+		    kmalloc(sizeof(struct display_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!davinci_dm.dev[i]) {
+			free_layer_objects_index = i;
+			printk(KERN_ERR "ran out of memory\n");
+			err = -ENOMEM;
+			goto davinci_init_free_layer_objects;
+		}
+		spin_lock_init(&davinci_dm.dev[i]->irqlock);
+	}
+	free_layer_objects_index = DAVINCI_DISPLAY_MAX_DEVICES;
+
+	if (display_buf_config_params.numbuffers[0] == 0)
+		printk(KERN_ERR "no vid2 buffer allocated\n");
+	if (display_buf_config_params.numbuffers[1] == 0)
+		printk(KERN_ERR "no vid3 buffer allocated\n");
+	free_buffer_layer_index = DAVINCI_DISPLAY_MAX_DEVICES;
+	free_buffer_index = display_buf_config_params.numbuffers[i - 1];
+	/* Register driver to the kernel */
+	err = driver_register(&davinci_driver);
+	if (0 != err)
+		goto davinci_init_free_layer_objects;
+
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_davinci_display_device);
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+
+	davinci_dm.event_callback.mask = (DAVINCI_DISP_END_OF_FRAME |
+					  DAVINCI_DISP_FIRST_FIELD |
+					  DAVINCI_DISP_SECOND_FIELD);
+
+	davinci_dm.event_callback.arg = &davinci_dm;
+	davinci_dm.event_callback.handler = davinci_display_isr;
+
+	err = davinci_disp_register_callback(&davinci_dm.event_callback);
+
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+	printk(KERN_NOTICE
+	       "davinci_init:DaVinci V4L2 Display Driver V1.0 loaded\n");
+	printk(KERN_DEBUG "</davinci_init>\n");
+	return 0;
+
+davinci_init_unregister_driver:
+	driver_unregister(&davinci_driver);
+
+davinci_init_free_layer_objects:
+	for (j = 0; j < free_layer_objects_index; j++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[j]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/*
+ * davinci_cleanup()
+ * This function un-registers device and driver to the kernel, frees requested
+ * irq handler and de-allocates memory allocated for layer objects.
+ */
+static void davinci_cleanup(void)
+{
+	int i = 0;
+	printk(KERN_INFO "<davinci_cleanup>\n");
+
+	davinci_disp_unregister_callback(&davinci_dm.event_callback);
+	platform_device_unregister(&_davinci_display_device);
+	driver_unregister(&davinci_driver);
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[i]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	printk(KERN_INFO "</davinci_cleanup>\n");
+}
+
+EXPORT_SYMBOL(davinci_display_dev);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(davinci_display_init);
+module_exit(davinci_cleanup);
diff --git a/drivers/media/video/davinci/davinci_enc_mngr.c b/drivers/media/video/davinci/davinci_enc_mngr.c
new file mode 100644
index 0000000..1593a35
--- /dev/null
+++ b/drivers/media/video/davinci/davinci_enc_mngr.c
@@ -0,0 +1,1166 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/attribute_container.h>
+#include <mach/hardware.h>
+#include <mach/mux.h>
+#include <mach/cpu.h>
+#include <mach/io.h>
+#include <asm/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+#define ISNULL(p)       ((NULL) == (p))
+
+static char *ch0_output = "";
+static char *ch1_output = "";
+static char *ch0_mode = "";
+static char *ch1_mode = "";
+module_param(ch0_output, charp, S_IRUGO);
+module_param(ch1_output, charp, S_IRUGO);
+module_param(ch0_mode, charp, S_IRUGO);
+module_param(ch1_mode, charp, S_IRUGO);
+
+struct vid_enc_device_mgr enc_dev[DAVINCI_ENC_MAX_CHANNELS];
+
+EXPORT_SYMBOL(enc_dev);
+extern struct enc_config davinci_enc_default[];
+extern char *davinci_outputs[];
+extern char *davinci_modes[];
+
+struct display_device {
+	struct module *owner;
+	struct device class_dev;
+	int channel;
+};
+
+static struct display_device *davinci_display_device[DAVINCI_ENC_MAX_CHANNELS];
+
+#define to_display_dev(cdev)	container_of(cdev, struct display_device, class_dev)
+
+static void display_class_release(struct device *cdev)
+{
+	struct display_device *dev = to_display_dev(cdev);
+
+	if (dev != NULL)
+		kfree(dev);
+}
+
+struct class display_class = {
+	.name = "davinci_display",
+	.owner	= THIS_MODULE,
+	.dev_release = display_class_release,
+};
+
+static ssize_t output_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	char name[VID_ENC_NAME_MAX_CHARS];
+	struct display_device *dev = to_display_dev(cdev);
+	int p, ret;
+
+	ret = davinci_enc_get_output(dev->channel, name);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+output_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[VID_ENC_NAME_MAX_CHARS];
+	int ret;
+
+	if (!buffer || (count == 0)|| (count > VID_ENC_NAME_MAX_CHARS))
+		return 0;
+
+	strncpy(name, buffer, count);
+	name[count - 1] = 0;
+	ret = davinci_enc_set_output(dev->channel, name);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t mode_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	struct vid_enc_mode_info mode_info;
+	int p;
+	int ret;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, mode_info.name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+mode_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[VID_ENC_NAME_MAX_CHARS];
+	struct vid_enc_mode_info mode_info;
+	int ret;
+
+	if (!buffer || (count == 0) || (count > VID_ENC_NAME_MAX_CHARS))
+		return 0;
+
+	strncpy(name, buffer, count);
+	name[count - 1] = 0;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+
+	if (ret < 0)
+		return ret;
+
+	mode_info.name = name;
+	ret = davinci_enc_set_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t enable_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t
+enable_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int enable_output_state, ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	if (strncmp(buffer, "on", 2) == 0)
+		enable_output_state = 1;
+	else if (strncmp(buffer, "off", 3) == 0)
+		enable_output_state = 0;
+	else
+		return -EINVAL;
+
+	ret = davinci_enc_enable_output(dev->channel, enable_output_state);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t
+control_store(struct device *cdev, const char *buffer, size_t count,
+	      u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int val;
+	int ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	val = simple_strtoul(buffer, NULL, 0);
+
+	ret = davinci_enc_set_control(dev->channel, ctrl, (char)val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+static ssize_t control_show(struct device *cdev, char *buf, u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	unsigned int p;
+	unsigned char val;
+	int ret;
+
+	ret = davinci_enc_get_control(dev->channel, ctrl, &val);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, "%d", val);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+brightness_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t brightness_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t
+hue_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_HUE);
+}
+static ssize_t hue_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_HUE);
+}
+static ssize_t
+gain_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_GAIN);
+}
+static ssize_t gain_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_GAIN);
+}
+
+#define DECLARE_ATTR(_name, _mode, _show, _store)                  \
+{                                                               \
+	.attr   = { .name = __stringify(_name), .mode = _mode,	\
+		    .owner = THIS_MODULE },  			\
+	.show   = _show,                                        \
+	.store  = _store,                                       \
+}
+static struct device_attribute bl_device_attributes[] = {
+	DECLARE_ATTR(output, S_IRWXUGO, output_show, output_store),
+	DECLARE_ATTR(mode, S_IRWXUGO, mode_show, mode_store),
+	DECLARE_ATTR(enable, S_IRWXUGO, enable_show, enable_store),
+	DECLARE_ATTR(brightness, S_IRWXUGO, brightness_show, brightness_store),
+	DECLARE_ATTR(hue, S_IRWXUGO, hue_show, hue_store),
+	DECLARE_ATTR(gain, S_IRWXUGO, gain_show, gain_store)
+};
+
+static void *create_sysfs_files(int channel)
+{
+	struct display_device *dev;
+	int ret;
+	int i;
+
+	dev = kzalloc(sizeof(struct display_device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->owner = THIS_MODULE;
+	dev->channel = channel;
+	dev->class_dev.class = &display_class;
+	dev_set_name(&dev->class_dev, "ch%d", channel);
+	dev_set_drvdata(&dev->class_dev, dev);
+	ret = device_register(&dev->class_dev);
+	if (ret < 0) {
+		printk(KERN_ERR "DaVinci Enc Manager: Error in device_register\n");
+		kfree(dev);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(bl_device_attributes); i++) {
+		ret = device_create_file(&dev->class_dev,
+					       &bl_device_attributes[i]);
+		if (ret < 0) {
+			while (--i >= 0)
+				device_remove_file(&dev->class_dev,
+							 &bl_device_attributes
+							 [i]);
+			dev_set_drvdata(&dev->class_dev, NULL);
+			device_unregister(&dev->class_dev);
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+static void remove_sysfs_files(struct display_device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(bl_device_attributes); i++)
+		device_remove_file(&dev->class_dev,
+					 &bl_device_attributes[i]);
+
+	dev_set_drvdata(&dev->class_dev, NULL);
+	device_unregister(&dev->class_dev);
+}
+
+static void davinci_enc_check_options(void)
+{
+	int i;
+
+	i = 0;
+	while (*(davinci_modes[i]) != 0) {
+		if (*ch0_mode != 0 && !strcmp(ch0_mode, davinci_modes[i])) {
+			if (strcmp(ch0_mode, "ntsc") == 0
+			    || strcmp(ch0_mode, "pal") == 0)
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i]);
+		}
+		if (*ch1_mode != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_mode, davinci_modes[i])) {
+			if (strcmp(ch1_mode, "ntsc") == 0
+			    || strcmp(ch1_mode, "pal") == 0)
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i]);
+		}
+		i++;
+	}
+
+	i = 0;
+	while (*(davinci_outputs[i]) != 0) {
+		if (*ch0_output != 0 && !strcmp(ch0_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[0].output,
+			       davinci_outputs[i]);
+
+		if (*ch1_output != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[1].output,
+			       davinci_outputs[i]);
+		i++;
+	}
+	printk(KERN_NOTICE "ch0 default output \"%s\", mode \"%s\"\n",
+	       davinci_enc_default[0].output, davinci_enc_default[0].mode);
+	if (DAVINCI_ENC_MAX_CHANNELS > 1)
+		printk(KERN_NOTICE "ch1 default output \"%s\", mode \"%s\"\n",
+		       davinci_enc_default[1].output,
+		       davinci_enc_default[1].mode);
+	return;
+}
+
+/*
+ * vid_enc_mgr_init
+ */
+static int davinci_enc_mngr_init(void)
+{
+
+	int i, err = -EINVAL;
+	struct vid_enc_device_mgr *ptr = 0;
+
+
+	class_register(&display_class);
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++) {
+		ptr = &enc_dev[i];
+
+		memset((void *)ptr, 0, sizeof(struct vid_enc_device_mgr));
+		init_MUTEX(&ptr->lock);
+
+		davinci_display_device[i] = create_sysfs_files(i);
+		if (!davinci_display_device[i]) {
+			printk(KERN_ERR
+			       "Could not create display control sysfs "
+			       "files for channel %d\n", i);
+			return -EINVAL;
+		}
+	}
+
+	davinci_enc_check_options();
+	err = 0;
+	return err;
+}
+
+/*
+ * vid_enc_mgr_cleanup
+ */
+static void davinci_enc_mngr_exit(void)
+{
+//Sandeep
+	int i;
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++)
+		remove_sysfs_files(davinci_display_device[i]);
+
+	class_unregister(&display_class);
+
+	return;
+}
+
+/*
+ * davinci_get_cur_encoder: get current encoder on the specified channel
+ */
+static struct vid_encoder_device *davinci_get_cur_encoder(int channel)
+{
+	struct vid_enc_device_mgr *mgr;
+
+	if ((channel > DAVINCI_ENC_MAX_CHANNELS) || (channel < 0))
+		return NULL;
+
+	mgr = &enc_dev[channel];
+
+	if (mgr->current_encoder > mgr->num_encoders)
+		return NULL;
+
+	if (mgr->num_encoders == 0)
+		return NULL;
+
+	return mgr->encoder[mgr->current_encoder];
+}
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set encoder
+ * parameters.
+ */
+int davinci_enc_setparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->setparams != NULL)
+		return cur_enc->params_ops->setparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_setparams);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get encoder
+ * parameters.
+ */
+int davinci_enc_getparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->getparams != NULL)
+		return cur_enc->params_ops->getparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_getparams);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->setcontrol != NULL)
+		return cur_enc->ctrl_ops->setcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_control);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops || NULL == val)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->getcontrol != NULL)
+		return cur_enc->ctrl_ops->getcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_control);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		return cur_enc->misc_ops->reset(cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_reset);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+*  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+* configuration of the VENC or related hardware in the VPSS and re-enabled
+* using this API. This will switch the output DACs Off or On based on the
+* flag.
+ */
+int davinci_enc_enable_output(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		return cur_enc->misc_ops->enable(flag, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_output);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to program the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During programing of the SoC hardware for timing, manager
+ * would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output)
+{
+	int i, j, found = -1;
+	int err = -EINVAL;
+	struct vid_encoder_device *cur_enc, *new_enc = 0;
+	struct vid_enc_device_mgr *mgr = NULL;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	cur_enc = davinci_get_cur_encoder(channel);
+	if (NULL == cur_enc || NULL == output)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	/* enumerate the output for each encoder on this channel
+	   to find a matching one */
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (ISNULL(mgr->encoder[i]))
+			return err;
+
+		for (j = 0; j < mgr->encoder[i]->output_ops->count; j++) {
+			err =
+			    mgr->encoder[i]->output_ops->
+			    enumoutput(j, buf, mgr->encoder[i]);
+			if (err != 0)
+				return err;
+			if (strcmp(buf, output) == 0) {
+				found = i;
+				new_enc = mgr->encoder[i];
+				break;
+			}
+		}
+	}
+
+	if (found < 0) {
+		printk(KERN_ERR "output not found\n");
+		return -EINVAL;
+	}
+
+	/* found the encoder */
+	err = 0;
+	mgr->current_encoder = found;
+	if ((err = down_interruptible(&mgr->lock)) < 0)
+		return err;
+	err |= cur_enc->deinitialize(cur_enc);
+	err |= new_enc->initialize(new_enc, VID_ENC_FULL_INIT_FLAG);
+	err |= new_enc->output_ops->setoutput(output, new_enc);
+
+	if (err < 0) {
+		up(&mgr->lock);
+		return err;
+	}
+
+	/* get default mode */
+	err |= new_enc->mode_ops->getmode(&mgr->current_mode, new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(0, new_enc);
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	/* Some encoders need a soft reset after configuring VENC, ex.
+	   ths8200
+	 */
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->reset != NULL)
+		err |= new_enc->misc_ops->reset(new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(1, new_enc);
+
+	if (0 == err)
+		strcpy(enc_dev[channel].current_output, output);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_output);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	int err = -EINVAL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	if (cur_enc->mode_ops->setmode != NULL) {
+		if ((err = down_interruptible(&mgr->lock)) < 0)
+			return err;
+		err = cur_enc->mode_ops->setmode(mode_info, cur_enc);
+		up(&mgr->lock);
+	} else
+		return err;
+
+	if (err < 0)
+		return err;
+
+	err = cur_enc->mode_ops->getmode(&mgr->current_mode, cur_enc);
+	if (err < 0)
+		return err;
+
+	err = 0;
+
+	if ((err = down_interruptible(&mgr->lock)) < 0)
+		return err;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(0, cur_enc);
+
+	/* non-standard */
+	if (mgr->current_mode.std == 0) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		up(&mgr->lock);
+		return err;
+	}
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		err |= cur_enc->misc_ops->reset(cur_enc);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(1, cur_enc);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode);
+
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * This is updated by encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+*/
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return -EINVAL;
+
+	if (cur_enc->mode_ops->getmode != NULL)
+		return cur_enc->mode_ops->getmode(mode_info, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_mode);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name.
+ * size VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+*   output name
+ */
+int davinci_enc_get_output(int channel, char *output)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->output_ops || NULL == output)
+		return -EINVAL;
+
+	if (cur_enc->output_ops->getoutput != NULL)
+		return cur_enc->output_ops->getoutput(output, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_output);
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device *encoder)
+{
+	int i, found = 0, err = 0;
+	int ch_id = 0;
+	struct vid_enc_device_mgr *mgr = 0;
+	struct vid_encoder_device *cur_enc = 0;
+	struct enc_config *enc_def = 0;
+	struct vid_enc_mode_info mode_info;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	if (ISNULL(encoder))
+		return -EINVAL;
+
+	memset(&mode_info, 0, sizeof(struct vid_enc_mode_info));
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return -EINVAL;
+
+	mgr = &enc_dev[ch_id];
+
+	if (mgr->num_encoders > DAVINCI_ENC_MAX_ENCODERS)
+		return -EINVAL;
+
+	/* get module boot args */
+	enc_def = &davinci_enc_default[ch_id];
+
+	/* we'd assume only std mode being reqeusted from bootargs */
+	mode_info.name = enc_def->mode;
+	mode_info.std = 1;
+	if (mgr->num_encoders == 0) {
+
+		/* set default for the first encoder */
+		err = encoder->initialize(encoder, VID_ENC_FULL_INIT_FLAG);
+
+		if (err >= 0) {
+			/* see if this has output requested by default
+			   or bootarg */
+
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err =
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Setmode failed, reset to encoder"
+					     " default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = 0;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			if ((err = down_interruptible(&mgr->lock)) < 0)
+				return err;
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+		}
+	} else {
+		/* If we have more than one encoder module, then we still
+		   want to make sure we can set to the default output and
+		   mode. If current one is not the default, try this new
+		   one. If still no luck, just use the newly registered
+		   one as default */
+		cur_enc = davinci_get_cur_encoder(ch_id);
+
+		if ((strcmp(mgr->current_output,
+			    enc_def->output) != 0) && (cur_enc != NULL)) {
+			cur_enc->deinitialize(cur_enc);
+
+			err = encoder->initialize(encoder,
+						  VID_ENC_FULL_INIT_FLAG);
+
+			if (err < 0) {
+				/* no change if new one cannot be
+				   initialized */
+				encoder->deinitialize(encoder);
+				cur_enc->initialize(cur_enc, 0);
+				return err;
+			}
+			/* look for matching output */
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err |=
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				/* setmode went wrong, try redo init */
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Set output or mode failed, "
+					     "reset to encoder default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = mgr->num_encoders - 1;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			if ((err = down_interruptible(&mgr->lock)) < 0)
+				return err;
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+
+		} else if (strcmp(mgr->current_output, enc_def->output) == 0) {
+			/* no change in output or mode */
+			mgr->encoder[mgr->num_encoders++] = encoder;
+
+		}
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(vid_enc_register_encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device *encoder)
+{
+	int i, j = 0, err = -EINVAL, ch_id;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	if (ISNULL(encoder))
+		return err;
+
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return err;
+
+	mgr = &enc_dev[ch_id];
+
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (encoder == mgr->encoder[i]) {
+
+			mgr->encoder[i] = NULL;
+			for (j = i; j < mgr->num_encoders - 1; j++)
+				mgr->encoder[j] = mgr->encoder[j + 1];
+			mgr->num_encoders--;
+			err = 0;
+			break;
+		}
+	}
+	return err;
+
+}
+
+EXPORT_SYMBOL(vid_enc_unregister_encoder);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_vbi)
+		return -EINVAL;
+
+	return cur_enc->enable_vbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_vbi);
+
+/**
+ * davinci_enc_enable_hbi
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_hbi)
+		return -EINVAL;
+
+	return cur_enc->enable_hbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_hbi);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *services)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->set_vbi_services)
+		return -EINVAL;
+
+	return cur_enc->set_vbi_services(services, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_sliced_vbi);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->write_vbi_data)
+		return -EINVAL;
+
+	return cur_enc->write_vbi_data(data, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_write_sliced_vbi_data);
+
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *service)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->get_sliced_cap)
+		return -EINVAL;
+
+	return cur_enc->get_sliced_cap(service, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_get_sliced_cap);
+
+subsys_initcall(davinci_enc_mngr_init);
+module_exit(davinci_enc_mngr_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DaVinci Encoder Manager");
+MODULE_AUTHOR("Texas Instruments");
diff --git a/drivers/media/video/davinci/davinci_osd.c b/drivers/media/video/davinci/davinci_osd.c
new file mode 100644
index 0000000..751c325
--- /dev/null
+++ b/drivers/media/video/davinci/davinci_osd.c
@@ -0,0 +1,2434 @@
+/*
+ * TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <mach/io.h>
+#include <mach/cpu.h>
+#include <mach/hardware.h>
+#include <media/davinci/vpss.h>
+
+#include <asm/io.h>
+
+#define MODULE_NAME 		"davinci_osd"
+
+#define DM355_VPSSBL_REG_BASE	0x01C70800
+
+/* parameters that apply on a per-window (OSD or video) basis */
+struct davinci_window_state {
+	int is_allocated;
+	int is_enabled;
+	unsigned long fb_base_phys;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	struct davinci_layer_config lconfig;
+};
+
+/* parameters that apply on a per-OSD-window basis */
+struct davinci_osdwin_state {
+	enum davinci_clut clut;
+	enum davinci_blending_factor blend;
+	int colorkey_blending;
+	unsigned colorkey;
+	int rec601_attenuation;
+	unsigned char palette_map[16];	/* index is pixel value */
+};
+
+/* hardware rectangular cursor parameters */
+struct davinci_cursor_state {
+	int is_enabled;
+	struct davinci_cursor_config config;
+};
+
+struct davinci_osd_state {
+	spinlock_t lock;
+	struct device *dev;
+	dma_addr_t osd_base_phys;
+	unsigned long osd_base;
+	unsigned long osd_size;
+
+	int irq;
+	struct davinci_disp_callback *callback;
+	int pingpong;		/* 1-->the isr will toggle the VID0 ping-pong buffer */
+	int interpolation_filter;
+	int field_inversion;
+	enum davinci_h_exp_ratio osd_h_exp;
+	enum davinci_v_exp_ratio osd_v_exp;
+	enum davinci_h_exp_ratio vid_h_exp;
+	enum davinci_v_exp_ratio vid_v_exp;
+	enum davinci_clut backg_clut;
+	unsigned backg_clut_index;
+	enum davinci_rom_clut rom_clut;
+	int is_blinking;	/* attribute window blinking enabled */
+	enum davinci_blink_interval blink;
+	enum davinci_pix_format yc_pixfmt;	/* YCbCrI or YCrCbI */
+	unsigned char clut_ram[256][3];	/* columns are Y, Cb, Cr */
+	struct davinci_cursor_state cursor;
+	struct davinci_window_state win[4];	/* OSD0, VID0, OSD1, VID1 */
+	struct davinci_osdwin_state osdwin[2];	/* OSD0, OSD1 */
+};
+
+static struct davinci_osd_state osd_state;
+static struct davinci_osd_state *osd = &osd_state;
+
+/* register access routines */
+static __inline__ u32 osd_read(u32 offset)
+{
+	return __raw_readl(osd->osd_base + offset);
+}
+
+static __inline__ u32 osd_write(u32 val, u32 offset)
+{
+	__raw_writel(val, osd->osd_base + offset);
+	return val;
+}
+
+static __inline__ u32 osd_set(u32 mask, u32 offset)
+{
+	u32 addr = osd->osd_base + offset;
+	u32 val = __raw_readl(addr) | mask;
+
+	__raw_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_clear(u32 mask, u32 offset)
+{
+	u32 addr = osd->osd_base + offset;
+	u32 val = __raw_readl(addr) & ~mask;
+
+	__raw_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_merge(u32 mask, u32 val, u32 offset)
+{
+	u32 addr = osd->osd_base + offset;
+	u32 new_val = (__raw_readl(addr) & ~mask) | (val & mask);
+
+	__raw_writel(new_val, addr);
+	return new_val;
+}
+
+void osd_write_left_margin(u32 val)
+{
+	__raw_writel(val, osd->osd_base + OSD_BASEPX);
+}
+EXPORT_SYMBOL(osd_write_left_margin);
+
+void osd_write_upper_margin(u32 val)
+{
+	__raw_writel(val, osd->osd_base + OSD_BASEPY);
+}
+EXPORT_SYMBOL(osd_write_upper_margin);
+
+u32 osd_read_left_margin(void)
+{
+	return __raw_readl(osd->osd_base + OSD_BASEPX);
+}
+EXPORT_SYMBOL(osd_read_left_margin);
+
+u32 osd_read_upper_margin(void)
+{
+	return __raw_readl(osd->osd_base + OSD_BASEPY);
+}
+EXPORT_SYMBOL(osd_read_upper_margin);
+	
+
+/* define some macros for layer and pixfmt classification */
+#define is_osd_win(layer) (((layer) == WIN_OSD0) || ((layer) == WIN_OSD1))
+#define is_vid_win(layer) (((layer) == WIN_VID0) || ((layer) == WIN_VID1))
+#define is_rgb_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_RGB565) || ((pixfmt) == PIXFMT_RGB888))
+#define is_yc_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_YCbCrI) || ((pixfmt) == PIXFMT_YCrCbI) || \
+	((pixfmt) == PIXFMT_NV12))
+#define MAX_WIN_SIZE OSD_VIDWIN0XP_V0X
+#define MAX_LINE_LENGTH (OSD_VIDWIN0OFST_V0LO << 5)
+
+/* interrupt service routine */
+static irqreturn_t davinci_disp_isr(int irq, void *arg)
+{
+	unsigned event = 0;
+	struct davinci_disp_callback *callback = osd->callback;
+	static unsigned last_event;
+#if 0
+	if (cpu_is_davinci_dm355()) {
+		if (!
+		    (__raw_readl(IO_ADDRESS(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT)) &
+		     VPSSBL_INTSTAT_VENCINT)) {
+			return IRQ_NONE;
+		}
+		__raw_writel(VPSSBL_INTSTAT_VENCINT,
+			       IO_ADDRESS(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT));
+	}
+#endif
+#if 0
+	if (cpu_is_davinci_dm365()) {
+		if (!
+		    (__raw_readl(IO_ADDRESS(DM365_ISP5_REG_BASE + ISP5_INTSTAT)) &
+		     ISP5_INTSTAT_VENCINT)) {
+			return IRQ_NONE;
+		}
+		__raw_writel(ISP5_INTSTAT_VENCINT,
+			       IO_ADDRESS(DM365_ISP5_REG_BASE + ISP5_INTSTAT));
+	}
+#endif
+	if (davinci_disp_is_second_field())
+		event |= DAVINCI_DISP_SECOND_FIELD;
+	else
+		event |= DAVINCI_DISP_FIRST_FIELD;
+
+	if (event == (last_event & ~DAVINCI_DISP_END_OF_FRAME)) {
+		/*
+		 * If the display is non-interlaced, then we need to flag the
+		 * end-of-frame event at every interrupt regardless of the
+		 * value of the FIDST bit.  We can conclude that the display is
+		 * non-interlaced if the value of the FIDST bit is unchanged
+		 * from the previous interrupt.
+		 */
+		event |= DAVINCI_DISP_END_OF_FRAME;
+	} else if (event == DAVINCI_DISP_SECOND_FIELD) {
+		/* end-of-frame for interlaced display */
+		event |= DAVINCI_DISP_END_OF_FRAME;
+	}
+	last_event = event;
+
+	if (osd->pingpong) {
+		/*
+		 * Toggle the ping-pong buffers for VID0.  This is part of the
+		 * workaround for field signal inversion Advisory 1.3.8 for
+		 * the DM6446.
+		 */
+		if (event & DAVINCI_DISP_SECOND_FIELD)
+			osd_set(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+		else
+			osd_clear(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+	}
+
+	while (callback) {
+		if (callback->mask & event)
+			callback->handler(event, callback->arg);
+		callback = callback->next;
+	}
+
+	return IRQ_HANDLED;
+}
+
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *prev;
+	int err = 0;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	prev = osd->callback;
+	if (!prev)
+		err = -1;
+	else if (prev == callback)
+		osd->callback = callback->next;
+	else {
+		while (prev->next && (prev->next != callback))
+			prev = prev->next;
+		if (!prev->next)
+			err = -1;
+		else
+			prev->next = callback->next;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return err;
+}
+EXPORT_SYMBOL(davinci_disp_unregister_callback);
+
+int davinci_disp_register_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *next;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	next = osd->callback;
+	osd->callback = callback;
+	callback->next = next;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_register_callback);
+
+/*
+ * This routine implements a workaround for the field signal inversion silicon
+ * erratum described in Advisory 1.3.8 for the DM6446.  The fb_base_phys and
+ * lconfig parameters apply to the vid0 window.  This routine should be called
+ * whenever the vid0 layer configuration or start address is modified, or when
+ * the OSD field inversion setting is modified.
+ * Returns: 1 if the ping-pong buffers need to be toggled in the vsync isr, or
+ *          0 otherwise
+ */
+static int _davinci_disp_dm6446_vid0_pingpong(int field_inversion,
+					      unsigned long fb_base_phys,
+					      const struct davinci_layer_config
+					      *lconfig)
+{
+/* TODO */
+#if 0
+	if (!cpu_is_davinci_dm644x_pg1x())
+		return 0;
+
+
+	if (!field_inversion || !lconfig->interlaced) {
+		osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+		osd_write(fb_base_phys & ~0x1F, OSD_PPVWIN0ADR);
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, 0, OSD_MISCCTL);
+
+		return 0;
+	} else {
+		unsigned miscctl = OSD_MISCCTL_PPRV;
+
+		osd_write((fb_base_phys & ~0x1F) - lconfig->line_length,
+			  OSD_VIDWIN0ADR);
+		osd_write((fb_base_phys & ~0x1F) + lconfig->line_length,
+			  OSD_PPVWIN0ADR);
+
+		if (davinci_disp_is_second_field())
+			miscctl |= OSD_MISCCTL_PPSW;
+
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, miscctl,
+			  OSD_MISCCTL);
+
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+int davinci_disp_get_field_inversion(void)
+{
+	return osd->field_inversion;
+}
+EXPORT_SYMBOL(davinci_disp_get_field_inversion);
+
+static void _davinci_disp_set_field_inversion(int enable)
+{
+	unsigned fsinv = 0;
+
+	if (enable)
+		fsinv = OSD_MODE_FSINV;
+
+	osd_merge(OSD_MODE_FSINV, fsinv, OSD_MODE);
+}
+
+void davinci_disp_set_field_inversion(int enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->field_inversion = (enable != 0);
+	_davinci_disp_set_field_inversion(enable);
+
+	osd->pingpong =
+	    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+					       osd->win[WIN_VID0].fb_base_phys,
+					       &osd->win[WIN_VID0].lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_field_inversion);
+
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*clut = osd->backg_clut;
+	*clut_index = osd->backg_clut_index;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_background);
+
+static void _davinci_disp_set_background(enum davinci_clut clut,
+					 unsigned char clut_index)
+{
+	u32 mode = 0;
+
+	if (clut == RAM_CLUT)
+		mode |= OSD_MODE_BCLUT;
+	mode |= clut_index;
+	osd_merge(OSD_MODE_BCLUT | OSD_MODE_CABG, mode, OSD_MODE);
+}
+
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->backg_clut = clut;
+	osd->backg_clut_index = clut_index;
+	_davinci_disp_set_background(clut, clut_index);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_background);
+
+int davinci_disp_get_interpolation_filter(void)
+{
+	return osd->interpolation_filter;
+}
+EXPORT_SYMBOL(davinci_disp_get_interpolation_filter);
+
+static void _davinci_disp_set_interpolation_filter(int filter)
+{
+	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
+		osd_clear(OSD_EXTMODE_EXPMDSEL, OSD_EXTMODE);
+	osd_merge(OSD_MODE_EF, filter ? OSD_MODE_EF : 0, OSD_MODE);
+}
+
+void davinci_disp_set_interpolation_filter(int filter)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->interpolation_filter = (filter != 0);
+	_davinci_disp_set_interpolation_filter(filter);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_interpolation_filter);
+
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*cursor = osd->cursor.config;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_cursor_config);
+
+static void _davinci_disp_set_cursor_config(const struct davinci_cursor_config
+					    *cursor)
+{
+	unsigned rectcur = 0;
+
+	osd_write(cursor->xsize, OSD_CURXL);
+	osd_write(cursor->xpos, OSD_CURXP);
+
+	if (cursor->interlaced) {
+		osd_write(cursor->ypos >> 1, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write((cursor->ysize >> 1) + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize >> 1, OSD_CURYL);
+	} else {
+		osd_write(cursor->ypos, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write(cursor->ysize + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize, OSD_CURYL);
+	}
+
+	if (cursor->clut == RAM_CLUT)
+		rectcur |= OSD_RECTCUR_CLUTSR;
+	rectcur |= (cursor->clut_index << OSD_RECTCUR_RCAD_SHIFT);
+	rectcur |= (cursor->h_width << OSD_RECTCUR_RCHW_SHIFT);
+	rectcur |= (cursor->v_width << OSD_RECTCUR_RCVW_SHIFT);
+	osd_merge(OSD_RECTCUR_RCAD | OSD_RECTCUR_CLUTSR | OSD_RECTCUR_RCHW |
+		  OSD_RECTCUR_RCVW, rectcur, OSD_RECTCUR);
+}
+
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	cursor->xsize = min(cursor->xsize, (unsigned)OSD_CURXL_RCSW);
+	cursor->ysize = min(cursor->ysize, (unsigned)OSD_CURYL_RCSH);
+	cursor->xpos = min(cursor->xpos, (unsigned)OSD_CURXP_RCSX);
+	cursor->ypos = min(cursor->ypos, (unsigned)OSD_CURYP_RCSY);
+	cursor->interlaced = (cursor->interlaced != 0);
+	if (cursor->interlaced) {
+		cursor->ysize &= ~1;
+		cursor->ypos &= ~1;
+	}
+	cursor->h_width &= (OSD_RECTCUR_RCHW >> OSD_RECTCUR_RCHW_SHIFT);
+	cursor->v_width &= (OSD_RECTCUR_RCVW >> OSD_RECTCUR_RCVW_SHIFT);
+	cursor->clut = (cursor->clut == RAM_CLUT) ? RAM_CLUT : ROM_CLUT;
+
+	osd->cursor.config = *cursor;
+	_davinci_disp_set_cursor_config(cursor);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_cursor_config);
+
+int davinci_disp_cursor_is_enabled(void)
+{
+	return osd->cursor.is_enabled;
+}
+EXPORT_SYMBOL(davinci_disp_cursor_is_enabled);
+
+static void _davinci_disp_cursor_disable(void)
+{
+	osd_clear(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_disable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 0;
+	_davinci_disp_cursor_disable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_cursor_disable);
+
+static void _davinci_disp_cursor_enable(void)
+{
+	osd_set(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_enable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 1;
+	_davinci_disp_cursor_enable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_cursor_enable);
+
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->vid_h_exp;
+	*v_exp = osd->vid_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_vid_expansion);
+
+static void _davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_VHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_VIDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_VVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
+		osd_merge(OSD_EXTMODE_VIDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_VHRSZ | OSD_MODE_VVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->vid_h_exp = h_exp;
+	osd->vid_v_exp = v_exp;
+	_davinci_disp_set_vid_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_set_vid_expansion);
+
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->osd_h_exp;
+	*v_exp = osd->osd_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_osd_expansion);
+
+static void _davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_OHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_OSDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_OVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
+		osd_merge(OSD_EXTMODE_OSDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_OHRSZ | OSD_MODE_OVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->osd_h_exp = h_exp;
+	osd->osd_v_exp = v_exp;
+	_davinci_disp_set_osd_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_set_osd_expansion);
+
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*enable = osd->is_blinking;
+	*blink = osd->blink;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_blink_attribute);
+
+static void _davinci_disp_set_blink_attribute(int enable,
+					      enum davinci_blink_interval blink)
+{
+	u32 osdatrmd = 0;
+
+	if (enable) {
+		osdatrmd |= OSD_OSDATRMD_BLNK;
+		osdatrmd |= blink << OSD_OSDATRMD_BLNKINT_SHIFT;
+	}
+	/* caller must ensure that OSD1 is configured in attribute mode */
+	osd_merge(OSD_OSDATRMD_BLNKINT | OSD_OSDATRMD_BLNK, osdatrmd,
+		  OSD_OSDATRMD);
+}
+
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->is_blinking = (enable != 0);
+	osd->blink = blink;
+	if (osd->win[WIN_OSD1].lconfig.pixfmt == PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blink_attribute(enable, blink);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_blink_attribute);
+
+enum davinci_rom_clut davinci_disp_get_rom_clut(void)
+{
+	return osd->rom_clut;
+}
+EXPORT_SYMBOL(davinci_disp_get_rom_clut);
+
+static void _davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	if (rom_clut == ROM_CLUT0)
+		osd_clear(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+	else
+		osd_set(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+}
+
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->rom_clut = rom_clut;
+	_davinci_disp_set_rom_clut(rom_clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_rom_clut);
+
+static void _davinci_disp_set_clut_ycbcr(unsigned char clut_index,
+					 unsigned char y, unsigned char cb,
+					 unsigned char cr)
+{
+	/* wait until any previous writes to the CLUT RAM have completed */
+	while (osd_read(OSD_MISCCTL) & OSD_MISCCTL_CPBSY)
+		cpu_relax();
+
+	osd_write((y << OSD_CLUTRAMYCB_Y_SHIFT) | cb, OSD_CLUTRAMYCB);
+	osd_write((cr << OSD_CLUTRAMCR_CR_SHIFT) | clut_index, OSD_CLUTRAMCR);
+}
+
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = y;
+	osd->clut_ram[clut_index][1] = cb;
+	osd->clut_ram[clut_index][2] = cr;
+	_davinci_disp_set_clut_ycbcr(clut_index, y, cb, cr);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_clut_ycbcr);
+
+static void _davinci_disp_rgb_to_ycbcr(const unsigned char rgb[3],
+				       unsigned char ycbcr[3])
+{
+	int y, cb, cr;
+	int r = rgb[0];
+	int g = rgb[1];
+	int b = rgb[2];
+	/*
+	 * This conversion matrix corresponds to the conversion matrix used
+	 * by the OSD to convert RGB values to YCbCr values.  All coefficients
+	 * have been scaled by a factor of 2^22.
+	 */
+	static const int rgb_to_ycbcr[3][3] = {
+		{1250330, 2453618, 490352},
+		{-726093, -1424868, 2150957},
+		{2099836, -1750086, -349759}
+	};
+
+	y = rgb_to_ycbcr[0][0] * r + rgb_to_ycbcr[0][1] * g +
+	    rgb_to_ycbcr[0][2] * b;
+	cb = rgb_to_ycbcr[1][0] * r + rgb_to_ycbcr[1][1] * g +
+	    rgb_to_ycbcr[1][2] * b;
+	cr = rgb_to_ycbcr[2][0] * r + rgb_to_ycbcr[2][1] * g +
+	    rgb_to_ycbcr[2][2] * b;
+
+	/* round and scale */
+	y = ((y + (1 << 21)) >> 22);
+	cb = ((cb + (1 << 21)) >> 22) + 128;
+	cr = ((cr + (1 << 21)) >> 22) + 128;
+
+	/* clip */
+	y = (y < 0) ? 0 : y;
+	y = (y > 255) ? 255 : y;
+	cb = (cb < 0) ? 0 : cb;
+	cb = (cb > 255) ? 255 : cb;
+	cr = (cr < 0) ? 0 : cr;
+	cr = (cr > 255) ? 255 : cr;
+
+	ycbcr[0] = y;
+	ycbcr[1] = cb;
+	ycbcr[2] = cr;
+}
+
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b)
+{
+	unsigned char rgb[3], ycbcr[3];
+	unsigned long flags;
+
+	rgb[0] = r;
+	rgb[1] = g;
+	rgb[2] = b;
+	_davinci_disp_rgb_to_ycbcr(rgb, ycbcr);
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = ycbcr[0];
+	osd->clut_ram[clut_index][1] = ycbcr[1];
+	osd->clut_ram[clut_index][2] = ycbcr[2];
+	_davinci_disp_set_clut_ycbcr(clut_index, ycbcr[0], ycbcr[1], ycbcr[2]);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_clut_rgb);
+
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+					   unsigned char pixel_value)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned char clut_index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0xf];
+		break;
+	default:
+		clut_index = 0;
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return clut_index;
+}
+EXPORT_SYMBOL(davinci_disp_get_palette_map);
+
+static void _davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+					  unsigned char pixel_value,
+					  unsigned char clut_index,
+					  enum davinci_pix_format pixfmt)
+{
+	int bmp_reg, bmp_offset, bmp_mask, bmp_shift;
+	static const int map_1bpp[] = { 0, 15 };
+	static const int map_2bpp[] = { 0, 5, 10, 15 };
+
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+		bmp_reg = map_1bpp[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		bmp_reg = map_2bpp[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		bmp_reg = pixel_value & 0xf;
+		break;
+	default:
+		return;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		bmp_offset = OSD_W0BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	case OSDWIN_OSD1:
+		bmp_offset = OSD_W1BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	default:
+		return;
+	}
+
+	if (bmp_reg & 1) {
+		bmp_shift = 8;
+		bmp_mask = 0xff << 8;
+	} else {
+		bmp_shift = 0;
+		bmp_mask = 0xff;
+	}
+
+	osd_merge(bmp_mask, clut_index << bmp_shift, bmp_offset);
+}
+
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		osdwin_state->palette_map[pixel_value & 0x1] = clut_index;
+		break;
+	case PIXFMT_2BPP:
+		osdwin_state->palette_map[pixel_value & 0x3] = clut_index;
+		break;
+	case PIXFMT_4BPP:
+		osdwin_state->palette_map[pixel_value & 0xf] = clut_index;
+		break;
+	default:
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	_davinci_disp_set_palette_map(osdwin, pixel_value, clut_index,
+				      win->lconfig.pixfmt);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_palette_map);
+
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->rec601_attenuation;
+}
+EXPORT_SYMBOL(davinci_disp_get_rec601_attenuation);
+
+static void _davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+						 int enable)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN0MD_ATN0E,
+				  enable ? OSD_OSDWIN0MD_ATN0E : 0,
+				  OSD_OSDWIN0MD);
+		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
+			osd_merge(OSD_EXTMODE_ATNOSD0EN,
+				  enable ? OSD_EXTMODE_ATNOSD0EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	case OSDWIN_OSD1:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN1MD_ATN1E,
+				  enable ? OSD_OSDWIN1MD_ATN1E : 0,
+				  OSD_OSDWIN1MD);
+		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
+			osd_merge(OSD_EXTMODE_ATNOSD1EN,
+				  enable ? OSD_EXTMODE_ATNOSD1EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	}
+}
+
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->rec601_attenuation = (enable != 0);
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_rec601_attenuation(osdwin, enable);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_rec601_attenuation);
+
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->blend;
+}
+EXPORT_SYMBOL(davinci_disp_get_blending_factor);
+
+static void _davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+					      enum davinci_blending_factor
+					      blend)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_merge(OSD_OSDWIN0MD_BLND0,
+			  blend << OSD_OSDWIN0MD_BLND0_SHIFT, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_merge(OSD_OSDWIN1MD_BLND1,
+			  blend << OSD_OSDWIN1MD_BLND1_SHIFT, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->blend = blend;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blending_factor(osdwin, blend);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_blending_factor);
+
+static void _davinci_disp_enable_rgb888_pixblend(enum davinci_osd_layer osdwin)
+{
+
+	osd_merge(OSD_MISCCTL_BLDSEL, 0, OSD_MISCCTL);
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_merge(OSD_EXTMODE_OSD0BLDCHR,
+			  OSD_EXTMODE_OSD0BLDCHR, OSD_EXTMODE);
+		break;
+	case OSDWIN_OSD1:
+		osd_merge(OSD_EXTMODE_OSD1BLDCHR,
+			  OSD_EXTMODE_OSD1BLDCHR, OSD_EXTMODE);
+		break;
+	}
+}
+
+void davinci_disp_enable_rgb888_pixblend(enum davinci_osd_layer osdwin)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	if (cpu_is_davinci_dm644x())
+		return;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (win->lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_rgb888_pixblend(osdwin);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_enable_rgb888_pixblend);
+
+static void _davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_clear(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 0;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_disable_color_key(osdwin);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_disable_color_key);
+
+static void _davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+					   unsigned colorkey,
+					   enum davinci_pix_format pixfmt)
+{
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+		if (cpu_is_davinci_dm355()) {
+			switch (osdwin) {
+			case OSDWIN_OSD0:
+				osd_merge(OSD_TRANSPBMPIDX_BMP0,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP0_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			case OSDWIN_OSD1:
+				osd_merge(OSD_TRANSPBMPIDX_BMP1,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP1_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			}
+		}
+		break;
+	case PIXFMT_RGB565:
+		if (cpu_is_davinci_dm644x()) {
+			osd_write(colorkey & OSD_TRANSPVAL_RGBTRANS,
+				  OSD_TRANSPVAL);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+		}
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm355())
+			osd_merge(OSD_TRANSPVALU_Y, colorkey, OSD_TRANSPVALU);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+			osd_merge(OSD_TRANSPVALU_RGBU, colorkey >> 16,
+				  OSD_TRANSPVALU);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_set(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 1;
+	osdwin_state->colorkey = colorkey;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR) {
+		_davinci_disp_enable_color_key(osdwin, colorkey,
+					       win->lconfig.pixfmt);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_enable_color_key);
+
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->clut;
+}
+EXPORT_SYMBOL(davinci_disp_get_osd_clut);
+
+static void _davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+				       enum davinci_clut clut)
+{
+	u32 winmd = 0;
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN0MD_CLUTS0;
+		osd_merge(OSD_OSDWIN0MD_CLUTS0, winmd, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN1MD_CLUTS1;
+		osd_merge(OSD_OSDWIN1MD_CLUTS1, winmd, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->clut = clut;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_osd_clut(osdwin, clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_osd_clut);
+
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_zoom = win->h_zoom;
+	*v_zoom = win->v_zoom;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_zoom);
+
+static void _davinci_disp_set_zoom(enum davinci_disp_layer layer,
+				   enum davinci_zoom_factor h_zoom,
+				   enum davinci_zoom_factor v_zoom)
+{
+	u32 winmd = 0;
+
+	switch (layer) {
+	case WIN_OSD0:
+		winmd |= (h_zoom << OSD_OSDWIN0MD_OHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN0MD_OVZ0_SHIFT);
+		osd_merge(OSD_OSDWIN0MD_OHZ0 | OSD_OSDWIN0MD_OVZ0, winmd,
+			  OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ0_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ0 | OSD_VIDWINMD_VVZ0, winmd,
+			  OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		winmd |= (h_zoom << OSD_OSDWIN1MD_OHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN1MD_OVZ1_SHIFT);
+		osd_merge(OSD_OSDWIN1MD_OHZ1 | OSD_OSDWIN1MD_OVZ1, winmd,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ1_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ1 | OSD_VIDWINMD_VVZ1, winmd,
+			  OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->h_zoom = h_zoom;
+	win->v_zoom = v_zoom;
+	_davinci_disp_set_zoom(layer, h_zoom, v_zoom);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_set_zoom);
+
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	return win->is_enabled;
+}
+EXPORT_SYMBOL(davinci_disp_layer_is_enabled);
+
+static void _davinci_disp_disable_layer(enum
+					davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_clear(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* disable attribute mode as well as disabling the window */
+		osd_clear(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_clear(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_disable_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+	win->is_enabled = 0;
+
+	_davinci_disp_disable_layer(layer);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_disable_layer);
+
+static void _davinci_disp_enable_attribute_mode(void)
+{
+	/* enable attribute mode for OSD1 */
+	osd_set(OSD_OSDWIN1MD_OASW, OSD_OSDWIN1MD);
+}
+
+static void _davinci_disp_enable_layer(enum
+				       davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_set(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* enable OSD1 and disable attribute mode */
+		osd_merge(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD_OACT1, OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_set(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+int davinci_disp_enable_layer(enum davinci_disp_layer layer,
+			      int otherwin)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	/* use otherwin flag to know this is the other vid window
+	 * in YUV420 mode, if is, skip this check
+	 */
+	if (!otherwin && (!win->is_allocated ||
+			!win->fb_base_phys ||
+			!win->lconfig.line_length ||
+			!win->lconfig.xsize ||
+			!win->lconfig.ysize)) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+
+	if (win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return 0;
+	}
+	win->is_enabled = 1;
+
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_enable_layer(layer);
+	else {
+		_davinci_disp_enable_attribute_mode();
+		_davinci_disp_set_blink_attribute(osd->is_blinking, osd->blink);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_enable_layer);
+
+static void _davinci_disp_start_layer(enum davinci_disp_layer layer,
+					unsigned long fb_base_phys,
+					unsigned long cbcr_ofst)
+{
+	if (cpu_is_davinci_dm644x()) {
+		switch (layer) {
+		case WIN_OSD0:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN0ADR);
+			break;
+		case WIN_VID0:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+			break;
+		case WIN_OSD1:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN1ADR);
+			break;
+		case WIN_VID1:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN1ADR);
+			break;
+		}
+	} else if (cpu_is_davinci_dm355()) {
+		unsigned long fb_offset_32 =
+		    (fb_base_phys - DAVINCI_DDR_BASE) >> 5;
+
+		switch (layer) {
+		case WIN_OSD0:
+			osd_merge(OSD_OSDWINADH_O0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O0AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN0ADL_O0AL,
+				  OSD_OSDWIN0ADL);
+			break;
+		case WIN_VID0:
+			osd_merge(OSD_VIDWINADH_V0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V0AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN0ADL_V0AL,
+				  OSD_VIDWIN0ADL);
+			break;
+		case WIN_OSD1:
+			osd_merge(OSD_OSDWINADH_O1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O1AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN1ADL_O1AL,
+				  OSD_OSDWIN1ADL);
+			break;
+		case WIN_VID1:
+			osd_merge(OSD_VIDWINADH_V1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V1AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN1ADL_V1AL,
+				  OSD_VIDWIN1ADL);
+			break;
+		}
+	} else if (cpu_is_davinci_dm365()) {
+		struct davinci_window_state *win = &osd->win[layer];
+		unsigned long fb_offset_32, cbcr_offset_32;
+
+		fb_offset_32 = fb_base_phys - DAVINCI_DDR_BASE;
+		if (cbcr_ofst)
+			cbcr_offset_32 = cbcr_ofst;
+		else
+			cbcr_offset_32 = win->lconfig.line_length *
+					 win->lconfig.ysize;
+		cbcr_offset_32 += fb_offset_32;
+		fb_offset_32 = fb_offset_32 >> 5;
+		cbcr_offset_32 = cbcr_offset_32 >> 5;
+		/*
+		 * DM365: start address is 27-bit long address b26 - b23 are
+		 * in offset register b12 - b9, and * bit 26 has to be '1'
+		 */
+		if (win->lconfig.pixfmt == PIXFMT_NV12) {
+			switch (layer) {
+			case WIN_VID0:
+			case WIN_VID1:
+				/* Y is in VID0 */
+				osd_merge(OSD_VIDWIN0OFST_V0AH,
+					 ((fb_offset_32 & 0x7800000) >>
+					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+					  OSD_VIDWIN0OFST);
+				osd_merge(OSD_VIDWINADH_V0AH,
+					  (fb_offset_32 & 0x7F0000) >>
+					  (16 - OSD_VIDWINADH_V0AH_SHIFT),
+					  OSD_VIDWINADH);
+				osd_write(fb_offset_32 & 0xFFFF,
+					  OSD_VIDWIN0ADL);
+				/* CbCr is in VID1 */
+				osd_merge(OSD_VIDWIN1OFST_V1AH,
+					 ((cbcr_offset_32 & 0x7800000) >>
+					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+					  OSD_VIDWIN1OFST);
+				osd_merge(OSD_VIDWINADH_V1AH,
+					  (cbcr_offset_32 & 0x7F0000) >>
+					  (16 - OSD_VIDWINADH_V1AH_SHIFT),
+					  OSD_VIDWINADH);
+				osd_write(cbcr_offset_32 & 0xFFFF,
+					  OSD_VIDWIN1ADL);
+				break;
+			default:
+				break;
+			}
+		}
+
+		switch (layer) {
+		case WIN_OSD0:
+			osd_merge(OSD_OSDWIN0OFST_O0AH,
+				 ((fb_offset_32 & 0x7800000) >>
+				 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+				  OSD_OSDWIN0OFST);
+			osd_merge(OSD_OSDWINADH_O0AH,
+				 (fb_offset_32 & 0x7F0000) >>
+				 (16 - OSD_OSDWINADH_O0AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & 0xFFFF, OSD_OSDWIN0ADL);
+			break;
+		case WIN_VID0:
+			if (win->lconfig.pixfmt != PIXFMT_NV12) {
+				osd_merge(OSD_VIDWIN0OFST_V0AH,
+					 ((fb_offset_32 & 0x7800000) >>
+					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+					  OSD_VIDWIN0OFST);
+				osd_merge(OSD_VIDWINADH_V0AH,
+					  (fb_offset_32 & 0x7F0000) >>
+					  (16 - OSD_VIDWINADH_V0AH_SHIFT),
+					  OSD_VIDWINADH);
+				osd_write(fb_offset_32 & 0xFFFF,
+					  OSD_VIDWIN0ADL);
+			}
+			break;
+		case WIN_OSD1:
+			osd_merge(OSD_OSDWIN1OFST_O1AH,
+				 ((fb_offset_32 & 0x7800000) >>
+				 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+				  OSD_OSDWIN1OFST);
+			osd_merge(OSD_OSDWINADH_O1AH,
+				  (fb_offset_32 & 0x7F0000) >>
+				  (16 - OSD_OSDWINADH_O1AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & 0xFFFF, OSD_OSDWIN1ADL);
+			break;
+		case WIN_VID1:
+			if (win->lconfig.pixfmt != PIXFMT_NV12) {
+				osd_merge(OSD_VIDWIN1OFST_V1AH,
+					 ((fb_offset_32 & 0x7800000) >>
+					 (23 - OSD_WINOFST_AH_SHIFT)) | 0x1000,
+					  OSD_VIDWIN1OFST);
+				osd_merge(OSD_VIDWINADH_V1AH,
+					  (fb_offset_32 & 0x7F0000) >>
+					  (16 - OSD_VIDWINADH_V1AH_SHIFT),
+					  OSD_VIDWINADH);
+				osd_write(fb_offset_32 & 0xFFFF,
+					  OSD_VIDWIN1ADL);
+			}
+			break;
+		}
+	}
+}
+
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys,
+			      unsigned long cbcr_ofst)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->fb_base_phys = fb_base_phys & ~0x1F;
+	_davinci_disp_start_layer(layer, fb_base_phys, cbcr_ofst);
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_start_layer);
+
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*lconfig = win->lconfig;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_get_layer_config);
+
+void _davinci_disp_copy_layer_config(enum davinci_disp_layer to_layer,
+				     enum davinci_disp_layer from_layer)
+{
+	struct davinci_layer_config *tlconfig, *flconfig;
+
+	tlconfig = &(osd->win[to_layer].lconfig);
+	flconfig = &(osd->win[from_layer].lconfig);
+
+	memcpy(tlconfig, flconfig, sizeof(struct davinci_layer_config));
+}
+
+/*
+ * If the requested lconfig is completely rejected and the value of lconfig on
+ * exit is the current lconfig, then try_layer_config() returns 1.  Otherwise,
+ * try_layer_config() returns 0.  A return value of 0 does not necessarily mean
+ * that the value of lconfig on exit is identical to the value of lconfig on
+ * entry, but merely that it represents a change from the current lconfig.
+ */
+static int try_layer_config(enum davinci_disp_layer layer,
+			    struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int bad_config = 0;
+
+	/* verify that the pixel format is compatible with the layer */
+	switch (lconfig->pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+	case PIXFMT_RGB565:
+		bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365())
+			bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_NV12:
+		if (!cpu_is_davinci_dm365())
+			bad_config = 1;
+		else
+			bad_config = is_osd_win(layer);
+		break;
+	case PIXFMT_OSD_ATTR:
+		bad_config = (layer != WIN_OSD1);
+		break;
+	default:
+		bad_config = 1;
+		break;
+	}
+	if (bad_config) {
+		/*
+		 * The requested pixel format is incompatible with the layer, so
+		 * keep the current layer configuration.
+		 */
+		*lconfig = win->lconfig;
+		return bad_config;
+	}
+
+	/* DM6446: */
+	/* only one OSD window at a time can use RGB pixel formats */
+	if ((cpu_is_davinci_dm644x())
+		&& is_osd_win(layer) && is_rgb_pixfmt(lconfig->pixfmt)) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_OSD0)
+			pixfmt = osd->win[WIN_OSD1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_OSD0].lconfig.pixfmt;
+
+		if (is_rgb_pixfmt(pixfmt)) {
+			/*
+			 * The other OSD window is already configured for an
+			 * RGB, so keep the current layer configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* DM6446: only one video window at a time can use RGB888 */
+	if (cpu_is_davinci_dm644x() && is_vid_win(layer)
+	    && lconfig->pixfmt == PIXFMT_RGB888) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_VID0)
+			pixfmt = osd->win[WIN_VID1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_VID0].lconfig.pixfmt;
+
+		if (pixfmt == PIXFMT_RGB888) {
+			/*
+			 * The other video window is already configured for
+			 * RGB888, so keep the current layer configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* window dimensions must be non-zero */
+	if (!lconfig->line_length || !lconfig->xsize || !lconfig->ysize) {
+		*lconfig = win->lconfig;
+		return 1;
+	}
+
+	/* round line_length up to a multiple of 32 */
+	lconfig->line_length = ((lconfig->line_length + 31) / 32) * 32;
+	lconfig->line_length =
+	    min(lconfig->line_length, (unsigned)MAX_LINE_LENGTH);
+	lconfig->xsize = min(lconfig->xsize, (unsigned)MAX_WIN_SIZE);
+	lconfig->ysize = min(lconfig->ysize, (unsigned)MAX_WIN_SIZE);
+	lconfig->xpos = min(lconfig->xpos, (unsigned)MAX_WIN_SIZE);
+	lconfig->ypos = min(lconfig->ypos, (unsigned)MAX_WIN_SIZE);
+	lconfig->interlaced = (lconfig->interlaced != 0);
+	if (lconfig->interlaced) {
+		/* ysize and ypos must be even for interlaced displays */
+		lconfig->ysize &= ~1;
+		lconfig->ypos &= ~1;
+	}
+
+	return 0;
+}
+
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return reject_config;
+}
+EXPORT_SYMBOL(davinci_disp_try_layer_config);
+
+static void _davinci_disp_disable_vid_rgb888(void)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine disables RGB888 pixel format for both video windows.
+	 * The caller must ensure that neither video window is currently
+	 * configured for RGB888 pixel format.
+	 */
+	if (cpu_is_davinci_dm644x())
+		osd_clear(OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+}
+
+static void _davinci_disp_enable_vid_rgb888(enum davinci_disp_layer layer)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine enables RGB888 pixel format for the specified video
+	 * window.  The caller must ensure that the other video window is not
+	 * currently configured for RGB888 pixel format, as this routine will
+	 * disable RGB888 pixel format for the other window.
+	 */
+	if (cpu_is_davinci_dm644x()) {
+		if (layer == WIN_VID0) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+		} else if (layer == WIN_VID1) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL);
+		}
+	}
+}
+
+static void _davinci_disp_set_cbcr_order(enum davinci_pix_format pixfmt)
+{
+	/*
+	 * The caller must ensure that all windows using YC pixfmt use the same
+	 * Cb/Cr order.
+	 */
+	if (pixfmt == PIXFMT_YCbCrI)
+		osd_clear(OSD_MODE_CS, OSD_MODE);
+	else if (pixfmt == PIXFMT_YCrCbI)
+		osd_set(OSD_MODE_CS, OSD_MODE);
+}
+
+static void _davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+					   const struct davinci_layer_config
+					   *lconfig)
+{
+	u32 winmd = 0, winmd_mask = 0, bmw = 0;
+
+	_davinci_disp_set_cbcr_order(lconfig->pixfmt);
+
+	switch (layer) {
+	case WIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			winmd_mask |= OSD_OSDWIN0MD_RGB0E;
+			if (lconfig->pixfmt == PIXFMT_RGB565)
+				winmd |= OSD_OSDWIN0MD_RGB0E;
+		} else if (cpu_is_davinci_dm355() || cpu_is_davinci_dm365()) {
+			winmd_mask |= OSD_OSDWIN0MD_BMP0MD;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_RGB565:
+				winmd |= (1 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			case PIXFMT_RGB888:
+				winmd |= (2 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				_davinci_disp_enable_rgb888_pixblend
+				    (OSDWIN_OSD0);
+				break;
+			case PIXFMT_YCbCrI:
+			case PIXFMT_YCrCbI:
+				winmd |= (3 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			default:
+				break;
+			}
+		}
+
+		winmd_mask |= OSD_OSDWIN0MD_BMW0 | OSD_OSDWIN0MD_OFF0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			bmw = 0;
+			break;
+		case PIXFMT_2BPP:
+			bmw = 1;
+			break;
+		case PIXFMT_4BPP:
+			bmw = 2;
+			break;
+		case PIXFMT_8BPP:
+			bmw = 3;
+			break;
+		default:
+			break;
+		}
+		winmd |= (bmw << OSD_OSDWIN0MD_BMW0_SHIFT);
+
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN0MD_OFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN0MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN0XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN0XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN0YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN0YL);
+		}
+		break;
+	case WIN_VID0:
+		winmd_mask |= OSD_VIDWINMD_VFF0;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN0XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN0XL);
+		/*
+		 * For YUV420P format the register contents are
+		 * duplicated in both VID registers
+		 */
+		if (cpu_is_davinci_dm365()) {
+			if (lconfig->pixfmt == PIXFMT_NV12) {
+				/* other window also */
+				if (lconfig->interlaced) {
+					winmd_mask |= OSD_VIDWINMD_VFF1;
+					winmd |= OSD_VIDWINMD_VFF1;
+					osd_merge(winmd_mask, winmd,
+						  OSD_VIDWINMD);
+				}
+
+				osd_merge(OSD_MISCCTL_S420D, OSD_MISCCTL_S420D,
+					  OSD_MISCCTL);
+				osd_write(lconfig->line_length >> 5,
+					  OSD_VIDWIN1OFST);
+				osd_write(lconfig->xpos, OSD_VIDWIN1XP);
+				osd_write(lconfig->xsize, OSD_VIDWIN1XL);
+				/* if NV21 pixfmt and line length not 32B
+				 * aligned (e.g. NTSC), Need to set window
+				 * X pixel size to be 32B aligned as well
+				 */
+				if (lconfig->xsize % 32) {
+					osd_write(((lconfig->xsize + 31) & ~31),
+						  OSD_VIDWIN1XL);
+					osd_write(((lconfig->xsize + 31) & ~31),
+						  OSD_VIDWIN0XL);
+				}
+			} else
+				osd_merge(OSD_MISCCTL_S420D, ~OSD_MISCCTL_S420D,
+					  OSD_MISCCTL);
+		}
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
+			if (cpu_is_davinci_dm365()
+			    && lconfig->pixfmt == PIXFMT_NV12) {
+				osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
+				osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
+			}
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN0YL);
+			if (cpu_is_davinci_dm365()
+			    && lconfig->pixfmt == PIXFMT_NV12) {
+				osd_write(lconfig->ypos, OSD_VIDWIN1YP);
+				osd_write(lconfig->ysize, OSD_VIDWIN1YL);
+			}
+		}
+		break;
+	case WIN_OSD1:
+		/*
+		 * The caller must ensure that OSD1 is disabled prior to
+		 * switching from a normal mode to attribute mode or from
+		 * attribute mode to a normal mode.
+		 */
+		if (lconfig->pixfmt == PIXFMT_OSD_ATTR) {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_ATN1E | OSD_OSDWIN1MD_RGB1E |
+				    OSD_OSDWIN1MD_CLUTS1 | OSD_OSDWIN1MD_BLND1 |
+				    OSD_OSDWIN1MD_TE1;
+			} else {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_BMP1MD | OSD_OSDWIN1MD_CLUTS1
+				    | OSD_OSDWIN1MD_BLND1 | OSD_OSDWIN1MD_TE1;
+			}
+		} else {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |= OSD_OSDWIN1MD_RGB1E;
+				if (lconfig->pixfmt == PIXFMT_RGB565)
+					winmd |= OSD_OSDWIN1MD_RGB1E;
+			} else if (cpu_is_davinci_dm355()
+				   || cpu_is_davinci_dm365()) {
+				winmd_mask |= OSD_OSDWIN1MD_BMP1MD;
+				switch (lconfig->pixfmt) {
+				case PIXFMT_RGB565:
+					winmd |=
+					    (1 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				case PIXFMT_RGB888:
+					winmd |=
+					    (2 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					_davinci_disp_enable_rgb888_pixblend
+					    (OSDWIN_OSD1);
+					break;
+				case PIXFMT_YCbCrI:
+				case PIXFMT_YCrCbI:
+					winmd |=
+					    (3 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				default:
+					break;
+				}
+			}
+
+			winmd_mask |= OSD_OSDWIN1MD_BMW1;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_1BPP:
+				bmw = 0;
+				break;
+			case PIXFMT_2BPP:
+				bmw = 1;
+				break;
+			case PIXFMT_4BPP:
+				bmw = 2;
+				break;
+			case PIXFMT_8BPP:
+				bmw = 3;
+				break;
+			default:
+				break;
+			}
+			winmd |= (bmw << OSD_OSDWIN1MD_BMW1_SHIFT);
+		}
+
+		winmd_mask |= OSD_OSDWIN1MD_OFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN1MD_OFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN1MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN1XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN1XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN1YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN1YL);
+		}
+		break;
+	case WIN_VID1:
+		winmd_mask |= OSD_VIDWINMD_VFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN1XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN1XL);
+		/*
+		 * For YUV420P format the register contents are
+		 * duplicated in both VID registers
+		 */
+		if (cpu_is_davinci_dm365()) {
+			if (lconfig->pixfmt == PIXFMT_NV12) {
+				/* other window also */
+				if (lconfig->interlaced) {
+					winmd_mask |= OSD_VIDWINMD_VFF0;
+					winmd |= OSD_VIDWINMD_VFF0;
+					osd_merge(winmd_mask, winmd,
+						  OSD_VIDWINMD);
+				}
+				osd_merge(OSD_MISCCTL_S420D, OSD_MISCCTL_S420D,
+					  OSD_MISCCTL);
+				osd_write(lconfig->line_length >> 5,
+					  OSD_VIDWIN0OFST);
+				osd_write(lconfig->xpos, OSD_VIDWIN0XP);
+				osd_write(lconfig->xsize, OSD_VIDWIN0XL);
+		} else
+			osd_merge(OSD_MISCCTL_S420D, ~OSD_MISCCTL_S420D,
+				  OSD_MISCCTL);
+		}
+
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
+			if (cpu_is_davinci_dm365()
+			    && lconfig->pixfmt == PIXFMT_NV12) {
+				osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
+				osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
+			}
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN1YL);
+			if (cpu_is_davinci_dm365()
+			    && lconfig->pixfmt == PIXFMT_NV12) {
+				osd_write(lconfig->ypos, OSD_VIDWIN0YP);
+				osd_write(lconfig->ysize, OSD_VIDWIN0YL);
+			}
+		}
+		break;
+	}
+}
+
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+	if (reject_config) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return reject_config;
+	}
+
+	/* update the current Cb/Cr order */
+	if (is_yc_pixfmt(lconfig->pixfmt))
+		osd->yc_pixfmt = lconfig->pixfmt;
+
+	/*
+	 * If we are switching OSD1 from normal mode to attribute mode or from
+	 * attribute mode to normal mode, then we must disable the window.
+	 */
+	if (layer == WIN_OSD1) {
+		if (((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+		     && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR))
+		    || ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+			&& (win->lconfig.pixfmt == PIXFMT_OSD_ATTR))) {
+			win->is_enabled = 0;
+			_davinci_disp_disable_layer(layer);
+		}
+	}
+
+	_davinci_disp_set_layer_config(layer, lconfig);
+
+	if (layer == WIN_OSD1) {
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[OSDWIN_OSD1];
+
+		if ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+		    && (win->lconfig.pixfmt == PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from attribute mode to normal
+			 * mode, so we must initialize the CLUT select, the
+			 * blend factor, transparency colorkey enable, and
+			 * attenuation enable (DM6446 only) bits in the
+			 * OSDWIN1MD register.
+			 */
+			_davinci_disp_set_osd_clut(OSDWIN_OSD1,
+						   osdwin_state->clut);
+			_davinci_disp_set_blending_factor(OSDWIN_OSD1,
+							  osdwin_state->blend);
+			if (osdwin_state->colorkey_blending) {
+				_davinci_disp_enable_color_key(OSDWIN_OSD1,
+							       osdwin_state->
+							       colorkey,
+							       lconfig->pixfmt);
+			} else
+				_davinci_disp_disable_color_key(OSDWIN_OSD1);
+			_davinci_disp_set_rec601_attenuation(OSDWIN_OSD1,
+							     osdwin_state->
+							     rec601_attenuation);
+		} else if ((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+			   && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from normal mode to attribute
+			 * mode, so we must initialize the blink enable and
+			 * blink interval bits in the OSDATRMD register.
+			 */
+			_davinci_disp_set_blink_attribute(osd->is_blinking,
+							  osd->blink);
+		}
+	}
+
+	/*
+	 * If we just switched to a 1-, 2-, or 4-bits-per-pixel bitmap format
+	 * then configure a default palette map.
+	 */
+	if ((lconfig->pixfmt != win->lconfig.pixfmt)
+	    && ((lconfig->pixfmt == PIXFMT_1BPP)
+		|| (lconfig->pixfmt == PIXFMT_2BPP)
+		|| (lconfig->pixfmt == PIXFMT_4BPP))) {
+		enum davinci_osd_layer osdwin =
+		    ((layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1);
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[osdwin];
+		unsigned char clut_index;
+		unsigned char clut_entries = 0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			clut_entries = 2;
+			break;
+		case PIXFMT_2BPP:
+			clut_entries = 4;
+			break;
+		case PIXFMT_4BPP:
+			clut_entries = 16;
+			break;
+		default:
+			break;
+		}
+		/*
+		 * The default palette map maps the pixel value to the clut
+		 * index, i.e. pixel value 0 maps to clut entry 0, pixel value 1
+		 * maps to clut entry 1, etc.
+		 */
+		for (clut_index = 0; clut_index < 16; clut_index++) {
+			osdwin_state->palette_map[clut_index] = clut_index;
+			if (clut_index < clut_entries) {
+				_davinci_disp_set_palette_map(osdwin,
+							      clut_index,
+							      clut_index,
+							      lconfig->pixfmt);
+			}
+		}
+	}
+
+	win->lconfig = *lconfig;
+	/* DM6446: configure the RGB888 enable and window selection */
+	if (osd->win[WIN_VID0].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID0);
+	else if (osd->win[WIN_VID1].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID1);
+	else
+		_davinci_disp_disable_vid_rgb888();
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_set_layer_config);
+
+void davinci_disp_init_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	enum davinci_osd_layer osdwin;
+	struct davinci_osdwin_state *osdwin_state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_enabled = 0;
+	_davinci_disp_disable_layer(layer);
+
+	win->h_zoom = ZOOM_X1;
+	win->v_zoom = ZOOM_X1;
+	_davinci_disp_set_zoom(layer, win->h_zoom, win->v_zoom);
+
+	win->fb_base_phys = 0;
+	_davinci_disp_start_layer(layer, win->fb_base_phys, 0);
+
+	win->lconfig.line_length = 0;
+	win->lconfig.xsize = 0;
+	win->lconfig.ysize = 0;
+	win->lconfig.xpos = 0;
+	win->lconfig.ypos = 0;
+	win->lconfig.interlaced = 0;
+	switch (layer) {
+	case WIN_OSD0:
+	case WIN_OSD1:
+		osdwin = (layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1;
+		osdwin_state = &osd->osdwin[osdwin];
+		/*
+		 * Other code relies on the fact that OSD windows default to a
+		 * bitmap pixel format when they are deallocated, so don't
+		 * change this default pixel format.
+		 */
+		win->lconfig.pixfmt = PIXFMT_8BPP;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		osdwin_state->clut = RAM_CLUT;
+		_davinci_disp_set_osd_clut(osdwin, osdwin_state->clut);
+		osdwin_state->colorkey_blending = 0;
+		_davinci_disp_disable_color_key(osdwin);
+		osdwin_state->blend = OSD_8_VID_0;
+		_davinci_disp_set_blending_factor(osdwin, osdwin_state->blend);
+		osdwin_state->rec601_attenuation = 0;
+		_davinci_disp_set_rec601_attenuation(osdwin,
+						     osdwin_state->
+						     rec601_attenuation);
+		if (osdwin == OSDWIN_OSD1) {
+			osd->is_blinking = 0;
+			osd->blink = BLINK_X1;
+		}
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		win->lconfig.pixfmt = osd->yc_pixfmt;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_init_layer);
+
+void davinci_disp_release_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	davinci_disp_init_layer(layer);
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_allocated = 0;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+EXPORT_SYMBOL(davinci_disp_release_layer);
+
+int davinci_disp_request_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+	win->is_allocated = 1;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(davinci_disp_request_layer);
+
+static void _davinci_disp_init(void)
+{
+	osd_write(0, OSD_MODE);
+	osd_write(0, OSD_VIDWINMD);
+	osd_write(0, OSD_OSDWIN0MD);
+	osd_write(0, OSD_OSDWIN1MD);
+	osd_write(0, OSD_RECTCUR);
+	osd_write(0, OSD_MISCCTL);
+	if (cpu_is_davinci_dm355()) {
+		osd_write(0, OSD_VBNDRY);
+		osd_write(0, OSD_EXTMODE);
+		osd_write(OSD_MISCCTL_DMANG, OSD_MISCCTL);
+	}
+}
+
+static int davinci_osd_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	osd->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(osd->dev, "Unable to get VENC interrupt");
+		return -ENOENT;
+	}
+	osd->irq = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(osd->dev, "Unable to get OSD register address map\n");
+		return -ENODEV;
+	}
+	osd->osd_base_phys = res->start;
+	osd->osd_size = res->end - res->start + 1;
+	if (!request_mem_region(osd->osd_base_phys, osd->osd_size,
+				MODULE_NAME)) {
+		dev_err(osd->dev, "Unable to reserve OSD MMIO region\n");
+		return -ENODEV;
+	}
+	osd->osd_base = (unsigned long)ioremap_nocache(res->start,
+							osd->osd_size);
+	if (!osd->osd_base) {
+		dev_err(osd->dev, "Unable to map the OSD region\n");
+		goto release_osd1;
+	}
+
+	if (request_irq(osd->irq, davinci_disp_isr, IRQF_SHARED, MODULE_NAME,
+			osd)) {
+		dev_err(osd->dev,"Unable to request interrupt\n");
+		goto release_osd2;
+	}
+
+	_davinci_disp_init();
+
+	/* set default Cb/Cr order */
+	osd->yc_pixfmt = PIXFMT_YCbCrI;
+
+	if (cpu_is_davinci_dm355()) {
+		/*
+		 * ROM CLUT1 on the DM355 is similar (identical?) to ROM CLUT0
+		 * on the DM6446, so make ROM_CLUT1 the default on the DM355.
+		 */
+		osd->rom_clut = ROM_CLUT1;
+	}
+	_davinci_disp_set_field_inversion(osd->field_inversion);
+	_davinci_disp_set_rom_clut(osd->rom_clut);
+
+	davinci_disp_init_layer(WIN_OSD0);
+	davinci_disp_init_layer(WIN_VID0);
+	davinci_disp_init_layer(WIN_OSD1);
+	davinci_disp_init_layer(WIN_VID1);
+
+	return 0;
+
+release_osd2:
+	iounmap((void *)osd->osd_base);
+release_osd1:
+	release_mem_region(osd->osd_base_phys, osd->osd_size);
+
+	return -ENODEV;
+}
+
+static int davinci_osd_remove(struct platform_device *pdev)
+{
+	free_irq(osd->irq, osd);
+	if (osd->osd_base)
+		iounmap((void *)osd->osd_base);
+	release_mem_region(osd->osd_base_phys, osd->osd_size);
+
+	return 0;
+}
+
+static struct platform_driver davinci_osd_driver = {
+	.probe		= davinci_osd_probe,
+	.remove		= davinci_osd_remove,
+	.driver		= {
+		.name	= MODULE_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+int davinci_osd_init(void)
+{
+	spin_lock_init(&osd->lock);
+
+	/* Register the driver */
+	if (platform_driver_register(&davinci_osd_driver)) {
+		printk(KERN_ERR "Unable to register davinci osd driver\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void davinci_osd_exit(void)
+{
+	platform_driver_unregister(&davinci_osd_driver);
+}
+
+subsys_initcall(davinci_osd_init);
+module_exit(davinci_osd_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DaVinci OSD Manager Driver");
+MODULE_AUTHOR("Texas Instruments");
diff --git a/drivers/media/video/davinci/davinci_platform.c b/drivers/media/video/davinci/davinci_platform.c
new file mode 100644
index 0000000..b0f0cd0
--- /dev/null
+++ b/drivers/media/video/davinci/davinci_platform.c
@@ -0,0 +1,1295 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/attribute_container.h>
+#include <linux/platform_device.h>
+#include <mach/hardware.h>
+#include <mach/mux.h>
+#include <mach/cpu.h>
+#include <mach/io.h>
+#include <mach/i2c.h>
+#include <asm/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+#define MSP430_I2C_ADDR		(0x25)
+#define PCA9543A_I2C_ADDR	(0x73)
+#define THS7303			0
+#define THS7303_I2C_ADDR	(0x2C)
+#define THS7353_I2C_ADDR	(0x2E)
+#define THS7353			1
+#define THS73XX_CHANNEL_1	1
+#define THS73XX_CHANNEL_2	2
+#define THS73XX_CHANNEL_3	3
+#define DM365_CPLD_REGISTER3	(0x04000018)
+#define DM365_TVP7002_SEL	(0x1)
+#define DM365_SENSOR_SEL	(0x2)
+#define DM365_TVP5146_SEL	(0x5)
+#define DM365_VIDEO_MUX_MASK	(0x7)
+#define DM644X_DDR2_CNTL_BASE	(0x20000000)
+
+struct davinci_venc_state {
+	spinlock_t lock;
+	struct device *vdev;
+	dma_addr_t venc_base_phys;
+	unsigned long venc_base;
+	unsigned long venc_size;
+};
+
+static struct davinci_venc_state venc_state;
+static struct davinci_venc_state *venc = &venc_state;
+
+enum ths73xx_filter_mode {
+	THS_FILTER_MODE_480I,
+	THS_FILTER_MODE_576I,
+	THS_FILTER_MODE_480P,
+	THS_FILTER_MODE_576P,
+	THS_FILTER_MODE_720P,
+	THS_FILTER_MODE_1080I,
+	THS_FILTER_MODE_1080P
+};
+
+extern struct vid_enc_device_mgr enc_dev[];
+
+struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
+	{VID_ENC_OUTPUT_COMPOSITE,
+	 VID_ENC_STD_NTSC}
+};
+
+EXPORT_SYMBOL(davinci_enc_default);
+
+char *davinci_outputs[] = {
+	VID_ENC_OUTPUT_COMPOSITE,
+	VID_ENC_OUTPUT_COMPOSITE1,
+	VID_ENC_OUTPUT_SVIDEO,
+	VID_ENC_OUTPUT_SVIDEO1,
+	VID_ENC_OUTPUT_COMPONENT,
+	VID_ENC_OUTPUT_COMPONENT1,
+	VID_ENC_OUTPUT_LCD,
+	VID_ENC_OUTPUT_LCD1,
+	""
+};
+
+EXPORT_SYMBOL(davinci_outputs);
+
+char *davinci_modes[] = {
+	VID_ENC_STD_NTSC,
+	"ntsc",
+	VID_ENC_STD_NTSC_RGB,
+	VID_ENC_STD_PAL,
+	"pal",
+	VID_ENC_STD_PAL_RGB,
+	VID_ENC_STD_720P_24,
+	VID_ENC_STD_720P_25,
+	VID_ENC_STD_720P_30,
+	VID_ENC_STD_720P_50,
+	VID_ENC_STD_720P_60,
+	VID_ENC_STD_1080I_25,
+	VID_ENC_STD_1080I_30,
+	VID_ENC_STD_1080P_25,
+	VID_ENC_STD_1080P_30,
+	VID_ENC_STD_1080P_50,
+	VID_ENC_STD_1080P_60,
+	VID_ENC_STD_480P_60,
+	VID_ENC_STD_576P_50,
+	VID_ENC_STD_640x480,
+	VID_ENC_STD_640x400,
+	VID_ENC_STD_640x350,
+	VID_ENC_STD_800x480,
+	""
+};
+
+EXPORT_SYMBOL(davinci_modes);
+
+static __inline__ u32 dispc_reg_in(u32 offset)
+{
+	return (__raw_readl(venc->venc_base + offset));
+}
+
+static __inline__ u32 dispc_reg_out(u32 offset, u32 val)
+{
+	__raw_writel(val, (venc->venc_base + offset));
+
+	return (val);
+}
+
+static __inline__ u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+
+	addr = venc->venc_base + offset;
+
+	new_val = (__raw_readl(addr) & ~mask) | (val & mask);
+	__raw_writel(new_val, addr);
+	return (new_val);
+}
+
+u32 venc_reg_in(u32 offset)
+{
+	return (__raw_readl(venc->venc_base + offset));
+}
+EXPORT_SYMBOL(venc_reg_in);
+
+u32 venc_reg_out(u32 offset, u32 val)
+{
+	__raw_writel(val, (venc->venc_base + offset));
+
+	return (val);
+}
+EXPORT_SYMBOL(venc_reg_out);
+
+u32 venc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+
+	addr = venc->venc_base + offset;
+
+	new_val = (__raw_readl(addr) & ~mask) | (val & mask);
+	__raw_writel(new_val, addr);
+	return (new_val);
+}
+EXPORT_SYMBOL(venc_reg_merge);
+
+static void __iomem *display_cntl_base;
+
+static DEFINE_SPINLOCK(reg_access_lock);
+static void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy)
+{
+	spin_lock(&reg_access_lock);
+
+	osd_write_left_margin(basepx & OSD_BASEPX_BPX);
+	osd_write_upper_margin(basepy & OSD_BASEPY_BPY);
+	
+	spin_unlock(&reg_access_lock);
+}
+
+static void davinci_enc_get_basep(int channel, unsigned *basepx,
+				  unsigned *basepy)
+{
+	spin_lock(&reg_access_lock);
+
+	*basepx = (OSD_BASEPX_BPX & osd_read_left_margin());
+	*basepy = (OSD_BASEPY_BPY & osd_read_upper_margin());
+
+	spin_unlock(&reg_access_lock);
+}
+
+struct system_device {
+	struct module *owner;
+	struct device class_dev;
+};
+
+static struct system_device *davinci_system_device;
+
+#define to_system_dev(cdev)	container_of(cdev, \
+ struct system_device, class_dev)
+
+static void davinci_system_class_release(struct device *cdev)
+{
+	struct system_device *dev = to_system_dev(cdev);
+
+	if (dev != NULL)
+		kfree(dev);
+}
+
+struct class davinci_system_class = {
+	.name = "davinci_system",
+	.owner	= THIS_MODULE,
+	.dev_release = davinci_system_class_release,
+};
+
+static ssize_t
+reg_store(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t count)
+{
+	char *str = 0;
+	char *bufv = 0;
+	int addr = 0;
+	int val = 0;
+	int len = 0;
+
+	if (!buffer || (count == 0) || (count >= 128))
+		return 0;
+
+	str = kmalloc(128, GFP_KERNEL);
+	if (0 == str)
+		return -ENOMEM;
+
+	strcpy(str, buffer);
+	/* overwrite the '\n' */
+	strcpy(str + count - 1, "\0");
+
+	/* format: <address> [<value>]
+	   if only <address> present, it is a read
+	   if <address> <value>, then it is a write */
+	len = strcspn(str, " ");
+	addr = simple_strtoul(str, NULL, 16);
+
+	if (len != count - 1) {
+		bufv = str;
+		strsep(&bufv, " ");
+		val = simple_strtoul(bufv, NULL, 16);
+	}
+
+	kfree(str);
+
+	/* for now, restrict this to access DDR2 controller
+	   Peripheral Bust Burst Priority Register PBBPR
+	   (addr: 0x20000020) only */
+	if (addr != (DM644X_DDR2_CNTL_BASE + 0x20))
+		return -EINVAL;
+
+	spin_lock(&reg_access_lock);
+	if (bufv != 0)
+		writel(val, display_cntl_base + addr - DM644X_DDR2_CNTL_BASE);
+	printk(KERN_NOTICE "%05x  %08x\n", addr,
+	       readl(display_cntl_base + addr - DM644X_DDR2_CNTL_BASE));
+	spin_unlock(&reg_access_lock);
+
+	return count;
+}
+
+static ssize_t reg_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t osd_basepx_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	unsigned int basepx, basepy;
+	int p;
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	p = sprintf(buf, "%d\n", basepx);
+	return p;
+}
+
+static ssize_t osd_basepx_store(struct device *cdev, struct device_attribute *attr, const char *buffer,
+				size_t count)
+{
+	unsigned int basepx, basepy;
+	char reg_val[10];
+
+	if (count >= 9) {
+		strncpy(reg_val, buffer, 9);
+		reg_val[9] = '\0';
+	} else {
+		/* overwrite the '\n' */
+		strcpy(reg_val, buffer);
+		strcpy(reg_val + count - 1, "\0");
+	}
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	basepx = simple_strtoul(reg_val, NULL, 10);
+
+	if (basepx > OSD_BASEPX_BPX) {
+		printk(KERN_ERR "Invalid value for OSD basepx\n");
+		return count;
+	}
+	davinci_enc_set_basep(0, basepx, basepy);
+	return count;
+}
+
+static ssize_t osd_basepy_show(struct device *cdev, struct device_attribute *attr, char *buf)
+{
+	unsigned int basepx, basepy;
+	int p;
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	p = sprintf(buf, "%d\n", basepy);
+	return p;
+}
+
+static ssize_t osd_basepy_store(struct device *cdev, struct device_attribute *attr, const char *buffer,
+				size_t count)
+{
+	unsigned int basepx, basepy;
+	char reg_val[10];
+
+	if (count >= 9) {
+		strncpy(reg_val, buffer, 9);
+		reg_val[9] = '\0';
+	} else {
+		/* overwrite the '\n' */
+		strcpy(reg_val, buffer);
+		strcpy(reg_val + count - 1, "\0");
+	}
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	basepy = simple_strtoul(reg_val, NULL, 10);
+	if (basepy > OSD_BASEPY_BPY) {
+		printk(KERN_ERR "Invalid value for OSD basepy\n");
+		return count;
+	}
+	davinci_enc_set_basep(0, basepx, basepy);
+	return count;
+}
+
+#define DECLARE_ATTR(_name, _mode, _show, _store) {		\
+	.attr   = { .name = __stringify(_name), .mode = _mode,	\
+		    .owner = THIS_MODULE },  			\
+	.show   = _show,                                        \
+	.store  = _store,}
+
+static struct device_attribute system_device_attributes[] = {
+	DECLARE_ATTR(reg, S_IRWXUGO, reg_show, reg_store),
+	DECLARE_ATTR(vpbe_osd_basepx, S_IRWXUGO, osd_basepx_show,
+		     osd_basepx_store),
+	DECLARE_ATTR(vpbe_osd_basepy, S_IRWXUGO, osd_basepy_show,
+		     osd_basepy_store)
+};
+
+static void *create_sysfs_files(void)
+{
+	struct system_device *dev;
+	int ret;
+	int i;
+
+	dev = kzalloc(sizeof(struct system_device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->owner = THIS_MODULE;
+	dev->class_dev.class = &davinci_system_class;
+	dev_set_name(&dev->class_dev, "%s", "system");
+//	dev_set_drvdata(&dev->class_dev, dev);
+	ret = device_register(&dev->class_dev);
+	if (ret < 0) {
+		printk(KERN_ERR "DaVinci Platform: Error in device_register\n");
+		kfree(dev);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(system_device_attributes); i++) {
+		ret = device_create_file(&dev->class_dev,
+					       &system_device_attributes
+					       [i]);
+		if (ret < 0) {
+			while (--i >= 0)
+				device_remove_file(&dev->class_dev,
+					 &system_device_attributes
+					 [i]);
+			device_unregister(&dev->class_dev);
+			printk(KERN_ERR "Error in device_create_file\n");
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+static void remove_sysfs_files(struct system_device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(system_device_attributes); i++)
+		device_remove_file(&dev->class_dev,
+					 &system_device_attributes[i]);
+
+	device_unregister(&dev->class_dev);
+}
+
+/**
+ * function davinci_enc_select_venc_clk
+ * @clk_source: clock source defined by davinci_enc_clk_source_type
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Select the venc input clock based on the clk_source_type.
+ */
+int davinci_enc_select_venc_clock(int clk)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_select_venc_clock);
+
+/* TODO */
+#if 0
+/* function to configure THS7303 filter */
+static int tvp73xx_setup_channel(u8 device, enum ths73xx_filter_mode mode)
+{
+	u8 val[2];
+	u8 input_bias_luma = 2, input_bias_chroma = 2, temp;
+	u8 i2c_addr = THS7303_I2C_ADDR;
+	int err = 0;
+
+	if (device == THS7353) {
+		i2c_addr = THS7353_I2C_ADDR;
+		input_bias_luma = 5;
+		input_bias_chroma = 4;
+	}
+
+	/* setup 7303
+	 * Input Mux A
+	 */
+	val[1] = 0;
+	switch (mode) {
+	case THS_FILTER_MODE_1080P:
+	{
+		/* LPF - 5MHz */
+		val[1] = (3 << 6);
+		/* LPF - bypass */
+		val[1] |= (3 << 3);
+		break;
+	}
+	case THS_FILTER_MODE_1080I:
+	case THS_FILTER_MODE_720P:
+	{
+		/* LPF - 5MHz */
+		val[1] = (2 << 6);
+		/* LPF - 35 MHz */
+		val[1] |= (2 << 3);
+		break;
+	}
+	case THS_FILTER_MODE_480P:
+	case THS_FILTER_MODE_576P:
+	{
+		/* LPF - 2.5MHz */
+		val[1] = (1 << 6);
+		/* LPF - 16 MHz */
+		val[1] |= (1 << 3);
+		break;
+	}
+	case THS_FILTER_MODE_480I:
+	case THS_FILTER_MODE_576I:
+	{
+		/* LPF - 500 KHz, LPF - 9 MHz. Do nothing */
+		break;
+	}
+	default:
+		return -1;
+	}
+	/* setup channel2 - Luma - Green */
+	temp = val[1];
+	val[1] |= input_bias_luma;
+	val[0] = THS73XX_CHANNEL_2;
+	err = davinci_i2c_write(2, val, i2c_addr);
+
+	/* setup channel1 chroam - Red */
+	val[1] = temp;
+	val[1] |= input_bias_chroma;
+
+	val[0] = THS73XX_CHANNEL_1;
+	err |= davinci_i2c_write(2, val, i2c_addr);
+
+	val[0] = THS73XX_CHANNEL_3;
+	err |= davinci_i2c_write(2, val, i2c_addr);
+	return 0;
+}
+#endif
+
+static void enableDigitalOutput(int bEnable)
+{
+	if (bEnable) {
+		dispc_reg_out(VENC_VMOD, 0);
+		dispc_reg_out(VENC_CVBS, 0);
+
+		if (cpu_is_davinci_dm644x())
+			__raw_writel(0, IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
+
+		dispc_reg_out(VENC_LCDOUT, 0);
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_DACSEL, 0);
+
+	} else {
+		/* Initialize the VPSS Clock Control register */
+		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
+		if (cpu_is_davinci_dm644x())
+			__raw_writel(0, IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
+
+		/* Set PINMUX0 reg to enable LCD (all other settings are kept
+		   per boot)
+		 */
+		if (cpu_is_davinci_dm644x()) {
+			davinci_cfg_reg(DM644X_LOEEN);
+			davinci_cfg_reg(DM644X_LFLDEN);
+		}
+
+		/* disable VCLK output pin enable */
+		dispc_reg_out(VENC_VIDCTL, 0x141);
+
+		/* Disable output sync pins */
+		dispc_reg_out(VENC_SYNCCTL, 0);
+
+		/* Disable DCLOCK */
+		dispc_reg_out(VENC_DCLKCTL, 0);
+		dispc_reg_out(VENC_DRGBX1, 0x0000057C);
+
+		/* Disable LCD output control (accepting default polarity) */
+		dispc_reg_out(VENC_LCDOUT, 0);
+		if (!cpu_is_davinci_dm355())
+			dispc_reg_out(VENC_CMPNT, 0x100);
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+
+		dispc_reg_out(VENC_HSDLY, 0);
+		dispc_reg_out(VENC_VSDLY, 0);
+
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_VSTARTA, 0);
+
+		/* Set OSD clock and OSD Sync Adavance registers */
+		dispc_reg_out(VENC_OSDCLK0, 1);
+		dispc_reg_out(VENC_OSDCLK1, 2);
+	}
+}
+
+/*
+ * setting NTSC mode
+ */
+
+static void davinci_enc_set_ntsc(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x01);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM 350 Configure VDAC_CONFIG , why ?? */
+		__raw_writel(0x0E21A6B6, IO_ADDRESS(DM3XX_VDAC_CONFIG));
+	} else if (cpu_is_davinci_dm365()) {
+		dispc_reg_out(VENC_CLKCTL, 0x01);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		__raw_writel(0x081141CF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
+	}
+
+	osd_write_left_margin(mode_info->left_margin);
+	osd_write_upper_margin(mode_info->upper_margin);
+
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ * setting PAL mode
+ */
+static void davinci_enc_set_pal(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x1);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM350 Configure VDAC_CONFIG  */
+		__raw_writel(0x0E21A6B6, IO_ADDRESS(DM3XX_VDAC_CONFIG));
+	} else if (cpu_is_davinci_dm365()) {
+		dispc_reg_out(VENC_CLKCTL, 0x1);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		__raw_writel(0x081141CF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+	}
+
+	dispc_reg_merge(VENC_SYNCCTL, 1 << VENC_SYNCCTL_OVD_SHIFT,
+			VENC_SYNCCTL_OVD);
+
+	
+	osd_write_left_margin(mode_info->left_margin);
+	/* PAL display shows shakiness in the OSD0 when
+	 * this is set to upper margin. Need to bump it
+	 * by 2 in the case of DM365
+	 */
+
+	if (cpu_is_davinci_dm365())
+		osd_write_upper_margin(mode_info->upper_margin + 2);
+	else
+		osd_write_upper_margin(mode_info->upper_margin);
+
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+	dispc_reg_out(VENC_DACTST, 0x0);
+}
+
+/*
+ * davinci_enc_ntsc_pal_rgb
+ */
+/* This function configures the video encoder to NTSC RGB setting.*/
+static void davinci_enc_set_ntsc_pal_rgb(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+
+	osd_write_left_margin(mode_info->left_margin);
+	osd_write_upper_margin(mode_info->upper_margin);
+}
+
+/*
+ * davinci_enc_set_525p
+ */
+/* This function configures the video encoder to HDTV(525p) component setting.*/
+static void davinci_enc_set_525p(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+	if (cpu_is_davinci_dm365())
+		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
+	else
+		__raw_writel(0x19, IO_ADDRESS(SYS_VPSS_CLKCTL));
+
+	osd_write_left_margin(mode_info->left_margin);
+	osd_write_upper_margin(mode_info->upper_margin);
+
+	if (cpu_is_davinci_dm365()) {
+/* TODO */
+#if 0
+		tvp73xx_setup_channel(THS7303, THS_FILTER_MODE_480P);
+		msleep(40);
+#endif
+		__raw_writel(0x081141EF, DM3XX_VDAC_CONFIG);
+	}
+
+	if (cpu_is_davinci_dm644x())
+		__raw_writel(VPBE_PCR_VENC_DIV,
+			       IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	if (cpu_is_davinci_dm644x()) {
+		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
+		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
+	}
+
+	dispc_reg_merge(VENC_VMOD,
+			VENC_VMOD_VDMD_YCBCR8 <<
+			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
+
+	/* Set REC656 Mode */
+	dispc_reg_out(VENC_YCCCTL, 0x1);
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ *  davinci_enc_set_625p
+ */
+/* This function configures the video encoder to HDTV(625p) component setting.*/
+static void davinci_enc_set_625p(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+	if (cpu_is_davinci_dm365())
+		__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
+	else
+		__raw_writel(0x19, IO_ADDRESS(SYS_VPSS_CLKCTL));
+
+	osd_write_left_margin(mode_info->left_margin);
+	osd_write_upper_margin(mode_info->upper_margin);
+
+	if (cpu_is_davinci_dm365()) {
+/* TODO */
+#if 0
+		tvp73xx_setup_channel(THS7303, THS_FILTER_MODE_576P);
+		msleep(40);
+#endif
+		__raw_writel(0x081141EF, IO_ADDRESS(DM3XX_VDAC_CONFIG));
+	}
+
+	if (cpu_is_davinci_dm644x())
+		__raw_writel(VPBE_PCR_VENC_DIV,
+			       IO_ADDRESS(DM644X_VPBE_REG_BASE + VPBE_PCR));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+
+	if (cpu_is_davinci_dm644x()) {
+		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
+		dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
+	}
+
+	dispc_reg_merge(VENC_VMOD,
+			VENC_VMOD_VDMD_YCBCR8 <<
+			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
+
+	/* Set REC656 Mode */
+	dispc_reg_out(VENC_YCCCTL, 0x1);
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ * davinci_enc_set_display_timing
+ */
+/* This function sets the display timing from the fb_info structure*/
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
+{
+	dispc_reg_out(VENC_HSPLS, mode->hsync_len);
+	dispc_reg_out(VENC_HSTART, mode->left_margin);
+	dispc_reg_out(VENC_HVALID, mode->xres);
+	dispc_reg_out(VENC_HINT,
+		      mode->xres + mode->left_margin + mode->right_margin - 1);
+
+	dispc_reg_out(VENC_VSPLS, mode->vsync_len);
+	dispc_reg_out(VENC_VSTART, mode->upper_margin);
+	dispc_reg_out(VENC_VVALID, mode->yres);
+	dispc_reg_out(VENC_VINT,
+		      mode->yres + mode->upper_margin + mode->lower_margin);
+};
+
+EXPORT_SYMBOL(davinci_enc_set_display_timing);
+
+/*
+ * davinci_enc_set_dclk_pattern
+ */
+/* This function sets the DCLK output mode and pattern using
+   DCLKPTN registers */
+void davinci_enc_set_dclk_pattern
+    (unsigned long enable, unsigned long long pattern) {
+	if (enable > 1)
+		enable = 1;
+
+	dispc_reg_out(VENC_DCLKPTN0, pattern & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN1, (pattern >> 16) & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN2, (pattern >> 32) & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN3, (pattern >> 48) & 0xFFFF);
+
+	/* The pattern is to enable DCLK or
+	   to determine its level */
+	dispc_reg_merge(VENC_DCLKCTL,
+			enable << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
+};
+EXPORT_SYMBOL(davinci_enc_set_dclk_pattern);
+
+/*
+ * davinci_enc_set_dclk_aux_pattern
+ */
+/* This function sets the auxiliary DCLK output pattern using
+   DCLKPTNnA registers */
+void davinci_enc_set_dclk_aux_pattern(unsigned long long pattern)
+{
+	dispc_reg_out(VENC_DCLKPTN0A, pattern & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN1A, (pattern >> 16) & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN2A, (pattern >> 32) & 0xFFFF);
+	dispc_reg_out(VENC_DCLKPTN3A, (pattern >> 48) & 0xFFFF);
+};
+EXPORT_SYMBOL(davinci_enc_set_dclk_aux_pattern);
+
+/*
+ * davinci_enc_set_dclk_pw
+ */
+/* This function sets the DCLK output pattern width using
+   DCLKCTL register, PCKPW is [0, 63] that makes real width [1, 64] */
+void davinci_enc_set_dclk_pw(unsigned long width)
+{
+	if (width > 0x3F)
+		width = 0;
+
+	dispc_reg_merge(VENC_DCLKCTL, width, VENC_DCLKCTL_DCKPW);
+};
+EXPORT_SYMBOL(davinci_enc_set_dclk_pw);
+
+/*
+ * setting DLCD 480P PRGB mode
+ */
+static void davinci_enc_set_prgb(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, 0x141);
+	/* set VPSS clock */
+	__raw_writel(0x18, IO_ADDRESS(SYS_VPSS_CLKCTL));
+
+	dispc_reg_out(VENC_DCLKCTL, 0);
+	dispc_reg_out(VENC_DCLKPTN0, 0);
+
+	/* Set the OSD Divisor to 1. */
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	/* Clear composite mode register */
+	dispc_reg_out(VENC_CVBS, 0);
+
+	/* Set PINMUX1 to enable all outputs needed to support RGB666 */
+	if (cpu_is_davinci_dm355()) {
+		/* Enable the venc and dlcd clocks. */
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else if (cpu_is_davinci_dm365()) {
+		/* DM365 pinmux */
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_cfg_reg(DM365_VOUT_FIELD_G81);
+		davinci_cfg_reg(DM365_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM365_VOUT_COUTH_EN);
+	} else {
+		dispc_reg_out(VENC_CMPNT, 0x100);
+		davinci_cfg_reg(DM644X_GPIO46_47);
+		davinci_cfg_reg(DM644X_GPIO0);
+		davinci_cfg_reg(DM644X_RGB666);
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	osd_write_left_margin(mode_info->left_margin);
+	osd_write_upper_margin(mode_info->upper_margin);
+
+	/* Set VIDCTL to select VCLKE = 1,
+	   VCLKZ =0, SYDIR = 0 (set o/p), DOMD = 0 */
+	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
+			VENC_VIDCTL_VCLKE);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
+			VENC_VIDCTL_VCLKZ);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
+			VENC_VIDCTL_SYDIR);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
+			VENC_VIDCTL_YCDIR);
+
+	dispc_reg_merge(VENC_DCLKCTL,
+			1 << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
+
+	dispc_reg_out(VENC_DCLKPTN0, 0x1);
+
+	davinci_enc_set_display_timing(mode_info);
+	dispc_reg_out(VENC_SYNCCTL,
+		      (VENC_SYNCCTL_SYEV |
+		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
+		       | VENC_SYNCCTL_VPL));
+
+	/* Configure VMOD. No change in VENC bit */
+	dispc_reg_out(VENC_VMOD, 0x2011);
+	dispc_reg_out(VENC_LCDOUT, 0x1);
+
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_720p(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	__raw_writel(0xa, IO_ADDRESS(SYS_VPSS_CLKCTL));
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+
+		osd_write_left_margin(mode_info->left_margin);
+		osd_write_upper_margin(mode_info->upper_margin);
+
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		osd_write_left_margin(mode_info->left_margin);
+		osd_write_upper_margin(mode_info->upper_margin);
+
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	dispc_reg_out(VENC_HSDLY, 0);
+	dispc_reg_out(VENC_VSDLY, 0);
+	dispc_reg_out(VENC_YCCCTL, 0);
+	dispc_reg_out(VENC_VSTARTA, 0);
+
+	/* Enable all VENC, non-standard timing mode, master timing, HD,
+	   progressive
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VENC | VENC_VMOD_VMD));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_HDMD));
+	}
+	dispc_reg_out(VENC_LCDOUT, 1);
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_1080i(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	dispc_reg_out(VENC_HSDLY, 0);
+	dispc_reg_out(VENC_VSDLY, 0);
+	dispc_reg_out(VENC_YCCCTL, 0);
+	dispc_reg_out(VENC_VSTARTA, 13);
+
+	__raw_writel(0xa, IO_ADDRESS(SYS_VPSS_CLKCTL));
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+
+		osd_write_left_margin(mode_info->left_margin);
+		osd_write_upper_margin(mode_info->upper_margin);
+	
+		davinci_cfg_reg(DM355_VOUT_FIELD);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		osd_write_left_margin(mode_info->left_margin);
+		osd_write_upper_margin(mode_info->upper_margin);
+
+		davinci_cfg_reg(DM644X_LFLDEN);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	/* Enable all VENC, non-standard timing mode, master timing,
+	   HD, interlaced
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_NSIT));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD | VENC_VMOD_HDMD |
+			       VENC_VMOD_NSIT));
+	}
+	dispc_reg_out(VENC_LCDOUT, 1);
+}
+
+/* TODO */
+#if 0
+static void davinci_enc_set_internal_hd(struct vid_enc_mode_info *mode_info)
+{
+	/* set sysclk4 to output 74.25 MHz from pll1 */
+	__raw_writel(0x38, SYS_VPSS_CLKCTL);
+
+	tvp73xx_setup_channel(THS7303, THS_FILTER_MODE_720P);
+	msleep(50);
+	__raw_writel(0x081141EF, DM3XX_VDAC_CONFIG);
+	return;
+}
+#endif
+
+void davinci_enc_priv_setmode(struct vid_enc_device_mgr *mgr)
+{
+
+	switch (mgr->current_mode.if_type) {
+	case VID_ENC_IF_BT656:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		dispc_reg_merge(VENC_YCCCTL, 1, 1);
+		break;
+	case VID_ENC_IF_BT1120:
+		break;
+	case VID_ENC_IF_YCC8:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_YCC16:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR16 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_SRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_PRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB666 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	default:
+		break;
+	}
+
+	if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC) == 0) {
+		davinci_enc_set_ntsc(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC_RGB) == 0) {
+		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL) == 0) {
+		davinci_enc_set_pal(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL_RGB) == 0) {
+		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_480P_60) == 0) {
+		davinci_enc_set_525p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_576P_50) == 0) {
+		davinci_enc_set_625p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_640x480) == 0 ||
+		strcmp(mgr->current_mode.name, VID_ENC_STD_640x400) == 0 ||
+		strcmp(mgr->current_mode.name, VID_ENC_STD_640x350) == 0 ||
+		strcmp(mgr->current_mode.name, VID_ENC_STD_800x480) == 0) {
+		davinci_enc_set_prgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_720P_60) == 0) {
+		/* DM365 has built-in HD DAC; otherwise, they depend on
+		 * THS8200
+		 */
+/* TODO */
+#if 0
+		if (cpu_is_davinci_dm365()) {
+			davinci_enc_set_internal_hd(&mgr->current_mode);
+			/* changed for 720P demo */
+			davinci_enc_set_basep(0, 0xf0, 10);
+		} else
+#endif
+			davinci_enc_set_720p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0) {
+/* TODO */
+#if 0
+		if (cpu_is_davinci_dm365()) {
+			davinci_enc_set_internal_hd(&mgr->current_mode);
+			davinci_enc_set_basep(0, 0xd0, 10);
+		} else
+#endif
+			davinci_enc_set_1080i(&mgr->current_mode);
+	}
+
+/* TODO */
+#if 0
+	/* turn off ping-pong buffer and field inversion to fix
+	 * the image shaking problem in 1080I mode. The problem i.d. by the
+	 * DM6446 Advisory 1.3.8 is not seen in 1080I mode, but the ping-pong
+	 * buffer workaround created a shaking problem.
+	 */
+	if ((cpu_is_davinci_dm644x_pg1x() || cpu_is_davinci_dm357()) &&
+		strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0)
+		davinci_disp_set_field_inversion(0);
+#endif
+
+	return;
+}
+
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
+{
+
+	if (0 == mgr->current_mode.std) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		return;
+	}
+	davinci_enc_priv_setmode(mgr);
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode_platform);
+
+int davinci_disp_is_second_field(void)
+{
+	return ((__raw_readl(venc->venc_base + VENC_VSTAT) & VENC_VSTAT_FIDST)
+		== VENC_VSTAT_FIDST);
+}
+EXPORT_SYMBOL(davinci_disp_is_second_field);
+
+static int davinci_venc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	venc->vdev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(venc->vdev, "Unable to get VENC register address map\n");
+		return -ENODEV;
+	}
+	venc->venc_base_phys = res->start;
+	venc->venc_size = res->end - res->start + 1;
+	if (!request_mem_region(venc->venc_base_phys, venc->venc_size,
+				"davinci_venc")) {
+		dev_err(venc->vdev, "Unable to reserve VENC MMIO region\n");
+		return -ENODEV;
+	}
+	venc->venc_base = (unsigned long)ioremap_nocache(res->start,
+							venc->venc_size);
+	if (!venc->venc_base) {
+		dev_err(venc->vdev, "Unable to map VENC MMIO\n");
+		goto release_venc;
+	}
+
+	return 0;
+
+release_venc:
+	release_mem_region(venc->venc_base_phys, venc->venc_size);
+
+	return -ENODEV;
+}
+
+static int davinci_venc_remove(struct platform_device *pdev)
+{
+	if (venc->venc_base)
+		iounmap((void *)venc->venc_base);
+	release_mem_region(venc->venc_base_phys, venc->venc_size);
+	
+	return 0;
+}
+
+static struct platform_driver davinci_venc_driver = {
+	.probe		= davinci_venc_probe,
+	.remove		= davinci_venc_remove,
+	.driver		= {
+		.name	= "davinci_venc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int davinci_platform_init(void)
+{
+/* Sandeep */
+	display_cntl_base = ioremap(DM644X_DDR2_CNTL_BASE, 0x24);
+	if (!display_cntl_base) {
+		printk(KERN_ERR "Could not remap control registers\n");
+		return -EINVAL;
+	}
+	class_register(&davinci_system_class);
+
+	davinci_system_device = create_sysfs_files();
+	if (!davinci_system_device) {
+		printk(KERN_ERR "Could not create davinci system sysfs\n");
+		iounmap(display_cntl_base);
+		return -EINVAL;
+	}
+
+	/* Register the driver */
+	if (platform_driver_register(&davinci_venc_driver)) {
+		printk(KERN_ERR "Unable to register davinci platform driver\n");
+		return -ENODEV;
+	}
+
+	
+	return 0;
+}
+
+static void davinci_platform_exit(void)
+{
+/* Sandeep */
+	remove_sysfs_files(davinci_system_device);
+	class_unregister(&davinci_system_class);
+	iounmap(display_cntl_base);
+
+	platform_driver_unregister(&davinci_venc_driver);
+
+	return;
+}
+
+subsys_initcall(davinci_platform_init);
+module_exit(davinci_platform_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DaVinci Platform Driver");
+MODULE_AUTHOR("Texas Instruments");
diff --git a/drivers/media/video/davinci/logicpd_encoder.c b/drivers/media/video/davinci/logicpd_encoder.c
new file mode 100644
index 0000000..104b3d1
--- /dev/null
+++ b/drivers/media/video/davinci/logicpd_encoder.c
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* logicpd_encoder.c. This is just a place holder for hardcoding all supported
+   modes timing. LogicPD timing signals are programmed by the encoder manager
+   based on this data.
+ */
+
+/* Kernel Specific header files */
+
+#include <linux/kernel.h>
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/logicpd_encoder.h>
+
+/* Function prototypes */
+static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag);
+static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc);
+
+static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc);
+static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc);
+
+static int logicpd_encoder_setoutput(char *output,
+				     struct vid_encoder_device *enc);
+static int logicpd_encoder_getoutput(char *output,
+				     struct vid_encoder_device *enc);
+
+static int logicpd_encoder_enumoutput(int index,
+				      char *output,
+				      struct vid_encoder_device *enc);
+
+static struct logicpd_encoder_config logicpd_encoder_configuration = {
+	.no_of_outputs = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_LCD,
+		      .no_of_standard = LOGICPD_ENCODER_GRAPHICS_NUM_STD,
+		      .standards[0] = {
+				       .name = VID_ENC_STD_640x480,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 480,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 32,
+				       .lower_margin = 11,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 0},	/* hsync -ve, vsync -ve */
+		      .standards[1] = {
+				       .name = VID_ENC_STD_640x400,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 400,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 72,
+				       .lower_margin = 51,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 2},	/* hsync -ve, vsync +ve */
+		      .standards[2] = {
+				       .name = VID_ENC_STD_640x350,
+				       .std = 1,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 640,
+				       .yres = 350,
+				       .fps = {60, 1},
+				       .left_margin = 85,
+				       .right_margin = 70,
+				       .upper_margin = 97,
+				       .lower_margin = 76,
+				       .hsync_len = 9,
+				       .vsync_len = 9,
+				       .flags = 1},	/* hsync +ve, vsync -ve */
+		      .standards[3] = {	/* This is programmed by the user application. We just save
+					   the received timing information */
+				       .name = VID_ENC_STD_NON_STANDARD,
+				       .std = 0,
+				       .if_type = VID_ENC_IF_PRGB,
+				       .interlaced = 0,
+				       .xres = 0,
+				       .yres = 0,
+				       .fps = {0, 0},
+				       .left_margin = 0,
+				       .right_margin = 0,
+				       .upper_margin = 0,
+				       .lower_margin = 0,
+				       .hsync_len = 0,
+				       .vsync_len = 0,
+				       .flags = 0},
+		      },
+};
+
+static struct logicpd_encoder_channel logicpd_encoder_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_640x480,
+	.enc_device = NULL
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = LOGICPD_ENCODER_MAX_NO_OUTPUTS,
+	.enumoutput = logicpd_encoder_enumoutput,
+	.setoutput = logicpd_encoder_setoutput,
+	.getoutput = logicpd_encoder_getoutput
+};
+
+static struct vid_enc_mode_ops modes_ops = {
+	.setmode = logicpd_encoder_setmode,
+	.getmode = logicpd_encoder_getmode,
+};
+
+static struct vid_encoder_device logicpd_encoder_dev = {
+	.name = "LOGICPD_ENCODER",
+	.capabilities = 0,
+	.initialize = logicpd_encoder_initialize,
+	.mode_ops = &modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = NULL,
+	.deinitialize = logicpd_encoder_deinitialize,
+};
+
+/* This function is called by the encoder manager to initialize logicpd encoder driver.
+ */
+static int logicpd_encoder_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0, outindex;
+	char *std, *output;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.enc_device = (struct encoder_device *)enc;
+
+	/* call set standard */
+	std = logicpd_encoder_channel_info.params.mode;
+	outindex = logicpd_encoder_channel_info.params.outindex;
+	output = logicpd_encoder_configuration.output[outindex].output_name;
+	err |= logicpd_encoder_setoutput(output, enc);
+	if (err < 0) {
+		err = -EINVAL;
+		printk(KERN_ERR "Error occured in setoutput\n");
+		logicpd_encoder_deinitialize(enc);
+		return err;
+	}
+	printk(KERN_DEBUG "LogicPD Encoder initialized\n");
+	return err;
+}
+
+/* Function to de-initialize the encoder */
+static int logicpd_encoder_deinitialize(struct vid_encoder_device *enc)
+{
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.enc_device = NULL;
+	printk(KERN_DEBUG "LogicPD Encoder de-initialized\n");
+	return 0;
+}
+
+/* Following function is used to set the mode*/
+static int logicpd_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i;
+	char *mode;
+	struct vid_enc_mode_info *my_mode_info = NULL;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (NULL == (mode = mode_info->name)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "Start of logicpd_encoder_setmode..\n");
+	outindex = logicpd_encoder_channel_info.params.outindex;
+
+	if (mode_info->std) {
+		char *mymode = NULL;
+		/* This is a standard mode */
+		for (i = 0;
+		     i <
+		     logicpd_encoder_configuration.output[outindex].
+		     no_of_standard; i++) {
+			if (!strcmp
+			    (logicpd_encoder_configuration.output[outindex].
+			     standards[i].name, mode)) {
+				mymode =
+				    logicpd_encoder_configuration.
+				    output[outindex].standards[i].name;
+				break;
+			}
+		}
+		if ((i ==
+		     logicpd_encoder_configuration.output[outindex].
+		     no_of_standard) || (NULL == mymode)) {
+			printk(KERN_ERR "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of logicpd_encoder */
+		logicpd_encoder_channel_info.params.mode = mymode;
+		return 0;
+	} else {
+		/* Non- Standard mode. Check if we support it. If so
+		   save the timing info and return */
+		for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
+			if (!strcmp
+			    (logicpd_encoder_configuration.output[outindex].
+			     standards[i].name, VID_ENC_STD_NON_STANDARD)) {
+				my_mode_info =
+				    &logicpd_encoder_configuration.
+				    output[outindex].standards[i];
+				break;
+			}
+		}
+		if (my_mode_info) {
+			/* We support. So save timing info and return success
+			   interface type is same as what is currently is active
+			 */
+			my_mode_info->interlaced = mode_info->interlaced;
+			my_mode_info->xres = mode_info->xres;
+			my_mode_info->yres = mode_info->yres;
+			my_mode_info->fps = mode_info->fps;
+			my_mode_info->left_margin = mode_info->left_margin;
+			my_mode_info->right_margin = mode_info->right_margin;
+			my_mode_info->upper_margin = mode_info->upper_margin;
+			my_mode_info->lower_margin = mode_info->lower_margin;
+			my_mode_info->hsync_len = mode_info->hsync_len;
+			my_mode_info->vsync_len = mode_info->vsync_len;
+			my_mode_info->flags = mode_info->flags;
+			/* If we need to configure something in the encoder module, we need to
+			   do this here */
+			return 0;
+		}
+		printk(KERN_ERR "Mode not supported..\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_setmode>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected mode.*/
+static int logicpd_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0, i, outindex;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<logicpd_encoder_getmode>\n");
+	outindex = logicpd_encoder_channel_info.params.outindex;
+	for (i = 0; i < LOGICPD_ENCODER_GRAPHICS_NUM_STD; i++) {
+		if (!strcmp(logicpd_encoder_channel_info.params.mode,
+			    logicpd_encoder_configuration.output[outindex].
+			    standards[i].name)) {
+			memcpy(mode_info,
+			       &logicpd_encoder_configuration.output[outindex].
+			       standards[i], sizeof(struct vid_enc_mode_info));
+			break;
+		}
+	}
+	if (i == LOGICPD_ENCODER_GRAPHICS_NUM_STD) {
+		printk(KERN_ERR "Wiered. No mode info\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_getmode>\n");
+	return err;
+}
+
+/* For LogicPD, we have only one output, called LCD, we
+   always set this to this at init
+*/
+static int logicpd_encoder_setoutput(char *output,
+				     struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	printk(KERN_DEBUG "<logicpd_encoder_setoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output: NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Just check if the default output match with this output name */
+	if (strcmp(logicpd_encoder_configuration.output[0].output_name, output)) {
+		printk(KERN_ERR "no matching output found.\n");
+		return -EINVAL;
+	}
+	logicpd_encoder_channel_info.params.mode
+	    = logicpd_encoder_configuration.output[0].standards[0].name;
+
+	my_mode_info = &logicpd_encoder_configuration.output[0].standards[0];
+	err |= logicpd_encoder_setmode(my_mode_info, enc);
+	if (err < 0) {
+		printk(KERN_ERR "Error in setting default mode\n");
+		return err;
+	}
+	printk(KERN_DEBUG "</logicpd_encoder_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get output name of current output.*/
+static int logicpd_encoder_getoutput(char *output,
+				     struct vid_encoder_device *enc)
+{
+	int err = 0, index, len;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<logicpd_encoder_getoutput>\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = logicpd_encoder_channel_info.params.outindex;
+	len = strlen(logicpd_encoder_configuration.output[index].output_name);
+	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
+		len = VID_ENC_NAME_MAX_CHARS - 1;
+	strncpy(output, logicpd_encoder_configuration.output[index].output_name,
+		len);
+	output[len] = '\0';
+	printk(KERN_DEBUG "</logicpd_encoder_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information in the output. */
+static int logicpd_encoder_enumoutput(int index, char *output,
+				      struct vid_encoder_device *enc)
+{
+	int err = 0;
+
+	printk(KERN_DEBUG "<logicpd_encoder_enumoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= logicpd_encoder_configuration.no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		logicpd_encoder_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	printk(KERN_DEBUG "</logicpd_encoder_enumoutput>\n");
+	return err;
+}
+
+/* This function used to initialize the LogicPD encoder driver */
+static int logicpd_encoder_init(void)
+{
+	int err = 0;
+
+	err = vid_enc_register_encoder(&logicpd_encoder_dev);
+	printk(KERN_NOTICE "LogicPD encoder initialized\n");
+	return err;
+}
+
+/* Function used to cleanup LogicPD encoder driver */
+static void logicpd_encoder_cleanup(void)
+{
+	vid_enc_unregister_encoder(&logicpd_encoder_dev);
+}
+
+subsys_initcall_sync(logicpd_encoder_init);
+module_exit(logicpd_encoder_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/davinci/vpbe_encoder.c b/drivers/media/video/davinci/vpbe_encoder.c
new file mode 100644
index 0000000..38316bb
--- /dev/null
+++ b/drivers/media/video/davinci/vpbe_encoder.c
@@ -0,0 +1,886 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpbe_encoder.c.. For internal encoder of the VPBE */
+
+/* Kernel Specific header files */
+
+#include <linux/kernel.h>
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/vpbe_encoder.h>
+#include <media/davinci/davinci_platform.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/cpu.h>
+
+#include <asm/io.h>
+
+struct vpbe_encoder_params {
+	int outindex;
+	char *mode;
+};
+
+struct vpbe_encoder_config {
+//	unsigned long vencregs;
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		char *standards[VPBE_ENCODER_MAX_NUM_STD];
+	} output[VPBE_ENCODER_MAX_NO_OUTPUTS];
+};
+
+struct vpbe_encoder_channel {
+	struct encoder_device *enc_device;
+	struct vpbe_encoder_params params;
+};
+
+/* Function prototypes */
+static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag);
+static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc);
+
+static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc);
+static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc);
+
+static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc);
+static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc);
+
+static int vpbe_encoder_enumoutput(int index,
+				   char *output,
+				   struct vid_encoder_device *enc);
+
+static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc);
+
+/* All Supported encoder modes */
+static struct vid_enc_mode_info vpbe_encoder_modes[VPBE_ENCODER_MAX_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0x79,
+	 .right_margin = 0,
+	 .upper_margin = 0x10,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0x7E,
+	 .right_margin = 0,
+	 .upper_margin = 0x16,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_NTSC_RGB,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x12,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL_RGB,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0x88,
+	 .right_margin = 0,
+	 .upper_margin = 0x18,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_480P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {60, 1},
+	 .left_margin = 0x80,
+	 .right_margin = 0,
+	 .upper_margin = 0x20,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_576P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {50, 1},
+	 .left_margin = 0x7E,
+	 .right_margin = 0,
+	 .upper_margin = 0x30,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {60, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {50, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {30, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {25, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_24,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {24, 1},
+	 .left_margin = 300,
+	 .right_margin = 70,
+	 .upper_margin = 26,
+	 .lower_margin = 3,
+	 .hsync_len = 80,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30, 1},
+	 .left_margin = 200,
+	 .right_margin = 80,
+	 .upper_margin = 13,
+	 .lower_margin = 31,
+	 .hsync_len = 88,
+	 .vsync_len = 5,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_INT,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {25, 1},
+	 .left_margin = 200,
+	 .right_margin = 80,
+	 .upper_margin = 13,
+	 .lower_margin = 31,
+	 .hsync_len = 88,
+	 .vsync_len = 5,
+	 .flags = 0},
+};
+
+static struct vpbe_encoder_config vpbe_encoder_configuration = {
+//	.vencregs = DM644X_VENC_REG_BASE,
+	.no_of_outputs = VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS,
+	.output[0] = {
+		      .output_name = VID_ENC_OUTPUT_COMPOSITE,
+		      .no_of_standard = VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
+		      },
+	.output[1] = {
+		      .output_name = VID_ENC_OUTPUT_SVIDEO,
+		      .no_of_standard = VPBE_DM644X_ENCODER_SVIDEO_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC, VID_ENC_STD_PAL},
+		      },
+	.output[2] = {
+		      .output_name = VID_ENC_OUTPUT_COMPONENT,
+		      .no_of_standard = VPBE_DM644X_ENCODER_COMPONENT_NUM_STD,
+		      .standards = {VID_ENC_STD_NTSC,
+				    VID_ENC_STD_PAL,
+				    VID_ENC_STD_NTSC_RGB,
+				    VID_ENC_STD_PAL_RGB,
+				    VID_ENC_STD_480P_60,
+				    VID_ENC_STD_576P_50},
+		      }
+};
+
+static struct vpbe_encoder_channel vpbe_encoder_channel_info = {
+	.params.outindex = 0,
+	.params.mode = VID_ENC_STD_NTSC,
+	.enc_device = NULL
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = VPBE_ENCODER_MAX_NO_OUTPUTS,
+	.enumoutput = vpbe_encoder_enumoutput,
+	.setoutput = vpbe_encoder_setoutput,
+	.getoutput = vpbe_encoder_getoutput
+};
+
+static struct vid_enc_mode_ops modes_ops = {
+	.setmode = vpbe_encoder_setmode,
+	.getmode = vpbe_encoder_getmode,
+};
+
+static struct vid_enc_misc_ops miscs_ops = {
+	.reset = NULL,
+	.enable = vpbe_encoder_enable,
+};
+
+static struct vid_encoder_device vpbe_encoder_dev = {
+	.name = "VPBE_ENCODER",
+	.capabilities = 0,
+	.initialize = vpbe_encoder_initialize,
+	.mode_ops = &modes_ops,
+	.ctrl_ops = NULL,
+	.output_ops = &outputs_ops,
+	.params_ops = NULL,
+	.misc_ops = &miscs_ops,
+	.deinitialize = vpbe_encoder_deinitialize,
+};
+
+/*
+ * display controller register I/O routines
+ */
+#if 0
+static __inline__ u32 venc_reg_in(u32 offset)
+{
+	u32 addr;
+	addr = vpbe_encoder_configuration.vencregs + offset;
+	return (__raw_readl(IO_ADDRESS(addr)));
+}
+static __inline__ u32 venc_reg_out(u32 offset, u32 val)
+{
+	u32 addr = vpbe_encoder_configuration.vencregs + offset;
+	__raw_writel(val, IO_ADDRESS(addr));
+	return (val);
+}
+static __inline__ u32 venc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+	addr = vpbe_encoder_configuration.vencregs + offset;
+	new_val = (__raw_readl(IO_ADDRESS(addr)) & ~mask) | (val & mask);
+	__raw_writel(new_val, IO_ADDRESS(addr));
+	return (new_val);
+}
+#endif
+
+/* Function to enable/disable output */
+static int vpbe_encoder_enable(int flag, struct vid_encoder_device *enc)
+{
+	if (flag)
+		venc_reg_out(VENC_DACTST, 0);
+	else
+		venc_reg_out(VENC_DACTST, 0xF000);
+	return 0;
+}
+
+/* This function sets the dac of the VPBE for various outputs
+ */
+static int vpbe_encoder_set_dac(char *output)
+{
+	int error = 0;
+
+	if (cpu_is_davinci_dm644x() || cpu_is_davinci_dm365()) {
+		if (!strcmp(output, VID_ENC_OUTPUT_COMPOSITE)) {
+			printk(KERN_DEBUG "Setting output to Composite\n");
+			venc_reg_out(VENC_DACSEL, 0);
+		} else if (!strcmp(output, VID_ENC_OUTPUT_SVIDEO)) {
+			printk(KERN_DEBUG "Setting output to S-Video\n");
+			venc_reg_out(VENC_DACSEL, 0x210);
+		} else if (!strcmp(output, VID_ENC_OUTPUT_COMPONENT)) {
+			printk(KERN_DEBUG
+			       "Setting output to Component Video\n");
+			venc_reg_out(VENC_DACSEL, 0x543);
+		} else
+			error = -1;
+	} else if (!cpu_is_davinci_dm355())
+		error = -1;
+	return error;
+}
+
+/* This function is called by the encoder manager to initialize vpbe encoder driver.
+ * It initializes all registers of vpbe_encoder with the default values
+ */
+static int vpbe_encoder_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0, outindex;
+	char *std, *output;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	vpbe_encoder_channel_info.enc_device = (struct encoder_device *)enc;
+
+	/* call set standard */
+	std = vpbe_encoder_channel_info.params.mode;
+	outindex = vpbe_encoder_channel_info.params.outindex;
+	output = vpbe_encoder_configuration.output[outindex].output_name;
+	err |= vpbe_encoder_setoutput(output, enc);
+	if (err < 0) {
+		err = -EINVAL;
+		printk(KERN_ERR "Error occured in setoutput\n");
+		vpbe_encoder_deinitialize(enc);
+		return err;
+	}
+	printk(KERN_DEBUG "VPBE Encoder initialized\n");
+	return err;
+}
+
+static int vpbe_encoder_deinitialize(struct vid_encoder_device *enc)
+{
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if (cpu_is_davinci_dm644x() || cpu_is_davinci_dm365())
+		venc_reg_out(VENC_DACSEL, 0);
+
+	/* disable output */
+	venc_reg_out(VENC_DACTST, 0xF000);
+	venc_reg_out(VENC_VMOD, 0);
+
+	vpbe_encoder_channel_info.enc_device = NULL;
+	printk(KERN_DEBUG "VPBE Encoder de-initialized\n");
+	return 0;
+}
+
+/* Following function returns ptr to a mode_info structure*/
+static struct vid_enc_mode_info *get_modeinfo(char *mode_name)
+{
+	int i;
+	for (i = 0; i < VPBE_ENCODER_MAX_NUM_STD; i++) {
+		if (!strcmp(vpbe_encoder_modes[i].name, mode_name)) {
+			return &vpbe_encoder_modes[i];
+		}
+	}
+	return NULL;
+}
+
+/* Following function is used to set the mode*/
+static int vpbe_encoder_setmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc)
+{
+	int err = 0, outindex, i, dm6446 = 0, dm355 = 0, dm365 = 0;
+	char *mode;
+	struct vid_enc_mode_info *my_mode_info;
+
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (NULL == (mode = mode_info->name)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "Start of vpbe_encoder_setmode..\n");
+	outindex = vpbe_encoder_channel_info.params.outindex;
+	if (cpu_is_davinci_dm644x())
+		dm6446 = 1;
+	else if (cpu_is_davinci_dm355())
+		dm355 = 1;
+	else if (cpu_is_davinci_dm365())
+		dm365 = 1;
+	else
+		return -EINVAL;
+
+	if (mode_info->std) {
+		char *mymode = NULL;
+		/* This is a standard mode */
+		for (i = 0;
+		     i <
+		     vpbe_encoder_configuration.output[outindex].no_of_standard;
+		     i++) {
+			if (!strcmp
+			    (vpbe_encoder_configuration.output[outindex].
+			     standards[i], mode)) {
+				mymode =
+				    vpbe_encoder_configuration.output[outindex].
+				    standards[i];
+				break;
+			}
+		}
+		if ((i ==
+		     vpbe_encoder_configuration.output[outindex].no_of_standard)
+		    || (NULL == mymode)) {
+			printk(KERN_ERR "Invalid id...\n");
+			return -EINVAL;
+		}
+		/* Store the standard in global object of vpbe_encoder */
+		vpbe_encoder_channel_info.params.mode = mymode;
+		if (!strcmp(mymode, VID_ENC_STD_NTSC)) {
+			/* Setup NTSC */
+			venc_reg_out(VENC_VMOD, 0);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+		} else if (!strcmp(mymode, VID_ENC_STD_PAL)) {
+			/* Setup PAL */
+			venc_reg_out(VENC_VMOD, 0);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+		} else if (!strcmp(mymode, VID_ENC_STD_NTSC_RGB) &&
+			   (dm6446 || dm365)) {
+			/* Setup for NTSC RGB */
+			venc_reg_out(VENC_VMOD, 0);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+			venc_reg_merge(VENC_CMPNT,
+					(1 << VENC_CMPNT_MRGB_SHIFT),
+					VENC_CMPNT_MRGB);
+		} else if (!strcmp(mymode, VID_ENC_STD_PAL_RGB) &&
+			   (dm6446 || dm365)) {
+			/* Setup for PAL RGB */
+			venc_reg_out(VENC_VMOD, 0);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+			venc_reg_merge(VENC_CMPNT,
+					(1 << VENC_CMPNT_MRGB_SHIFT),
+					VENC_CMPNT_MRGB);
+		} else if (!strcmp(mymode, VID_ENC_STD_480P_60) &&
+			   (dm6446 || dm365)) {
+			/* Setup for 480P, Progressive NTSC */
+			venc_reg_out(VENC_VMOD, 0);
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			venc_reg_merge(VENC_VMOD,
+					(HDTV_525P << VENC_VMOD_TVTYP_SHIFT),
+					VENC_VMOD_TVTYP);
+
+		} else if (!strcmp(mymode, VID_ENC_STD_576P_50) &&
+			   (dm6446 || dm365)) {
+			venc_reg_out(VENC_VMOD, 0);
+			/* Setup for 576P, Progressive PAL */
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			venc_reg_merge
+			    (VENC_VMOD,
+			     (HDTV_625P << VENC_VMOD_TVTYP_SHIFT),
+			     VENC_VMOD_TVTYP);
+		} else if (!strncmp(mymode, VID_ENC_STD_720P_60, 5) && dm365) {
+			char buf[16];
+			unsigned long xh, val;
+			strcpy(buf, mymode + 5);
+			venc_reg_out(VENC_VMOD, 0);
+			/* DM365 component HD mode */
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			venc_reg_merge
+			    (VENC_VMOD,
+			     (HDTV_720P << VENC_VMOD_TVTYP_SHIFT),
+			     VENC_VMOD_TVTYP);
+			venc_reg_merge
+			    (VENC_VMOD,
+			     VENC_VMOD_VENC,
+			     VENC_VMOD_VENC);
+			/* DM365 VENC spec, Table 16 */
+			if (strict_strtoul(buf, 10, &val) != 0)
+				val = 60;
+			switch (val) {
+			case 60:
+			default:
+				xh = 0;
+				break;
+			case 50:
+				xh = 330;
+				break;
+			case 30:
+				xh = 1650;
+				break;
+			case 25:
+				xh = 2310;
+				break;
+			case 24:
+				xh = 2475;
+				break;
+			}
+			venc_reg_out(VENC_XHINTVL, xh);
+		} else if (!strncmp(mymode, VID_ENC_STD_1080I_30, 6) && dm365) {
+			char buf[16];
+			unsigned long xh, val;
+			strcpy(buf, mymode + 6);
+			venc_reg_out(VENC_VMOD, 0);
+			/* DM365 component HD mode */
+			venc_reg_merge(VENC_VMOD,
+					(1 << VENC_VMOD_VIE_SHIFT),
+					VENC_VMOD_VIE);
+			venc_reg_merge(VENC_VMOD,
+					VENC_VMOD_HDMD, VENC_VMOD_HDMD);
+			venc_reg_merge
+			    (VENC_VMOD,
+			     (HDTV_1080I << VENC_VMOD_TVTYP_SHIFT),
+			     VENC_VMOD_TVTYP);
+			venc_reg_merge
+			    (VENC_VMOD,
+			     VENC_VMOD_VENC,
+			     VENC_VMOD_VENC);
+			if (strict_strtoul(buf, 10, &val) != 0)
+				val = 30;
+			switch (val) {
+			case 30:
+			default:
+				xh = 0;
+				break;
+			case 25:
+				xh = 2640;
+				break;
+			}
+			venc_reg_out(VENC_XHINTVL, xh);
+		} else {
+			printk(KERN_ERR "Mode not supported..\n");
+			return -EINVAL;
+		}
+	} else {
+		/* Non- Standard mode. Check if we support it. If so
+		   save the timing info and return */
+		my_mode_info = get_modeinfo(VID_ENC_STD_NON_STANDARD);
+		if (my_mode_info) {
+			/* We support. So save timing info and return success
+			   interface type is same as what is currently is active
+			 */
+			vpbe_encoder_channel_info.params.mode =
+			    VID_ENC_STD_NON_STANDARD;
+			my_mode_info->std = 0;
+			my_mode_info->interlaced = mode_info->interlaced;
+			my_mode_info->xres = mode_info->xres;
+			my_mode_info->yres = mode_info->yres;
+			my_mode_info->fps = mode_info->fps;
+			my_mode_info->left_margin = mode_info->left_margin;
+			my_mode_info->right_margin = mode_info->right_margin;
+			my_mode_info->upper_margin = mode_info->upper_margin;
+			my_mode_info->lower_margin = mode_info->lower_margin;
+			my_mode_info->hsync_len = mode_info->hsync_len;
+			my_mode_info->vsync_len = mode_info->vsync_len;
+			my_mode_info->flags = mode_info->flags;
+			/* If we need to configure something in the encoder module, we need to
+			   do this here */
+			return 0;
+		}
+		printk(KERN_ERR "Mode not supported..\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "</vpbe_encoder_setmode>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected mode.*/
+static int vpbe_encoder_getmode(struct vid_enc_mode_info *mode_info,
+				struct vid_encoder_device *enc)
+{
+	int err = 0;
+	struct vid_enc_mode_info *my_mode_info;
+	if ((NULL == enc) || (NULL == mode_info)) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<vpbe_encoder_getmode>\n");
+	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		printk(KERN_ERR "NULL Pointer for current mode info\n");
+		return -EINVAL;
+	}
+	memcpy(mode_info, my_mode_info, sizeof(struct vid_enc_mode_info));
+	printk(KERN_DEBUG "<vpbe_encoder_getmode/>\n");
+	return err;
+}
+
+/* Following function is used to set output format in VPBE DAC. The
+   output name is  passed as the argument to this function. */
+static int vpbe_encoder_setoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0, index;
+	struct vid_enc_mode_info *my_mode_info;
+	printk(KERN_DEBUG "<vpbe_encoder_setoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output: NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < vpbe_encoder_configuration.no_of_outputs;
+	     index++) {
+		if (!strcmp
+		    (output,
+		     vpbe_encoder_configuration.output[index].output_name)) {
+			break;
+		}
+	}
+
+	if (index == vpbe_encoder_configuration.no_of_outputs) {
+		/* No output matching this name */
+		printk(KERN_ERR "No matching output: %s\n", output);
+		return -EINVAL;
+	}
+
+	if (vpbe_encoder_set_dac(output) < 0) {
+		printk(KERN_ERR
+		       "<vpbe_encoder_setoutput, error in setting DAC config>\n");
+		return -EINVAL;
+	}
+
+	vpbe_encoder_channel_info.params.outindex = index;
+
+	/* set default standard */
+	vpbe_encoder_channel_info.params.mode
+	    = vpbe_encoder_configuration.output[index].standards[0];
+
+	my_mode_info = get_modeinfo(vpbe_encoder_channel_info.params.mode);
+	if (NULL == my_mode_info) {
+		printk(KERN_ERR "No matching mode_info entry found\n");
+		return -EINVAL;
+	}
+
+	err |= vpbe_encoder_setmode(my_mode_info, enc);
+	if (err < 0) {
+		printk(KERN_ERR "Erron in setting default mode\n");
+		return err;
+	}
+	printk(KERN_DEBUG "</vpbe_encoder_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get output name of current output.*/
+static int vpbe_encoder_getoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0, index, len;
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer\n");
+		return -EINVAL;
+	}
+	printk(KERN_DEBUG "<vpbe_encoder_getoutput>\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = vpbe_encoder_channel_info.params.outindex;
+	len = strlen(vpbe_encoder_configuration.output[index].output_name);
+	if (len > (VID_ENC_NAME_MAX_CHARS - 1))
+		len = VID_ENC_NAME_MAX_CHARS - 1;
+	strncpy(output, vpbe_encoder_configuration.output[index].output_name,
+		len);
+	output[len] = '\0';
+	printk(KERN_DEBUG "</vpbe_encoder_getoutput>\n");
+	return err;
+}
+
+/* Following function is used to enumerate outputs supported by the driver.
+   It fills in information about the output in the output. */
+static int vpbe_encoder_enumoutput(int index, char *output,
+				   struct vid_encoder_device *enc)
+{
+	int err = 0;
+
+	printk(KERN_DEBUG "<vpbe_encoder_enumoutput>\n");
+	if (NULL == enc) {
+		printk(KERN_ERR "enc:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* check for null pointer */
+	if (output == NULL) {
+		printk(KERN_ERR "output:NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Only one output is available */
+	if (index >= vpbe_encoder_configuration.no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		vpbe_encoder_configuration.output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	printk(KERN_DEBUG "</vpbe_encoder_enumoutput>\n");
+	return err;
+}
+
+/* This function used to initialize the vpbe encoder driver */
+static int vpbe_encoder_init(void)
+{
+	int err = 0;
+
+	if (cpu_is_davinci_dm644x()) {
+		/* Do nothing. We have everything setup for DM6446 */
+	} else if (cpu_is_davinci_dm355()) {
+		outputs_ops.count = VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
+//		vpbe_encoder_configuration.vencregs = DM355_VENC_REG_BASE;
+		vpbe_encoder_configuration.no_of_outputs =
+		    VPBE_DM355_ENCODER_MAX_NO_OUTPUTS;
+		vpbe_encoder_configuration.output[0].no_of_standard =
+		    VPBE_DM355_ENCODER_COMPOSITE_NUM_STD;
+		/* If we have different no of standards for composite in
+		 * DM355 and DM6446 we need to fill the stanard names as
+		 * well here. Now both are the same.
+		 */
+	} else if (cpu_is_davinci_dm365()) {
+		outputs_ops.count = VPBE_DM365_ENCODER_MAX_NO_OUTPUTS;
+//		vpbe_encoder_configuration.vencregs = DM365_VENC_REG_BASE;
+		vpbe_encoder_configuration.no_of_outputs =
+		    VPBE_DM365_ENCODER_MAX_NO_OUTPUTS;
+		vpbe_encoder_configuration.output[0].no_of_standard =
+		    VPBE_DM365_ENCODER_COMPOSITE_NUM_STD;
+		vpbe_encoder_configuration.output[1].no_of_standard =
+		    VPBE_DM365_ENCODER_COMPONENT_NUM_STD;
+		vpbe_encoder_configuration.output[1].output_name =
+		    VID_ENC_OUTPUT_COMPONENT;
+		vpbe_encoder_configuration.output[1].standards[0] =
+		    VID_ENC_STD_480P_60;
+		vpbe_encoder_configuration.output[1].standards[1] =
+		    VID_ENC_STD_576P_50;
+		vpbe_encoder_configuration.output[1].standards[2] =
+		    VID_ENC_STD_720P_24;
+		vpbe_encoder_configuration.output[1].standards[3] =
+		    VID_ENC_STD_720P_25;
+		vpbe_encoder_configuration.output[1].standards[4] =
+		    VID_ENC_STD_720P_30;
+		vpbe_encoder_configuration.output[1].standards[5] =
+		    VID_ENC_STD_720P_50;
+		vpbe_encoder_configuration.output[1].standards[6] =
+		    VID_ENC_STD_720P_60;
+		vpbe_encoder_configuration.output[1].standards[7] =
+		    VID_ENC_STD_1080I_25;
+		vpbe_encoder_configuration.output[1].standards[8] =
+		    VID_ENC_STD_1080I_30;
+  } else
+		return -1;
+
+	err = vid_enc_register_encoder(&vpbe_encoder_dev);
+	printk(KERN_NOTICE "VPBE Encoder Initialized\n");
+	return err;
+}
+
+/* Function used to cleanup vpbe encoder driver */
+static void vpbe_encoder_cleanup(void)
+{
+	vid_enc_unregister_encoder(&vpbe_encoder_dev);
+}
+
+subsys_initcall(vpbe_encoder_init);
+module_exit(vpbe_encoder_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/davinci/vpfe_capture.c b/drivers/media/video/davinci/vpfe_capture.c
index e7ddd3b..a2d2202 100644
--- a/drivers/media/video/davinci/vpfe_capture.c
+++ b/drivers/media/video/davinci/vpfe_capture.c
@@ -2066,14 +2066,14 @@ static __init int vpfe_probe(struct platform_device *device)
 
 	ccdc_hw_dev.set_ccdc_base(mem1, res1->end - res1->start + 1);
 
-	if (!request_mem_region(res2->start, res2->end - res2->start + 1,
+	/*if (!request_mem_region(res2->start, res2->end - res2->start + 1,
 				vpfe_dev->driver->name)) {
 		err = -ENXIO;
 		v4l2_err(vpfe_dev->driver,
 			"Failed request_mem_region for"
 				  " vpss base\n");
 		goto probe_out_unmap1;
-	}
+	}*/
 
 	mem2 = ioremap_nocache(res2->start, res2->end - res2->start + 1);
 	if (!mem2) {
diff --git a/drivers/media/video/davinci/vpss.c b/drivers/media/video/davinci/vpss.c
new file mode 100644
index 0000000..b17d888
--- /dev/null
+++ b/drivers/media/video/davinci/vpss.c
@@ -0,0 +1,690 @@
+/*
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * common vpss driver for all video drivers.
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/compiler.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <media/davinci/vpss.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("VPSS Driver");
+MODULE_AUTHOR("Texas Instruments");
+
+/* DM644x defines */
+#define DM644X_SBL_PCR_VPSS		(4)
+
+/* vpss BL register offsets */
+#define DM355_VPSSBL_CCDCMUX		0x1c
+/* vpss CLK register offsets */
+#define DM355_VPSSCLK_CLKCTRL		0x4
+#define DM355_VPSSBL_PCR		0x4
+#define DM355_VPSSBL_MEMCTRL		0x18
+
+/* masks and shifts */
+#define DM365_PCCR 			0x04
+#define DM365_ISP_REG_BASE 		0x01c70000
+#define DM365_VPSS_REG_BASE 		0x01c70200
+#define DM365_VPBE_CLK_CTRL 		0x00
+#define DM365_ISP5_CCDCMUX 		0x20
+#define DM365_ISP5_PG_FRAME_SIZE 	0x28
+#define DM365_CCDC_PG_VD_POL_SHIFT 	0
+#define DM365_CCDC_PG_HD_POL_SHIFT 	1
+#define DM365_VPSS_INTSTAT		0x0C
+#define DM365_VPSS_INTSEL1		0x10
+
+
+#define VPSS_CLK_CTRL			0x01C40044
+#define CCD_SRC_SEL_MASK		(BIT_MASK(5) | BIT_MASK(4))
+#define CCD_SRC_SEL_SHIFT		4
+#define CCD_INT_SEL_MASK		(BIT_MASK(12) | BIT_MASK(11)|\
+					BIT_MASK(10) | BIT_MASK(9)  |\
+					BIT_MASK(8)  | BIT_MASK(4)  |\
+					BIT_MASK(3)  | BIT_MASK(2)  |\
+					BIT_MASK(1)  | BIT_MASK(0))
+
+#define VPSS_HSSISEL_SHIFT		4
+
+
+/**
+ * vpss operations. Depends on platform. Not all functions are available
+ * on all platforms. The api, first check if a function is available before
+ * invoking it. In the probe, the function ptrs are intialized based on
+ * vpss name. vpss name can be "dm355_vpss", "dm644x_vpss" etc.
+ */
+struct vpss_hw_ops {
+	/* enable clock */
+	int (*enable_clock)(enum vpss_clock_sel clock_sel, int en);
+	/* select input to ccdc */
+	void (*select_ccdc_source)(enum vpss_ccdc_source_sel src_sel);
+	/* clear wbl overflow bit */
+	int (*clear_wbl_overflow)(enum vpss_wbl_sel wbl_sel);
+	/* set sync polarity */
+	void (*set_sync_pol)(struct vpss_sync_pol);
+	/* set the PG_FRAME_SIZE register*/
+	void (*set_pg_frame_size)(struct vpss_pg_frame_size);
+	/* check and clear interrupt if occured */ 
+	int (*dma_complete_interrupt)(void);
+};
+
+/* vpss configuration */
+struct vpss_oper_config {
+	__iomem void *vpss_regs_base0;
+	__iomem void *vpss_regs_base1;
+	resource_size_t *vpss_regs_base2;
+	struct resource		*r1;
+	resource_size_t		len1;
+	struct resource		*r2;
+	resource_size_t		len2;
+	char vpss_name[32];
+	spinlock_t vpss_lock;
+	struct vpss_hw_ops hw_ops;
+};
+
+static struct vpss_oper_config oper_cfg;
+
+/* register access routines */
+static inline u32 bl_regr(u32 offset)
+{
+	return __raw_readl(oper_cfg.vpss_regs_base0 + offset);
+}
+
+static inline void bl_regw(u32 val, u32 offset)
+{
+	__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);
+}
+
+static inline u32 isp5_read(u32 offset)
+{
+	return __raw_readl(oper_cfg.vpss_regs_base0 + offset);
+}
+
+static inline void isp5_write(u32 val, u32 offset)
+{
+	__raw_writel(val, oper_cfg.vpss_regs_base0 + offset);
+}
+
+static inline u32 vpss_regr(u32 offset)
+{
+	return __raw_readl(oper_cfg.vpss_regs_base1 + offset);
+}
+
+static inline void vpss_regw(u32 val, u32 offset)
+{
+	__raw_writel(val, oper_cfg.vpss_regs_base1 + offset);
+}
+
+static void dm355_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
+{
+	bl_regw(src_sel << VPSS_HSSISEL_SHIFT, DM355_VPSSBL_CCDCMUX);
+}
+
+static void dm365_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
+{
+	u32 temp = isp5_read(DM365_ISP5_CCDCMUX) & ~CCD_SRC_SEL_MASK;
+
+	/* if we are using pattern generator, enable it */
+	if (src_sel == VPSS_PGLPBK || src_sel == VPSS_CCDCPG)
+		temp |= 0x08;
+
+	temp |= (src_sel << CCD_SRC_SEL_SHIFT);
+	isp5_write(temp, DM365_ISP5_CCDCMUX);
+}
+
+/**
+ *  dm365_dma_complete_interrupt - check and clear RSZ_INT_DMA 
+ *
+ *  This is called to update check and clear RSZ_INT_DMA interrupt
+ */
+int dm365_dma_complete_interrupt(void)
+{
+	u32 status;
+
+	status = isp5_read(DM365_VPSS_INTSTAT);	
+	/* Check and clear bit 15 */
+	if (status & 0x8000) {
+		status &= 0x8000;
+		isp5_write(status, DM365_VPSS_INTSTAT);
+		/* clear the interrupt */
+		return 0;
+	}
+	return 1;
+}
+
+int vpss_dma_complete_interrupt(void)
+{
+	if (!oper_cfg.hw_ops.dma_complete_interrupt)
+		return 2;
+	
+	return oper_cfg.hw_ops.dma_complete_interrupt(); 	
+}
+EXPORT_SYMBOL(vpss_dma_complete_interrupt);
+
+int vpss_select_ccdc_source(enum vpss_ccdc_source_sel src_sel)
+{
+	if (!oper_cfg.hw_ops.select_ccdc_source)
+		return -1;
+
+	oper_cfg.hw_ops.select_ccdc_source(src_sel);
+
+	return 0;
+}
+EXPORT_SYMBOL(vpss_select_ccdc_source);
+
+static int dm644x_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel)
+{
+	u32 mask = 1, val;
+
+	if (wbl_sel < VPSS_PCR_AEW_WBL_0 ||
+	    wbl_sel > VPSS_PCR_CCDC_WBL_O)
+		return -1;
+
+	/* writing a 0 clear the overflow */
+	mask = ~(mask << wbl_sel);
+	val = bl_regr(DM644X_SBL_PCR_VPSS) & mask;
+	bl_regw(val, DM644X_SBL_PCR_VPSS);
+
+	return 0;
+}
+
+/**
+ *  vpss_pcr_control - common function for updating vpsssbl pcr register
+ *  @val: value to be written
+ *  @mask: bit mask
+ *  @shift: shift for mask and val 
+ *
+ *  This is called to update VPSSSBL PCR register
+ */
+static void vpss_pcr_control(int val, int mask, int shift)
+{
+	unsigned long flags;
+	u32 utemp;
+
+	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
+
+	utemp = bl_regr(DM355_VPSSBL_PCR);
+	mask <<= shift;
+	val <<= shift;
+	utemp &= (~mask);
+	utemp |= val;
+
+	bl_regw(utemp, DM355_VPSSBL_PCR);
+	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
+}
+
+/**
+ *  vpss_dm355_assign_wblctrl_master - select WBLCTRL/DDR2 read master 
+ *  @master: memory master
+ *
+ *  This is called to assign DDR2/WBLCTRL master. Use this in only DM355
+ */
+void vpss_dm355_assign_wblctrl_master(enum dm355_wblctrl master)
+{
+	/* WBLCTRL is bit 6 */
+	vpss_pcr_control(master, 1, 6);
+}
+EXPORT_SYMBOL(vpss_dm355_assign_wblctrl_master);
+
+/**
+ *  vpss_dm355_assign_rblctrl_master - select RBLCTRL/DDR2 read master 
+ *  @master: memory master
+ *
+ *  This is called to assign DDR2/RBLCTRL master. Use this in only DM355
+ */
+void vpss_dm355_assign_rblctrl_master(enum dm355_rblctrl master)
+{
+	/* RBLCTRL is bit 5 & 4 */
+	vpss_pcr_control(master, 3, 5);
+}
+EXPORT_SYMBOL(vpss_dm355_assign_rblctrl_master);
+
+/**
+ *  vpss_memory_control - common function for updating memory
+ *  control register
+ *  @en: enable/disable
+ *  @mask: bit mask
+ *
+ *  This is called to update memory control register
+ */
+static void vpss_mem_control(int en, u32 mask)
+{
+	unsigned long flags;
+	u32 utemp;
+
+	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
+	utemp = bl_regr(DM355_VPSSBL_MEMCTRL);
+	if (en)
+		utemp |= mask;
+	else
+		utemp &= (~mask);
+
+	bl_regw(utemp, DM355_VPSSBL_MEMCTRL);
+	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
+}
+
+/**
+ *  vpss_dm355_assign_dfc_memory_master - select dfc memory by IPIPE/CCDC
+ *  @master: memory master
+ *
+ *  This is called to assign dfc memory mastership to IPIPE or CCDC.
+ *  Use this in only DM355
+ */
+void vpss_dm355_assign_dfc_memory_master(enum dm355_dfc_mem_sel master)
+{
+	if (master == DM355_DFC_MEM_IPIPE)
+		vpss_mem_control(0, 0x1);
+	else
+		vpss_mem_control(1, 0x1);
+}
+EXPORT_SYMBOL(vpss_dm355_assign_dfc_memory_master);
+
+/**
+ *  vpss_dm355_ipipe_enable_any_address - IPIPE can use any address type 
+ *  @en: enable/disable non-aligned buffer address use.
+ *
+ *  This is called to allow IPIPE to use non-aligned buffer address.
+ *  Applicable only to DM355.
+ */
+void vpss_dm355_ipipe_enable_any_address(int en)
+{
+	if (en)
+		vpss_mem_control(1, 0x4);
+	else
+		vpss_mem_control(0, 0x4);
+}
+EXPORT_SYMBOL(vpss_dm355_ipipe_enable_any_address);
+
+/*
+ *  vpss_dm355_assign_int_memory_master - assign internal module memory 
+ *  @master: master for internal memory
+ *
+ *  This function will select the module that gets access to internal memory.
+ *  Choice is either IPIPE or CFALD. Applicable only on DM355
+ */
+void vpss_dm355_assign_int_memory_master(enum dm355_int_mem_sel master)
+{
+	if (master == DM355_INT_MEM_IPIPE)
+		vpss_mem_control(0, 0x2);
+	else
+		vpss_mem_control(1, 0x2);
+
+}
+EXPORT_SYMBOL(vpss_dm355_assign_int_memory_master);
+
+#if 0
+static void dm365_enable_irq(void)
+{
+	u32 current_val = isp5_read(DM365_VPSS_INTSEL1);
+	/*just enable INTSEL0 and INTSEL1 and leave everything else as is*/
+	current_val &= ~(CCD_INT_SEL_MASK);
+	current_val |= BIT_MASK(8);
+	isp5_write(current_val, DM365_VPSS_INTSEL1);
+}
+#endif
+
+void dm365_set_sync_pol(struct vpss_sync_pol sync)
+{
+	int val = 0;
+	val = isp5_read(DM365_ISP5_CCDCMUX);
+
+	val |= (sync.ccdpg_hdpol << DM365_CCDC_PG_HD_POL_SHIFT);
+	val |= (sync.ccdpg_vdpol << DM365_CCDC_PG_VD_POL_SHIFT);
+
+	isp5_write(val, DM365_ISP5_CCDCMUX);
+}
+
+void vpss_set_sync_pol(struct vpss_sync_pol sync)
+{
+	if (!oper_cfg.hw_ops.set_sync_pol)
+		return;
+
+	oper_cfg.hw_ops.set_sync_pol(sync);
+}
+EXPORT_SYMBOL(vpss_set_sync_pol);
+
+void dm365_set_pg_frame_size(struct vpss_pg_frame_size frame_size)
+{
+	int current_reg = ((frame_size.hlpfr >> 1) - 1) << 16;
+
+	current_reg |= (frame_size.pplen - 1);
+	isp5_write(current_reg, DM365_ISP5_PG_FRAME_SIZE);
+}
+
+void vpss_set_pg_frame_size(struct vpss_pg_frame_size frame_size)
+{
+	if (!oper_cfg.hw_ops.set_pg_frame_size)
+		return;
+
+	oper_cfg.hw_ops.set_pg_frame_size(frame_size);
+}
+EXPORT_SYMBOL(vpss_set_pg_frame_size);
+
+int vpss_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel)
+{
+	if (!oper_cfg.hw_ops.clear_wbl_overflow)
+		return -1;
+
+	return oper_cfg.hw_ops.clear_wbl_overflow(wbl_sel);
+}
+EXPORT_SYMBOL(vpss_clear_wbl_overflow);
+
+/**
+ *  dm355_enable_clock - Enable VPSS Clock
+ *  @clock_sel: CLock to be enabled/disabled
+ *  @en: enable/disable flag
+ *
+ *  This is called to enable or disable a vpss clock
+ */
+static int dm355_enable_clock(enum vpss_clock_sel clock_sel, int en)
+{
+	unsigned long flags;
+	u32 utemp, mask = 0x1, shift = 0;
+
+	switch (clock_sel) {
+	case VPSS_VPBE_CLOCK:
+		/* nothing since lsb */
+		break;
+	case VPSS_VENC_CLOCK_SEL:
+		shift = 2;
+		break;
+	case VPSS_CFALD_CLOCK:
+		shift = 3;
+		break;
+	case VPSS_H3A_CLOCK:
+		shift = 4;
+		break;
+	case VPSS_IPIPE_CLOCK:
+		shift = 5;
+		break;
+	case VPSS_CCDC_CLOCK:
+		shift = 6;
+		break;
+	default:
+		printk(KERN_ERR "dm355_enable_clock:"
+				" Invalid selector: %d\n", clock_sel);
+		return -1;
+	}
+
+	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
+	utemp = vpss_regr(DM355_VPSSCLK_CLKCTRL);
+	if (!en)
+		utemp &= ~(mask << shift);
+	else
+		utemp |= (mask << shift);
+
+	vpss_regw(utemp, DM355_VPSSCLK_CLKCTRL);
+	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
+
+	return 0;
+}
+
+static int dm365_enable_clock(enum vpss_clock_sel clock_sel, int en)
+{
+	unsigned long flags;
+	u32 utemp, mask = 0x1, shift = 0, offset = DM365_PCCR;
+	u32 (*read)(u32 offset) = isp5_read;
+	void(*write)(u32 val, u32 offset) = isp5_write;
+
+	switch (clock_sel) {
+	case VPSS_BL_CLOCK:
+		break;
+	case VPSS_CCDC_CLOCK:
+		shift = 1;
+		break;
+	case VPSS_H3A_CLOCK:
+		shift = 2;
+		break;
+	case VPSS_RSZ_CLOCK:
+		shift = 3;
+		break;
+	case VPSS_IPIPE_CLOCK:
+		shift = 4;
+		break;
+	case VPSS_IPIPEIF_CLOCK:
+		shift = 5;
+		break;
+	case VPSS_PCLK_INTERNAL:
+		shift = 6;
+		break;
+	case VPSS_PSYNC_CLOCK_SEL:
+		shift = 7;
+		break;
+	case VPSS_VPBE_CLOCK:
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	case VPSS_VENC_CLOCK_SEL:
+		shift = 2;
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	case VPSS_LDC_CLOCK:
+		shift = 3;
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	case VPSS_FDIF_CLOCK:
+		shift = 4;
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	case VPSS_OSD_CLOCK_SEL:
+		shift = 6;
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	case VPSS_LDC_CLOCK_SEL:
+		shift = 7;
+		read = vpss_regr;
+		write = vpss_regw;
+		offset = DM365_VPBE_CLK_CTRL;
+		break;
+	default:
+		printk(KERN_ERR "dm365_enable_clock: Invalid selector: %d\n",
+		       clock_sel);
+		return -1;
+	}
+
+	spin_lock_irqsave(&oper_cfg.vpss_lock, flags);
+	utemp = read(offset);
+	if (!en) {
+		mask = ~mask;
+		utemp &= (mask << shift);
+	} else
+		utemp |= (mask << shift);
+
+	write(utemp, offset);
+	spin_unlock_irqrestore(&oper_cfg.vpss_lock, flags);
+
+	return 0;
+}
+
+int vpss_enable_clock(enum vpss_clock_sel clock_sel, int en)
+{
+	if (!oper_cfg.hw_ops.enable_clock)
+		return -1;
+
+	return oper_cfg.hw_ops.enable_clock(clock_sel, en);
+}
+EXPORT_SYMBOL(vpss_enable_clock);
+
+static int __init vpss_probe(struct platform_device *pdev)
+{
+	int status, dm355 = 0, dm365 = 0;
+
+	if (!pdev->dev.platform_data) {
+		dev_err(&pdev->dev, "no platform data\n");
+		return -ENOENT;
+	}
+	strcpy(oper_cfg.vpss_name, pdev->dev.platform_data);
+
+	if (!strcmp(oper_cfg.vpss_name, "dm355_vpss"))
+		dm355 = 1;
+	else if (!strcmp(oper_cfg.vpss_name, "dm365_vpss"))
+		dm365 = 1;
+	else if (strcmp(oper_cfg.vpss_name, "dm644x_vpss")) {
+		dev_err(&pdev->dev, "vpss driver not supported on"
+			" this platform\n");
+		return -ENODEV;
+	}
+
+	dev_info(&pdev->dev, "%s vpss probed\n", oper_cfg.vpss_name);
+	oper_cfg.r1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!oper_cfg.r1)
+		return -ENOENT;
+
+	oper_cfg.len1 = oper_cfg.r1->end - oper_cfg.r1->start + 1;
+
+	oper_cfg.r1 = request_mem_region(oper_cfg.r1->start, oper_cfg.len1,
+					 oper_cfg.r1->name);
+	if (!oper_cfg.r1)
+		return -EBUSY;
+
+	oper_cfg.vpss_regs_base0 = ioremap(oper_cfg.r1->start, oper_cfg.len1);
+	if (!oper_cfg.vpss_regs_base0) {
+		status = -EBUSY;
+		goto fail1;
+	}
+
+	if (dm355 || dm365) {
+		oper_cfg.r2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (!oper_cfg.r2) {
+			status = -ENOENT;
+			goto fail2;
+		}
+		oper_cfg.len2 = oper_cfg.r2->end - oper_cfg.r2->start + 1;
+		oper_cfg.r2 = request_mem_region(oper_cfg.r2->start,
+						 oper_cfg.len2,
+						 oper_cfg.r2->name);
+		if (!oper_cfg.r2) {
+			status = -EBUSY;
+			goto fail2;
+		}
+
+		oper_cfg.vpss_regs_base1 = ioremap(oper_cfg.r2->start,
+						  oper_cfg.len2);
+		if (!oper_cfg.vpss_regs_base1) {
+			status = -EBUSY;
+			goto fail3;
+		}
+	}
+
+	if (dm355) {
+		//oper_cfg.hw_ops.enable_clock = dm355_enable_clock;
+		//oper_cfg.hw_ops.select_ccdc_source = dm355_select_ccdc_source;
+	} else if (dm365) {
+		oper_cfg.hw_ops.enable_clock = dm365_enable_clock;
+		oper_cfg.hw_ops.select_ccdc_source = dm365_select_ccdc_source;
+		oper_cfg.hw_ops.set_sync_pol = dm365_set_sync_pol;
+		oper_cfg.hw_ops.set_pg_frame_size = dm365_set_pg_frame_size;
+		oper_cfg.hw_ops.dma_complete_interrupt =
+				dm365_dma_complete_interrupt;
+
+	} else if (!strcmp(oper_cfg.vpss_name, "dm644x_vpss"))
+		oper_cfg.hw_ops.clear_wbl_overflow = dm644x_clear_wbl_overflow;
+
+	if (dm355) {
+		/*
+		 * These values being written to INTSEL and EVTSEL
+		 * registers match those in LSP 2.10
+		 */
+		bl_regw(0xff83ff10, 0x10);
+		bl_regw(0x7b3c0004, 0x14);
+	}
+	if (dm365) {
+		/**
+		 * These values being written to INTSEL and EVTSEL
+		 * registers match those in LSP 2.10
+		 */
+		isp5_write((isp5_read(0x4) | 0x0000007f), 0x4);
+		isp5_write((isp5_read(0x8) | 0x00000002), 0x8);
+		/* INT0, INT1, AF */
+		isp5_write((isp5_read(0x10) | 0x0b1f0100), 0x10);
+		/* AEW, RSZ_INT_DMA */
+		isp5_write((isp5_read(0x14) | 0x1f0a0f1f), 0x14);
+		/* VENC */
+		isp5_write((isp5_read(0x18) | 0x00000015), 0x18);
+		/* No event selected */
+		isp5_write((isp5_read(0x1c) | 0x00000000), 0x1c);
+	}
+
+	spin_lock_init(&oper_cfg.vpss_lock);
+	dev_info(&pdev->dev, "%s vpss probe success\n", oper_cfg.vpss_name);
+	return 0;
+
+fail3:
+	release_mem_region(oper_cfg.r2->start, oper_cfg.len2);
+fail2:
+	iounmap(oper_cfg.vpss_regs_base0);
+fail1:
+	release_mem_region(oper_cfg.r1->start, oper_cfg.len1);
+	return status;
+}
+
+static int vpss_remove(struct platform_device *pdev)
+{
+	iounmap(oper_cfg.vpss_regs_base0);
+	release_mem_region(oper_cfg.r1->start, oper_cfg.len1);
+	if (!strcmp(oper_cfg.vpss_name, "dm355_vpss") ||
+	    !strcmp(oper_cfg.vpss_name, "dm365_vpss")) {
+		iounmap(oper_cfg.vpss_regs_base1);
+		release_mem_region(oper_cfg.r2->start, oper_cfg.len2);
+	}
+
+	return 0;
+}
+
+static struct platform_driver vpss_driver = {
+	.driver = {
+		.name	= "vpss",
+		.owner = THIS_MODULE,
+	},
+	.remove = __devexit_p(vpss_remove),
+	.probe = vpss_probe,
+};
+
+static void vpss_exit(void)
+{
+	iounmap(oper_cfg.vpss_regs_base2);
+	release_mem_region(*oper_cfg.vpss_regs_base2, 4);
+	platform_driver_unregister(&vpss_driver);
+}
+
+static int __init vpss_init(void)
+{
+	if (request_mem_region(VPSS_CLK_CTRL, 4, "vpss_clock_control")) {
+		oper_cfg.vpss_regs_base2 = ioremap(VPSS_CLK_CTRL, 4);
+		__raw_writel(0x18, oper_cfg.vpss_regs_base2);
+	} else
+		return -EBUSY;
+
+	return platform_driver_register(&vpss_driver);
+}
+subsys_initcall(vpss_init);
+module_exit(vpss_exit);
diff --git a/drivers/video/davincifb.c b/drivers/video/davincifb.c
index 1344be7..44dffc7 100644
--- a/drivers/video/davincifb.c
+++ b/drivers/video/davincifb.c
@@ -1,18 +1,22 @@
 /*
- * drivers/video/davincifb.c
+ * Copyright (C) 2007 MontaVista Software Inc.
+ * Copyright (C) 2006 Texas Instruments Inc
  *
- * Framebuffer driver for Texas Instruments DaVinci display controller.
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
  *
- * Copyright (C) 2006 Texas Instruments, Inc.
- * Rishi Bhattacharya <support@ti.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
  *
- * Leveraged from the framebuffer driver for OMAP24xx
- * written by Andy Lowe (source@mvista.com)
- * Copyright (C) 2004 MontaVista Software, Inc.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
 #include <linux/module.h>
@@ -26,754 +30,1348 @@
 #include <linux/fb.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-
-#include <asm/irq.h>
 #include <asm/uaccess.h>
-
-#include <video/davincifb.h>
+#include <linux/moduleparam.h>	/* for module_param() */
+#include <linux/platform_device.h>
 #include <asm/system.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <media/davinci/davinci_enc.h>
+#include <video/davincifb_ioctl.h>
+#include <video/davincifb.h>
+#include <mach/cpu.h>
 
-#define MODULE_NAME "davincifb"
+/* return non-zero if the info structure corresponds to OSD0 or OSD1 */
+static int is_osd_win(const struct fb_info *info)
+{
+	const struct vpbe_dm_win_info *win = info->par;
 
-/* Output Format Selection  */
-#define MULTIPLE_BUFFERING	1
+	if (win->layer == WIN_OSD0 || win->layer == WIN_OSD1)
+		return 1;
+	else
+		return 0;
+}
 
-#ifdef MULTIPLE_BUFFERING
-#define DOUBLE_BUF	2
-#define TRIPLE_BUF	3
-#else
-#define DOUBLE_BUF	1
-#define TRIPLE_BUF	1
-#endif
+/* return non-zero if the info structure corresponds to VID0 or VID1 */
+#define is_vid_win(info) (!is_osd_win(info))
 
 /*
- * display controller register I/O routines
+ * Convert a framebuffer info pointer to a davinci_osd_layer enumeration.
+ * It is up to the caller to verify that the info structure corresponds to
+ * either OSD0 or OSD1.
  */
-static __inline__ u32 dispc_reg_in(u32 reg)
-{
-	return ioread32(IO_ADDRESS(reg));
-}
-static __inline__ u32 dispc_reg_out(u32 reg, u32 val)
-{
-	iowrite32(val, IO_ADDRESS(reg));
-	return (val);
-}
-static __inline__ u32 dispc_reg_merge(u32 reg, u32 val, u32 mask)
+static enum davinci_osd_layer fb_info_to_osd_enum(const struct fb_info *info)
 {
-	u32 new_val = (ioread32(IO_ADDRESS(reg)) & ~mask) | (val & mask);
+	const struct vpbe_dm_win_info *win = info->par;
 
-	iowrite32(new_val, IO_ADDRESS(reg));
-	return (new_val);
+	if (win->layer == WIN_OSD1)
+		return OSDWIN_OSD1;
+	else
+		return OSDWIN_OSD0;
 }
 
-/* There are 4 framebuffers, each represented by an fb_info and
- * a dm_win_info structure */
-#define OSD0_FBNAME	"dm_osd0_fb"
-#define OSD1_FBNAME	"dm_osd1_fb"
-#define VID0_FBNAME	"dm_vid0_fb"
-#define VID1_FBNAME	"dm_vid1_fb"
+/* macros for testing fb_var_screeninfo attributes */
+#define is_attribute_mode(var) (((var)->bits_per_pixel == 4) && \
+	((var)->nonstd != 0))
+#define is_yuv(var) ((((var)->bits_per_pixel == 16) || \
+  ((var)->bits_per_pixel == 8)) \
+  && ((var)->nonstd != 0))
+#define is_window_interlaced(var) (((var)->vmode & FB_VMODE_INTERLACED) \
+	== FB_VMODE_INTERLACED)
 
-/* usage:	if (is_win(info->fix.id, OSD0)) ... */
-#define is_win(name, x) ((strcmp(name, x ## _FBNAME) == 0) ? 1 : 0)
+/* macros for testing fb_videomode attributes */
+#define is_display_interlaced(mode) (((mode)->vmode & FB_VMODE_INTERLACED) \
+	== FB_VMODE_INTERLACED)
 
-struct dm_win_info {
-	struct fb_info info;
+static unsigned int fb_cbcr_ofst;
 
-	/* X and Y position */
-	unsigned int x, y;
+/*
+ * Convert an fb_var_screeninfo struct to a Davinci display layer configuration.
+ * lconfig->xpos, lconfig->ypos, and lconfig->line_length are not modified
+ * because no information about them is contained in var.
+ * The value of the yc_pixfmt argument is returned in lconfig->pixfmt if a
+ * the var specifies a YC pixel format.  The value of yc_pixfmt must be either
+ * PIXFMT_YCbCrI or PIXFMT_YCrCbI.
+ */
+static void convert_fb_var_to_osd(const struct fb_var_screeninfo *var,
+				  struct davinci_layer_config *lconfig,
+				  enum davinci_pix_format yc_pixfmt)
+{
+	lconfig->xsize = var->xres;
+	lconfig->ysize = var->yres;
+	lconfig->interlaced = is_window_interlaced(var);
 
-	/* framebuffer area */
-	dma_addr_t fb_base_phys;
-	unsigned long fb_base;
-	unsigned long fb_size;
+	switch (var->bits_per_pixel) {
+	case 1:
+		lconfig->pixfmt = PIXFMT_1BPP;
+		break;
+	case 2:
+		lconfig->pixfmt = PIXFMT_2BPP;
+		break;
+	case 4:
+		if (is_attribute_mode(var))
+			lconfig->pixfmt = PIXFMT_OSD_ATTR;
+		else
+			lconfig->pixfmt = PIXFMT_4BPP;
+		break;
+	case 8:
+		if (is_yuv(var))
+			lconfig->pixfmt = PIXFMT_NV12;
+		else
+			lconfig->pixfmt = PIXFMT_8BPP;
+		break;
+	case 16:
+	default:
+		if (is_yuv(var))
+			lconfig->pixfmt = yc_pixfmt;
+		else
+			lconfig->pixfmt = PIXFMT_RGB565;
+		break;
+	case 24:
+	case 32:
+		lconfig->pixfmt = PIXFMT_RGB888;
+		break;
+	}
+}
 
-	u32 pseudo_palette[17];
+/*
+ * Convert an fb_info struct to a Davinci display layer configuration.
+ */
+static void convert_fb_info_to_osd(const struct fb_info *info,
+				   struct davinci_layer_config *lconfig)
+{
+	const struct vpbe_dm_win_info *win = info->par;
 
-	/* flag to identify if framebuffer area is fixed already or not */
-	int alloc_fb_mem;
-	unsigned long sdram_address;
-	struct dm_info *dm;
-};
+	lconfig->line_length = info->fix.line_length;
+	lconfig->xpos = win->xpos;
+	lconfig->ypos = win->ypos;
+	convert_fb_var_to_osd(&info->var, lconfig, win->dm->yc_pixfmt);
+}
 
-static struct dm_info {
-	struct dm_win_info *osd0;
-	struct dm_win_info *osd1;
-	struct dm_win_info *vid0;
-	struct dm_win_info *vid1;
+/*
+ * Convert a Davinci display layer configuration to var info.
+ * The following members of var are not modified:
+ *	var->xres_virtual
+ *	var->yres_virtual
+ *	var->xoffset
+ *	var->yoffset
+ *	var->pixclock
+ *	var->left_margin
+ *	var->right_margin
+ *	var->upper_margin
+ *	var->lower_margin
+ *	var->hsync_len
+ *	var->vsync_len
+ *	var->sync
+ * Only bit 0 of var->vmode (FB_VMODE_INTERLACED) is modified.  All other bits
+ * of var->vmode are retained.
+ */
+static void convert_osd_to_fb_var(const struct davinci_layer_config *lconfig,
+				  struct fb_var_screeninfo *var)
+{
+	var->xres = lconfig->xsize;
+	var->yres = lconfig->ysize;
+	if (lconfig->interlaced)
+		var->vmode |= FB_VMODE_INTERLACED;
+	else
+		var->vmode &= ~FB_VMODE_INTERLACED;
+
+	var->red.offset = var->green.offset = var->blue.offset = 0;
+	var->red.msb_right = var->green.msb_right = var->blue.msb_right = 0;
+	var->transp.offset = var->transp.length = var->transp.msb_right = 0;
+	var->nonstd = 0;
+
+	switch (lconfig->pixfmt) {
+	case PIXFMT_1BPP:
+		var->bits_per_pixel = 1;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_2BPP:
+		var->bits_per_pixel = 2;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_4BPP:
+		var->bits_per_pixel = 4;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_8BPP:
+		var->bits_per_pixel = 8;
+		var->red.length = var->green.length = var->blue.length =
+		    var->bits_per_pixel;
+		break;
+	case PIXFMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 0;
+		var->blue.length = 5;
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		var->bits_per_pixel = 16;
+		var->red.length = var->green.length = var->blue.length = 0;
+		var->nonstd = 1;
+		break;
+	case PIXFMT_NV12:
+		if (cpu_is_davinci_dm365()) {
+			var->bits_per_pixel = 8;
+			var->red.length = var->green.length = var->blue.length =
+			    0;
+			var->nonstd = 1;
+		}
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm644x()) {
+			var->bits_per_pixel = 24;
+			var->red.offset = 0;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 16;
+			var->blue.length = 8;
+		} else {
+			var->bits_per_pixel = 32;
+			var->red.offset = 16;
+			var->red.length = 8;
+			var->green.offset = 8;
+			var->green.length = 8;
+			var->blue.offset = 0;
+			var->blue.length = 8;
+			var->transp.offset = 24;
+			var->transp.length = 3;
+		}
+		break;
+	case PIXFMT_OSD_ATTR:
+		var->bits_per_pixel = 4;
+		var->red.length = var->green.length = var->blue.length = 0;
+		var->nonstd = 1;
+		break;
+	}
 
-	/* to map the registers */
-	dma_addr_t mmio_base_phys;
-	unsigned long mmio_base;
-	unsigned long mmio_size;
+	var->grayscale = 0;
+	var->activate = FB_ACTIVATE_NOW;
+	var->height = 0;
+	var->width = 0;
+	var->accel_flags = 0;
+	var->rotate = 0;
+}
 
-	wait_queue_head_t vsync_wait;
-	unsigned long vsync_cnt;
-	int timeout;
+/*
+ * Get the video mode from the encoder manager.
+ */
+static int get_video_mode(struct fb_videomode *mode)
+{
+	struct vid_enc_mode_info mode_info;
+	int ret;
 
-	/* this is the function that configures the output device (NTSC/PAL/LCD)
-	 * for the required output format (composite/s-video/component/rgb)
-	 */
-	void (*output_device_config) (int on);
+	memset(&mode_info, 0, sizeof(mode_info));
+	memset(mode, 0, sizeof(*mode));
+
+	ret = davinci_enc_get_mode(0, &mode_info);
+
+	mode->name = mode_info.name;
+	if (mode_info.fps.denominator) {
+		unsigned fps_1000;	/* frames per 1000 seconds */
+		unsigned lps;	/* lines per second */
+		unsigned pps;	/* pixels per second */
+		unsigned vtotal;	/* total lines per frame */
+		unsigned htotal;	/* total pixels per line */
+		unsigned interlace = (mode_info.interlaced) ? 2 : 1;
+
+		fps_1000 =
+		    (1000 * mode_info.fps.numerator +
+		     mode_info.fps.denominator / 2) / mode_info.fps.denominator;
+		mode->refresh = (interlace * fps_1000 + 1000 / 2) / 1000;
+
+		vtotal =
+		    mode_info.yres + mode_info.lower_margin +
+		    mode_info.vsync_len + mode_info.upper_margin;
+		lps = (fps_1000 * vtotal + 1000 / 2) / 1000;
+
+		htotal =
+		    mode_info.xres + mode_info.right_margin +
+		    mode_info.hsync_len + mode_info.left_margin;
+		pps = lps * htotal;
+
+		if (pps)
+			mode->pixclock =
+			    ((1000000000UL + pps / 2) / pps) * 1000;
+	}
+	mode->xres = mode_info.xres;
+	mode->yres = mode_info.yres;
+	mode->left_margin = mode_info.left_margin;
+	mode->right_margin = mode_info.right_margin;
+	mode->upper_margin = mode_info.upper_margin;
+	mode->lower_margin = mode_info.lower_margin;
+	mode->hsync_len = mode_info.hsync_len;
+	mode->vsync_len = mode_info.vsync_len;
+	if (mode_info.flags & (1 << 0))
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (mode_info.flags & (1 << 1))
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	if (mode_info.std)
+		mode->sync |= FB_SYNC_BROADCAST;
+	if (mode_info.interlaced)
+		mode->vmode |= FB_VMODE_INTERLACED;
+
+	return ret;
+}
 
-	struct device *dev;
-} dm_static;
-static struct dm_info *dm = &dm_static;
+/*
+ * Set a video mode with the encoder manager.
+ */
+static int set_video_mode(struct fb_videomode *mode)
+{
+	struct vid_enc_mode_info mode_info;
+	int ret;
 
-static struct fb_ops davincifb_ops;
+	davinci_enc_get_mode(0, &mode_info);
+
+	mode_info.name = (unsigned char *)mode->name;
+	mode_info.fps.numerator = 0;
+	mode_info.fps.denominator = 0;
+	if (mode->pixclock && mode->xres && mode->yres) {
+		unsigned fps_1000;	/* frames per 1000 seconds */
+		unsigned lps;	/* lines per second */
+		unsigned pps;	/* pixels per second */
+		unsigned vtotal;	/* total lines per frame */
+		unsigned htotal;	/* total pixels per line */
+
+		pps =
+		    ((1000000000UL +
+		      mode->pixclock / 2) / mode->pixclock) * 1000;
+
+		htotal =
+		    mode->xres + mode->right_margin + mode->hsync_len +
+		    mode->left_margin;
+		lps = (pps + htotal / 2) / htotal;
+
+		vtotal =
+		    mode->yres + mode->lower_margin + mode->vsync_len +
+		    mode->upper_margin;
+		fps_1000 = (lps * 1000 + vtotal / 2) / vtotal;
+
+		mode_info.fps.numerator = fps_1000;
+		mode_info.fps.denominator = 1000;
+
+		/*
+		 * 1000 == 2*2*2*5*5*5, so factor out any common multiples of 2
+		 * or 5
+		 */
+		while ((((mode_info.fps.numerator / 2) * 2) ==
+			mode_info.fps.numerator)
+		       && (((mode_info.fps.denominator / 2) * 2) ==
+			   mode_info.fps.denominator)) {
+			mode_info.fps.numerator = mode_info.fps.numerator / 2;
+			mode_info.fps.denominator =
+			    mode_info.fps.denominator / 2;
+		}
+		while ((((mode_info.fps.numerator / 5) * 5) ==
+			mode_info.fps.numerator)
+		       && (((mode_info.fps.denominator / 5) * 5) ==
+			   mode_info.fps.denominator)) {
+			mode_info.fps.numerator = mode_info.fps.numerator / 5;
+			mode_info.fps.denominator =
+			    mode_info.fps.denominator / 5;
+		}
+	}
+	mode_info.xres = mode->xres;
+	mode_info.yres = mode->yres;
+	mode_info.left_margin = mode->left_margin;
+	mode_info.right_margin = mode->right_margin;
+	mode_info.upper_margin = mode->upper_margin;
+	mode_info.lower_margin = mode->lower_margin;
+	mode_info.hsync_len = mode->hsync_len;
+	mode_info.vsync_len = mode->vsync_len;
+	if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		mode_info.flags |= (1 << 0);
+	else
+		mode_info.flags &= ~(1 << 0);
+	if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		mode_info.flags |= (1 << 1);
+	else
+		mode_info.flags &= ~(1 << 1);
+	if (mode->sync & FB_SYNC_BROADCAST)
+		mode_info.std = 1;
+	else
+		mode_info.std = 0;
+	if (mode->vmode & FB_VMODE_INTERLACED)
+		mode_info.interlaced = 1;
+	else
+		mode_info.interlaced = 0;
 
-#define BASEX		0x80
-#define BASEY		0x12
+	ret = davinci_enc_set_mode(0, &mode_info);
 
-#define DISP_XRES	720
-#define DISP_YRES	480
-#define DISP_MEMY	576
+	return ret;
+}
 
-/* Random value chosen for now. Should be within the panel's supported range */
-#define LCD_PANEL_CLOCK	180000
+/*
+ * Construct an fb_var_screeninfo structure from an fb_videomode structure
+ * describing the display and a davinci_layer_config structure describing a window.
+ * The following members of var not modified:
+ *	var->xoffset
+ *	var->yoffset
+ *	var->xres_virtual
+ *	var->yres_virtual
+ * The following members of var are loaded with values derived from mode:
+ *	var->pixclock
+ *	var->left_margin
+ *	var->hsync_len
+ *	var->vsync_len
+ *	var->right_margin
+ *	var->upper_margin
+ *	var->lower_margin
+ *	var->sync
+ *	var->vmode (all bits except bit 0: FB_VMODE_INTERLACED)
+ * The following members of var are loaded with values derived from lconfig:
+ *	var->xres
+ *	var->yres
+ *	var->bits_per_pixel
+ *	var->red
+ *	var->green
+ *	var->blue
+ *	var->transp
+ *	var->nonstd
+ *	var->grayscale
+ *	var->activate
+ *	var->height
+ *	var->width
+ *	var->accel_flags
+ *	var->rotate
+ *	var->vmode (only bit 0: FB_VMODE_INTERLACED)
+ *
+ * If the display resolution (xres and yres) specified in mode matches the
+ * window resolution specified in lconfig, then the display timing info returned
+ * in var is valid and var->pixclock will be the value derived from mode.
+ * If the display resolution does not match the window resolution, then
+ * var->pixclock will be set to 0 to indicate that the display timing info
+ * returned in var is not valid.
+ *
+ * mode and lconfig are not modified.
+ */
+static void construct_fb_var(struct fb_var_screeninfo *var,
+			     struct fb_videomode *mode,
+			     struct davinci_layer_config *lconfig)
+{
+	fb_videomode_to_var(var, mode);
+	convert_osd_to_fb_var(lconfig, var);
+	if (lconfig->xsize != mode->xres || lconfig->ysize != mode->yres)
+		var->pixclock = 0;
+}
 
-/* All window widths have to be rounded up to a multiple of 32 bytes */
+/*
+ * Update the values in an fb_fix_screeninfo structure based on the values in an
+ * fb_var_screeninfo structure.
+ * The following members of fix are updated:
+ *	fix->visual
+ *	fix->xpanstep
+ *	fix->ypanstep
+ *	fix->ywrapstep
+ *	fix->line_length
+ * All other members of fix are unmodified.
+ */
+static void update_fix_info(const struct fb_var_screeninfo *var,
+			    struct fb_fix_screeninfo *fix)
+{
+	fix->visual =
+	    (var->bits_per_pixel >
+	     8) ? FB_VISUAL_TRUECOLOR : FB_VISUAL_PSEUDOCOLOR;
+	/*
+	 * xpanstep must correspond to a multiple of the 32-byte cache line size
+	 */
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 12:
+	case 16:
+	case 32:
+		fix->xpanstep = (8 * 32) / var->bits_per_pixel;
+		break;
+	case 24:
+		fix->xpanstep = 32;	/* 32 pixels = 3 cache lines */
+		break;
+	default:
+		fix->xpanstep = 0;
+		break;
+	}
+	fix->ypanstep = 1;
+	fix->ywrapstep = 0;
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel + 7) / 8;
+	/* line_length must be a multiple of the 32-byte cache line size */
+	fix->line_length = ((fix->line_length + 31) / 32) * 32;
+}
 
-/* The OSD0 window has to be always within VID0. Plus, since it is in RGB565
- * mode, it _cannot_ overlap with VID1.
- * For defaults, we are setting the OSD0 window to be displayed in the top
- * left quadrant of the screen, and the VID1 in the bottom right quadrant.
- * So the default 'xres' and 'yres' are set to  half of the screen width and
- * height respectively. Note however that the framebuffer size is allocated
- * for the full screen size so the user can change the 'xres' and 'yres' by
- * using the FBIOPUT_VSCREENINFO ioctl within the limits of the screen size.
+/*
+ * Determine if the window configuration specified by var will fit in a
+ * framebuffer of size fb_size.
+ * Returns 1 if the window will fit in the framebuffer, or 0 otherwise.
  */
-#define round_32(width)	((((width) + 31) / 32) * 32 )
-
-#define OSD0_XRES	round_32((DISP_XRES)*16/8) * 8/16	/* pixels */
-#define OSD0_YRES	DISP_YRES
-#define OSD0_FB_PHY	0
-#define OSD0_FB_SIZE	(round_32((DISP_XRES)*16/8) * DISP_MEMY * DOUBLE_BUF)
-
-			/* 16 bpp, Double buffered */
-static struct fb_var_screeninfo osd0_default_var = {
-	.xres = OSD0_XRES,
-	.yres = OSD0_YRES,
-	.xres_virtual = OSD0_XRES,
-	.yres_virtual = OSD0_YRES * DOUBLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 16,
-	.grayscale = 0,
-	.red = {11, 5, 0},
-	.green = {5, 6, 0},
-	.blue = {0, 5, 0},
-	.transp = {0, 0, 0},
-	.nonstd = 0,
-	.activate = FB_ACTIVATE_NOW,
-	.height = -1,
-	.width = -1,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.left_margin = 40,	/* pixclocks */
-	.right_margin = 4,	/* pixclocks */
-	.upper_margin = 8,	/* line clocks */
-	.lower_margin = 2,	/* line clocks */
-	.hsync_len = 4,		/* pixclocks */
-	.vsync_len = 2,		/* line clocks */
-	.sync = 0,
-	.vmode = FB_VMODE_INTERLACED,
-};
+static int window_will_fit_framebuffer(const struct fb_var_screeninfo *var,
+				       unsigned fb_size)
+{
+	unsigned line_length;
 
-/* Using the full screen for OSD1 by default */
-#define OSD1_XRES	round_32(DISP_XRES*4/8) * 8/4	/* pixels */
-#define OSD1_YRES	DISP_YRES
-#define OSD1_FB_PHY	0
-#define OSD1_FB_SIZE	(round_32(DISP_XRES*4/8) * DISP_MEMY * DOUBLE_BUF)
-
-static struct fb_var_screeninfo osd1_default_var = {
-	.xres = DISP_XRES,
-	.yres = OSD1_YRES,
-	.xres_virtual = OSD1_XRES,
-	.yres_virtual = OSD1_YRES * DOUBLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 4,
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.vmode = FB_VMODE_INTERLACED,
-};
+	line_length = (var->bits_per_pixel * var->xres_virtual + 7) / 8;
+	/* line length must be a multiple of the cache line size (32) */
+	line_length = ((line_length + 31) / 32) * 32;
 
-/* Using the full screen for OSD0 by default */
-#define VID0_XRES	round_32(DISP_XRES*16/8) * 8/16	/* pixels */
-#define VID0_YRES	DISP_YRES
-#define VID0_FB_PHY	0
-#define VID0_FB_SIZE	(round_32(DISP_XRES*16/8) * DISP_MEMY * TRIPLE_BUF)
-static struct fb_var_screeninfo vid0_default_var = {
-	.xres = VID0_XRES,
-	.yres = VID0_YRES,
-	.xres_virtual = VID0_XRES,
-	.yres_virtual = VID0_YRES * TRIPLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = 16,
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.vmode = FB_VMODE_INTERLACED,
-};
+	if (var->yres_virtual * line_length <= fb_size)
+		return 1;
+	else
+		return 0;
+}
 
-/* Using the bottom right quadrant of the screen screen for VID1 by default,
- * but keeping the framebuffer allocated for the full screen, so the user can
- * change the 'xres' and 'yres' later using the FBIOPUT_VSCREENINFO ioctl.
+/*
+ * FBIO_WAITFORVSYNC handler
  */
-#define VID1_BPP	16	/* Video1 can be in YUV or RGB888 format */
-#define VID1_XRES round_32(DISP_XRES*16/8) * 8/16	/* pixels */
-#define VID1_YRES DISP_YRES
-#define VID1_FB_PHY	0
-#define VID1_FB_SIZE (round_32(DISP_XRES*16/8) * DISP_MEMY * TRIPLE_BUF)
-static struct fb_var_screeninfo vid1_default_var = {
-	.xres = VID1_XRES,
-	.yres = VID1_YRES,
-	.xres_virtual = VID1_XRES,
-	.yres_virtual = VID1_YRES * TRIPLE_BUF,
-	.xoffset = 0,
-	.yoffset = 0,
-	.bits_per_pixel = VID1_BPP,
-	.activate = FB_ACTIVATE_NOW,
-	.accel_flags = 0,
-	.pixclock = LCD_PANEL_CLOCK,	/* picoseconds */
-	.vmode = FB_VMODE_INTERLACED,
-};
+static int davincifb_wait_for_vsync(struct fb_info *info)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	wait_queue_t wq;
+	unsigned long cnt;
+	int ret;
 
-#define	x_pos(w)	((w)->x)
-#define	y_pos(w)	((w)->y)
-
-static struct dmparams_t {
-	u8 output;
-	u8 format;
-	u8 windows;		/* bitmap flag based on VID0, VID1, OSD0, OSD1
-				 * definitions in header file */
-	u32 vid0_xres;
-	u32 vid0_yres;
-	u32 vid0_xpos;
-	u32 vid0_ypos;
-
-	u32 vid1_xres;
-	u32 vid1_yres;
-	u32 vid1_xpos;
-	u32 vid1_ypos;
-
-	u32 osd0_xres;
-	u32 osd0_yres;
-	u32 osd0_xpos;
-	u32 osd0_ypos;
-
-	u32 osd1_xres;
-	u32 osd1_yres;
-	u32 osd1_xpos;
-	u32 osd1_ypos;
-} dmparams = {
-	NTSC,		/* output */
-	    COMPOSITE,		/* format */
-	    (1 << VID0) | (1 << VID1) | (1 << OSD0) | (1 << OSD1),
-	    /* windows registered */
-	    720, 480, 0, 0,	/* vid0 size and position */
-	    720, 480, 0, 0,	/* vid1 size and position */
-	    720, 480, 0, 0,	/* osd0 size and position */
-	    720, 480, 0, 0,	/* osd1 size and position */
-};
+	init_waitqueue_entry(&wq, current);
+
+	cnt = win->dm->vsync_cnt;
+	ret = wait_event_interruptible_timeout(win->dm->vsync_wait,
+					       cnt != win->dm->vsync_cnt,
+					       win->dm->timeout);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -ETIMEDOUT;
 
-/* Must do checks against the limits of the output device */
-static int davincifb_venc_check_mode(const struct dm_win_info *w,
-				     const struct fb_var_screeninfo *var)
-{
 	return 0;
 }
 
-static void set_sdram_params(char *id, u32 addr, u32 line_length);
-static irqreturn_t davincifb_isr(int irq, void *arg)
+static void davincifb_vsync_callback(unsigned event, void *arg)
 {
-	struct dm_info *dm = (struct dm_info *)arg;
-	unsigned long addr=0;
-
-	if ((dispc_reg_in(VENC_VSTAT) & 0x00000010) == 0x10) {
-		xchg(&addr, dm->osd0->sdram_address);
+	struct vpbe_dm_info *dm = (struct vpbe_dm_info *)arg;
+	unsigned long addr = 0;
+	static unsigned last_event;
+
+	event &= ~DAVINCI_DISP_END_OF_FRAME;
+	if (event == last_event) {
+		/* progressive */
+		xchg(&addr, dm->win[WIN_OSD0].sdram_address);
 		if (addr) {
-			set_sdram_params(dm->osd0->info.fix.id,
-					 dm->osd0->sdram_address,
-					 dm->osd0->info.fix.line_length);
-			dm->osd0->sdram_address = 0;
+			davinci_disp_start_layer(dm->win[WIN_OSD0].layer,
+						 dm->win[WIN_OSD0].
+						 sdram_address,
+						 fb_cbcr_ofst);
+			dm->win[WIN_OSD0].sdram_address = 0;
 		}
 		addr = 0;
-		xchg(&addr, dm->osd1->sdram_address);
+		xchg(&addr, dm->win[WIN_OSD1].sdram_address);
 		if (addr) {
-			set_sdram_params(dm->osd1->info.fix.id,
-					 dm->osd1->sdram_address,
-					 dm->osd1->info.fix.line_length);
-			dm->osd1->sdram_address = 0;
+			davinci_disp_start_layer(dm->win[WIN_OSD1].layer,
+						 dm->win[WIN_OSD1].
+						 sdram_address,
+						 fb_cbcr_ofst);
+			dm->win[WIN_OSD1].sdram_address = 0;
 		}
 		addr = 0;
-		xchg(&addr, dm->vid0->sdram_address);
+		xchg(&addr, dm->win[WIN_VID0].sdram_address);
 		if (addr) {
-			set_sdram_params(dm->vid0->info.fix.id,
-					 dm->vid0->sdram_address,
-					 dm->vid0->info.fix.line_length);
-			dm->vid0->sdram_address = 0;
+			davinci_disp_start_layer(dm->win[WIN_VID0].layer,
+						 dm->win[WIN_VID0].
+						 sdram_address,
+						 fb_cbcr_ofst);
+			dm->win[WIN_VID0].sdram_address = 0;
 		}
 		addr = 0;
-		xchg(&addr, dm->vid1->sdram_address);
+		xchg(&addr, dm->win[WIN_VID1].sdram_address);
 		if (addr) {
-			set_sdram_params(dm->vid1->info.fix.id,
-					 dm->vid1->sdram_address,
-					 dm->vid1->info.fix.line_length);
-			dm->vid1->sdram_address = 0;
+			davinci_disp_start_layer(dm->win[WIN_VID1].layer,
+						 dm->win[WIN_VID1].
+						 sdram_address,
+						 fb_cbcr_ofst);
+			dm->win[WIN_VID1].sdram_address = 0;
 		}
-		return IRQ_HANDLED;
-	} else {
 		++dm->vsync_cnt;
 		wake_up_interruptible(&dm->vsync_wait);
-		return IRQ_HANDLED;
-  	}
-
-	return IRQ_HANDLED;
-}
-
-/* Wait for a vsync interrupt.  This routine sleeps so it can only be called
- * from process context.
- */
-static int davincifb_wait_for_vsync(struct dm_win_info *w)
-{
-	struct dm_info *dm = w->dm;
-	wait_queue_t wq;
-	unsigned long cnt;
-	int ret;
-
-	init_waitqueue_entry(&wq, current);
-
-	cnt = dm->vsync_cnt;
-	ret = wait_event_interruptible_timeout(dm->vsync_wait,
-					       cnt != dm->vsync_cnt,
-					       dm->timeout);
-	if (ret < 0)
-		return (ret);
-	if (ret == 0)
-		return (-ETIMEDOUT);
-
-	return (0);
+	} else {
+		/* interlaced */
+		if (event & DAVINCI_DISP_SECOND_FIELD) {
+			xchg(&addr, dm->win[WIN_OSD0].sdram_address);
+			if (addr) {
+				davinci_disp_start_layer(dm->win[WIN_OSD0].
+							 layer,
+							 dm->win[WIN_OSD0].
+							 sdram_address,
+							 fb_cbcr_ofst);
+				dm->win[WIN_OSD0].sdram_address = 0;
+			}
+			addr = 0;
+			xchg(&addr, dm->win[WIN_OSD1].sdram_address);
+			if (addr) {
+				davinci_disp_start_layer(dm->win[WIN_OSD1].
+							 layer,
+							 dm->win[WIN_OSD1].
+							 sdram_address,
+							 fb_cbcr_ofst);
+				dm->win[WIN_OSD1].sdram_address = 0;
+			}
+			addr = 0;
+			xchg(&addr, dm->win[WIN_VID0].sdram_address);
+			if (addr) {
+				davinci_disp_start_layer(dm->win[WIN_VID0].
+							 layer,
+							 dm->win[WIN_VID0].
+							 sdram_address,
+							 fb_cbcr_ofst);
+				dm->win[WIN_VID0].sdram_address = 0;
+			}
+			addr = 0;
+			xchg(&addr, dm->win[WIN_VID1].sdram_address);
+			if (addr) {
+				davinci_disp_start_layer(dm->win[WIN_VID1].
+							 layer,
+							 dm->win[WIN_VID1].
+							 sdram_address,
+							 fb_cbcr_ofst);
+				dm->win[WIN_VID1].sdram_address = 0;
+			}
+		} else {
+			++dm->vsync_cnt;
+			wake_up_interruptible(&dm->vsync_wait);
+		}
+	}
+	last_event = event;
 }
 
-/* Sets a uniform attribute value over a rectangular area on the attribute
- * window. The attribute value (0 to 7) is passed through the fb_fillrect's
- * color parameter.
+/*
+ * FBIO_SETATTRIBUTE handler
+ *
+ * This ioctl is deprecated.  The user can write the attribute values directly
+ * to the OSD1 framebuffer.
+ *
+ * Set a uniform attribute value over a rectangular area on the attribute
+ * window. The attribute value (0 to 15) is passed through the fb_fillrect's
+ * color parameter.  r->dx and r->width must both be even.  If not, they are
+ * rounded down.
  */
-static int davincifb_set_attr_blend(struct fb_fillrect *r)
+static int vpbe_set_attr_blend(struct fb_info *info, struct fb_fillrect *r)
 {
-	struct fb_info *info = &dm->osd1->info;
-	struct fb_var_screeninfo *var = &dm->osd1->info.var;
-	unsigned long start = 0;
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	char __iomem *start;
 	u8 blend;
 	u32 width_bytes;
 
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	if (!is_attribute_mode(var))
+		return -EINVAL;
+
 	if (r->dx + r->width > var->xres_virtual)
 		return -EINVAL;
 	if (r->dy + r->height > var->yres_virtual)
 		return -EINVAL;
-	if (r->color < 0 || r->color > 7)
+	if (r->color > 15)
 		return -EINVAL;
 
-	/* since bits_per_pixel = 4, this will truncate the width if it is
-	 * not even. Similarly r->dx will be rounded down to an even pixel.
-	 * ... Do we want to return an error otherwise?
-	 */
-	width_bytes = r->width * var->bits_per_pixel / 8;
-	start = dm->osd1->fb_base + r->dy * info->fix.line_length
-	    + r->dx * var->bits_per_pixel / 8;
+	width_bytes = (r->width * var->bits_per_pixel) / 8;
+	start =
+	    info->screen_base + r->dy * info->fix.line_length +
+	    (r->dx * var->bits_per_pixel) / 8;
 
 	blend = (((u8) r->color & 0xf) << 4) | ((u8) r->color);
 	while (r->height--) {
+		memset(start, blend, width_bytes);
 		start += info->fix.line_length;
-		memset((void *)start, blend, width_bytes);
 	}
 
 	return 0;
 }
 
-/* These position parameters are given through fb_var_screeninfo.
- * xp = var.reserved[0], yp = var.reserved[1],
- * xl = var.xres, yl = var.yres
+/*
+ * FBIO_SETPOSX handler
  */
-static void set_win_position(char *id, u32 xp, u32 yp, u32 xl, u32 yl)
+static int vpbe_setposx(struct fb_info *info, unsigned xpos)
 {
-	int i = 0;
-
-	if (is_win(id, VID0)) {
-		i = 0;
-	} else if (is_win(id, VID1)) {
-		i = 1;
-	} else if (is_win(id, OSD0)) {
-		i = 2;
-	} else if (is_win(id, OSD1)) {
-		i = 3;
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_xpos = win->xpos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->xpos = xpos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->xpos = old_xpos;
+		return retval;
 	}
 
-	dispc_reg_out(OSD_WINXP(i), xp);
-	dispc_reg_out(OSD_WINYP(i), yp);
-	dispc_reg_out(OSD_WINXL(i), xl);
-	dispc_reg_out(OSD_WINYL(i), yl);
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
 }
 
-static inline void get_win_position(struct dm_win_info *w,
-				    u32 * xp, u32 * yp, u32 * xl, u32 * yl)
+/*
+ * FBIO_SETPOSY handler
+ */
+static int vpbe_setposy(struct fb_info *info, unsigned ypos)
 {
-	struct fb_var_screeninfo *v = &w->info.var;
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_ypos = win->ypos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->ypos = ypos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->ypos = old_ypos;
+		return retval;
+	}
 
-	*xp = x_pos(w);
-	*yp = y_pos(w);
-	*xl = v->xres;
-	*yl = v->yres;
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
 }
 
-/* Returns 1 if the windows overlap, 0 otherwise */
-static int window_overlap(struct dm_win_info *w, u32 xp, u32 yp, u32 xl, u32 yl)
+/*
+ * FBIO_SETZOOM handler
+ */
+static int vpbe_set_zoom(struct fb_info *info, struct zoom_params *zoom)
 {
-	u32 _xp = 0, _yp = 0, _xl = 0, _yl = 0;
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_zoom_factor h_zoom, v_zoom;
 
-#define OVERLAP(x1, y1, x2, y2, x3, y3, x4, y4)		\
-(!(	((x1)<(x3) && (x2)<(x3)) || ((x1)>(x4) && (x2)>(x4)) ||	\
-	((y1)<(y3) && (y2)<(y3)) || ((y1)>(y4) && (y2)>(y4)) )	\
-)
+	if (!win->own_window)
+		return -ENODEV;
 
-	if (!w)
-		return (0);
+	switch (zoom->zoom_h) {
+	case 0:
+		h_zoom = ZOOM_X1;
+		break;
+	case 1:
+		h_zoom = ZOOM_X2;
+		break;
+	case 2:
+		h_zoom = ZOOM_X4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (zoom->zoom_v) {
+	case 0:
+		v_zoom = ZOOM_X1;
+		break;
+	case 1:
+		v_zoom = ZOOM_X2;
+		break;
+	case 2:
+		v_zoom = ZOOM_X4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	davinci_disp_set_zoom(win->layer, h_zoom, v_zoom);
+
+	return 0;
+}
+
+/*
+ * FBIO_ENABLE_DISABLE_WIN handler
+ *
+ * This ioctl is deprecated.  Use the standard FBIOBLANK ioctl instead.
+ */
+static int vpbe_enable_disable_win(struct fb_info *info, int enable)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	int retval = 0;
 
-	get_win_position(w, &_xp, &_yp, &_xl, &_yl);
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (enable) {
+		win->display_window = 1;
+		retval = info->fbops->fb_check_var(&info->var, info);
+		if (retval)
+			return retval;
+		retval = info->fbops->fb_set_par(info);
+	} else {
+		win->display_window = 0;
+		davinci_disp_disable_layer(win->layer);
+	}
 
-	return (OVERLAP(xp, yp, xp + xl, yp + yl,
-		       _xp, _yp, _xp + _xl, _yp + _yl));
-#undef OVERLAP
+	return retval;
 }
 
-/* Returns 1 if the window parameters are within VID0, 0 otherwise */
-static int within_vid0_limits(u32 xp, u32 yp, u32 xl, u32 yl)
+/*
+ * FBIO_SET_BITMAP_BLEND_FACTOR handler
+ */
+static int vpbe_bitmap_set_blend_factor(struct fb_info *info, struct vpbe_bitmap_blend_params
+					*blend_para)
 {
-	u32 vid0_xp = 0, vid0_yp = 0, vid0_xl = 0, vid0_yl = 0;
-
-	if (!dm->vid0)
-		return (1);
-	get_win_position(dm->vid0, &vid0_xp, &vid0_yp, &vid0_xl, &vid0_yl);
-	if ((xp >= vid0_xp) && (yp >= vid0_yp) &&
-	    (xp + xl <= vid0_xp + vid0_xl) && (yp + yl <= vid0_yp + vid0_yl))
-		return (1);
-	return (0);
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	if (blend_para->bf > OSD_8_VID_0)
+		return -EINVAL;
+
+	davinci_disp_set_blending_factor(osdwin, blend_para->bf);
+	if (blend_para->enable_colorkeying)
+		davinci_disp_enable_color_key(osdwin, blend_para->colorkey);
+	else
+		davinci_disp_disable_color_key(osdwin);
+
+	return 0;
 }
 
-/* VID0 must be large enough to hold all other windows */
-static int check_new_vid0_size(u32 xp0, u32 yp0, u32 xl0, u32 yl0)
+/*
+ * FBIO_SET_BITMAP_WIN_RAM_CLUT handler
+ *
+ * This ioctl is deprecated.  Use the standard framebuffer ioctl FBIOPUTCMAP
+ * instead.  Note that FBIOPUTCMAP colors are expressed in RGB space instead of
+ * YCbCr space.
+ */
+static int vpbe_bitmap_set_ram_clut(struct fb_info *info,
+				    unsigned char ram_clut[256][3])
 {
-	u32 _xp = 0, _yp = 0, _xl = 0, _yl = 0;
-#define WITHIN_LIMITS 				\
-	((_xp >= xp0) && (_yp >= yp0) &&	\
-	(_xp + _xl <= xp0 + xl0) && (_yp + _yl <= yp0 + yl0))
-
-	if (dm->osd0) {
-		get_win_position(dm->osd0, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS)
-			return (-EINVAL);
-	}
-	if (dm->osd1) {
-		get_win_position(dm->osd1, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS)
-			return (-EINVAL);
-	}
-	if (dm->vid1) {
-		get_win_position(dm->vid1, &_xp, &_yp, &_xl, &_yl);
-		if (!WITHIN_LIMITS)
-			return (-EINVAL);
-	}
-	return (0);
+	int i;
 
-#undef WITHIN_LIMITS
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	for (i = 0; i < 256; i++) {
+		davinci_disp_set_clut_ycbcr(i, ram_clut[i][0], ram_clut[i][1],
+					    ram_clut[i][2]);
+	}
+	return 0;
 }
 
-/**
- *      davincifb_check_var - Validates a var passed in.
- *      @var: frame buffer variable screen structure
- *      @info: frame buffer structure that represents a single frame buffer
+/*
+ * FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN handler
+ *
+ * This ioctl is deprecated.  Attribute mode can be enabled via the standard
+ * framebuffer ioctl FBIOPUT_VSCREENINFO by setting var->bits_per_pixel to 4
+ * and var->nonstd to a non-zero value.  Attribute mode can be disabled by using
+ * FBIOPUT_VSCREENINFO to set a standard pixel format.
  *
- *	Checks to see if the hardware supports the state requested by
- *	var passed in. This function does not alter the hardware state!!!
- *	This means the data stored in struct fb_info and struct xxx_par do
- *      not change. This includes the var inside of struct fb_info.
- *	Do NOT change these. This function can be called on its own if we
- *	intent to only test a mode and not actually set it.
- *	If the var passed in is slightly off by what the hardware can support
- *	then we alter the var PASSED in to what we can do.
+ * The enabled/disabled status of OSD1 is unchanged by this ioctl.  To avoid
+ * display glitches, you should disable OSD1 prior to calling this ioctl.
  *
- *	Returns negative errno on error, or zero on success.
+ * When enabling attribute mode, var->bits_per_pixel is set to 4.  var->xres,
+ * var->yres, var->xres_virtual, var->yres_virtual, win->xpos, and win->ypos are
+ * all copied from OSD0.  var->xoffset and var->yoffset are set to 0.
+ * fix->line_length is updated to be consistent with 4 bits per pixel.  No
+ * changes are made to the OSD1 configuration if OSD1 is already in attribute
+ * mode.
+ *
+ * When disabling attribute mode, the window geometry is unchanged.
+ * var->bits_per_pixel remains set to 4.  No changes are made to the OSD1
+ * configuration if OSD1 is not in attribute mode.
  */
-static int davincifb_check_var(struct fb_var_screeninfo *var,
-			       struct fb_info *info)
+static int vpbe_enable_disable_attribute_window(struct fb_info *info, u32 flag)
 {
-	const struct dm_win_info *w = (const struct dm_win_info *)info->par;
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
 	struct fb_var_screeninfo v;
+	struct davinci_layer_config lconfig;
+	int retval;
 
-/* Rules:
- * 1) Vid1, OSD0, OSD1 and Cursor must be fully contained inside of Vid0.
- * 2) Vid0 and Vid1 are both set to accept YUV 4:2:2 (for now).
- * 3) OSD window data is always packed into 32-bit words and left justified.
- * 4) Each horizontal line of window data must be a multiple of 32 bytes.
- *    32 bytes = 32 bytes / 2 bytes per pixel = 16 pixels.
- *    This implies that 'xres' must be a multiple of 32 bytes.
- * 5) The offset registers hold the distance between the start of one line and
- *    the start of the next. This offset value must be a multiple of 32 bytes.
- *    This implies that 'xres_virtual' is also a multiple of 32 bytes. Note
- *    that 'xoffset' needn't be a multiple of 32 bytes.
- * 6) OSD0 is set to accept RGB565.
- * 	dispc_reg_merge(OSD_OSDWIN0ND, OSD_OSDWIN0ND_RGB0E, OSD_OSDWIN0ND_RGB0E)
- * 7) OSD1 is set to be the attribute window.
- * 8) Vid1 startX = Vid0 startX + N * 16 pixels (32 bytes)
- * 9) Vid1 width = (16*N - 8) pixels
- * 10) When one of the OSD windows is in RGB565, it cannot overlap with Vid1.
- * 11) Vid1 start X position must be offset a multiple of 16 pixels from the
- * left edge of Vid0.
- */
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
 
+	/* return with no error if there is nothing to do */
+	if ((is_attribute_mode(var) && flag)
+	    || (!is_attribute_mode(var) && !flag))
+		return 0;
+
+	/* start with the current OSD1 var */
 	memcpy(&v, var, sizeof(v));
-	return (0);
-
-	/* do board-specific checks on the var */
-	if (davincifb_venc_check_mode(w, &v))
-		return (-EINVAL);
-
-	if (v.xres_virtual < v.xres || v.yres_virtual < v.yres)
-		return (-EINVAL);
-	if (v.xoffset > v.xres_virtual - v.xres)
-		return (-EINVAL);
-	if (v.yoffset > v.yres_virtual - v.yres)
-		return (-EINVAL);
-	if ((v.xres * v.bits_per_pixel / 8) % 32 || (v.xres_virtual * v.bits_per_pixel / 8) % 32)	/* Rules 4, 5 */
-		return (-EINVAL);
-	if (v.xres_virtual * v.yres_virtual * v.bits_per_pixel / 8 > w->fb_size)
-		return (-EINVAL);
-
-	if (!is_win(info->fix.id, VID0)) {
-		/* Rule 1 */
-		if (!within_vid0_limits(x_pos(w), y_pos(w), v.xres, v.yres))
-			return (-EINVAL);
+
+	if (flag) {		/* enable attribute mode */
+		const struct vpbe_dm_win_info *osd0 = &win->dm->win[WIN_OSD0];
+		const struct fb_var_screeninfo *osd0_var = &osd0->info->var;
+		unsigned old_xpos = win->xpos;
+		unsigned old_ypos = win->ypos;
+		/* get the OSD0 window configuration */
+		convert_fb_var_to_osd(osd0_var, &lconfig, win->dm->yc_pixfmt);
+		/* change the pixfmt to attribute mode */
+		lconfig.pixfmt = PIXFMT_OSD_ATTR;
+		/* update the var for OSD1 */
+		convert_osd_to_fb_var(&lconfig, &v);
+		/* copy xres_virtual and yres_virtual from OSD0 */
+		v.xres_virtual = osd0_var->xres_virtual;
+		v.yres_virtual = osd0_var->yres_virtual;
+		/* zero xoffset and yoffset */
+		v.xoffset = 0;
+		v.yoffset = 0;
+		/* copy xpos and ypos from OSD0 */
+		win->xpos = osd0->xpos;
+		win->ypos = osd0->ypos;
+
+		retval = info->fbops->fb_check_var(&v, info);
+		if (retval) {
+			win->xpos = old_xpos;
+			win->ypos = old_ypos;
+			return retval;
+		}
+
+		/*
+		 * Enable attribute mode by replacing info->var and calling
+		 * the fb_set_par method to activate it.
+		 */
+		memcpy(var, &v, sizeof(v));
+		retval = info->fbops->fb_set_par(info);
+	} else {		/* disable attribute mode */
+		/* get the current OSD1 window configuration */
+		convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
+		/* change the pixfmt to 4-bits-per-pixel bitmap */
+		lconfig.pixfmt = PIXFMT_4BPP;
+		/* update the var for OSD1 */
+		convert_osd_to_fb_var(&lconfig, &v);
+
+		retval = info->fbops->fb_check_var(&v, info);
+		if (retval)
+			return retval;
+
+		/*
+		 * Disable attribute mode by replacing info->var and calling
+		 * the fb_set_par method to activate it.
+		 */
+		memcpy(var, &v, sizeof(v));
+		retval = info->fbops->fb_set_par(info);
 	}
-	if (is_win(info->fix.id, OSD0)) {
-		/* Rule 10 */
-		if (window_overlap(w->dm->vid1,
-				   x_pos(w), y_pos(w), v.xres, v.yres))
-			return (-EINVAL);
-		/* Rule 5 */
-		v.bits_per_pixel = 16;
-		v.red.offset = 11;
-		v.green.offset = 5;
-		v.blue.offset = 0;
-		v.red.length = 5;
-		v.green.length = 6;
-		v.blue.length = 5;
-		v.transp.offset = v.transp.length = 0;
-		v.red.msb_right = v.green.msb_right = v.blue.msb_right
-		    = v.transp.msb_right = 0;
-		v.nonstd = 0;
-		v.accel_flags = 0;
-	} else if (is_win(info->fix.id, OSD1)) {
-		v.bits_per_pixel = 4;
-	} else if (is_win(info->fix.id, VID0)) {
-		if (check_new_vid0_size(x_pos(w), y_pos(w), v.xres, v.yres))
-			return (-EINVAL);
-		v.bits_per_pixel = 16;
-	} else if (is_win(info->fix.id, VID1)) {
-		/* Rule 11 */
-		if ((x_pos(w->dm->vid0) - x_pos(w)) % 16)
-			return (-EINVAL);
-		/* Video1 may be in YUV or RGB888 format */
-		if ((v.bits_per_pixel != 16) && (v.bits_per_pixel != 32))
-			return (-EINVAL);
-	} else
-		return (-EINVAL);
 
-	memcpy(var, &v, sizeof(v));
-	return (0);
+	return retval;
+}
+
+/*
+ * FBIO_GET_BLINK_INTERVAL handler
+ */
+static int vpbe_get_blinking(struct fb_info *info,
+			     struct vpbe_blink_option *blink_option)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_blink_interval blink;
+	int enabled;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	davinci_disp_get_blink_attribute(&enabled, &blink);
+	blink_option->blinking = enabled;
+	blink_option->interval = blink;
+
+	return 0;
 }
 
-/* Interlaced = Frame mode, Non-interlaced = Field mode */
-static void set_interlaced(char *id, unsigned int on)
+/*
+ * FBIO_SET_BLINK_INTERVAL handler
+ */
+static int vpbe_set_blinking(struct fb_info *info,
+			     struct vpbe_blink_option *blink_option)
 {
-	on = (on == 0) ? 0 : ~0;
-
-	if (is_win(id, VID0))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_VFF0);
-	else if (is_win(id, VID1))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_VFF1);
-	else if (is_win(id, OSD0))
-		dispc_reg_merge(OSD_OSDWIN0MD, on, OSD_OSDWIN0MD_OFF0);
-	else if (is_win(id, OSD1))
-		dispc_reg_merge(OSD_OSDWIN1MD, on, OSD_OSDWIN1MD_OFF1);
+	struct vpbe_dm_win_info *win = info->par;
+
+	if (win->layer != WIN_OSD1)
+		return -EINVAL;
+
+	if (blink_option->interval > BLINK_X4)
+		return -EINVAL;
+
+	davinci_disp_set_blink_attribute(blink_option->blinking,
+					 blink_option->interval);
+
+	return 0;
 }
 
-/* For zooming, we just have to set the start of framebuffer, the zoom factors
- * and the display size. The hardware will then read only
- * (display size / zoom factor) area of the framebuffer and  zoom and
- * display it. In the following function, we assume that the start of
- * framebuffer and the display size parameters are set already.
+/*
+ * FBIO_GET_VIDEO_CONFIG_PARAMS handler
+ *
+ * Despite the name, this ioctl can be used on both video windows and OSD
+ * (bitmap) windows.
  */
-static void set_zoom(int WinID, int h_factor, int v_factor)
+static int vpbe_get_vid_params(struct fb_info *info,
+			       struct vpbe_video_config_params *vid_conf_params)
 {
-	switch (WinID) {
-	case 0:		//VID0
-		dispc_reg_merge(OSD_VIDWINMD,
-				h_factor << OSD_VIDWINMD_VHZ0_SHIFT,
-				OSD_VIDWINMD_VHZ0);
-		dispc_reg_merge(OSD_VIDWINMD,
-				v_factor << OSD_VIDWINMD_VVZ0_SHIFT,
-				OSD_VIDWINMD_VVZ0);
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (is_vid_win(info))
+		davinci_disp_get_vid_expansion(&h_exp, &v_exp);
+	else
+		davinci_disp_get_osd_expansion(&h_exp, &v_exp);
+
+	vid_conf_params->cb_cr_order =
+	    (win->dm->yc_pixfmt == PIXFMT_YCbCrI) ? 0 : 1;
+	vid_conf_params->exp_info.horizontal = h_exp;
+	vid_conf_params->exp_info.vertical = v_exp;
+
+	return 0;
+}
+
+/*
+ * FBIO_SET_VIDEO_CONFIG_PARAMS handler
+ *
+ * Despite the name, this ioctl can be used on both video windows and OSD
+ * (bitmap) windows.
+ *
+ * NOTE: If the cb_cr_order is changed, it won't take effect until an
+ * FBIOPUT_VSCREENINFO ioctl is executed on a window with a YC pixel format.
+ */
+static int vpbe_set_vid_params(struct fb_info *info,
+			       struct vpbe_video_config_params *vid_conf_params)
+{
+	struct vpbe_dm_win_info *win = info->par;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	if (vid_conf_params->exp_info.horizontal > H_EXP_3_OVER_2)
+		return -EINVAL;
+
+	if (vid_conf_params->exp_info.vertical > V_EXP_6_OVER_5)
+		return -EINVAL;
+
+	win->dm->yc_pixfmt =
+	    vid_conf_params->cb_cr_order ? PIXFMT_YCrCbI : PIXFMT_YCbCrI;
+
+	h_exp = vid_conf_params->exp_info.horizontal;
+	v_exp = vid_conf_params->exp_info.vertical;
+	if (is_vid_win(info))
+		davinci_disp_set_vid_expansion(h_exp, v_exp);
+	else
+		davinci_disp_set_osd_expansion(h_exp, v_exp);
+
+	return 0;
+}
+
+/*
+ * FBIO_GET_BITMAP_CONFIG_PARAMS handler
+ */
+static int vpbe_bitmap_get_params(struct fb_info *info, struct vpbe_bitmap_config_params
+				  *bitmap_conf_params)
+{
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+	enum davinci_clut clut;
+
+	if (!is_osd_win(info))
+		return -EINVAL;
+
+	clut = davinci_disp_get_osd_clut(osdwin);
+	if (clut == ROM_CLUT)
+		bitmap_conf_params->clut_select = davinci_disp_get_rom_clut();
+	else
+		bitmap_conf_params->clut_select = 2;
+
+	bitmap_conf_params->attenuation_enable =
+	    davinci_disp_get_rec601_attenuation(osdwin);
+
+	memset(&bitmap_conf_params->clut_idx, 0,
+	       sizeof(bitmap_conf_params->clut_idx));
+
+	switch (info->var.bits_per_pixel) {
+	case 1:
+		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_1bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
 		break;
-	case 1:		//VID1
-		dispc_reg_merge(OSD_VIDWINMD,
-				h_factor << OSD_VIDWINMD_VHZ1_SHIFT,
-				OSD_VIDWINMD_VHZ1);
-		dispc_reg_merge(OSD_VIDWINMD,
-				v_factor << OSD_VIDWINMD_VVZ1_SHIFT,
-				OSD_VIDWINMD_VVZ1);
+	case 2:
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_2 =
+		    davinci_disp_get_palette_map(osdwin, 2);
+		bitmap_conf_params->clut_idx.for_2bit_bitmap.bitmap_val_3 =
+		    davinci_disp_get_palette_map(osdwin, 3);
 		break;
-	case 2:		//OSD0
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				h_factor << OSD_OSDWIN0MD_OHZ0_SHIFT,
-				OSD_OSDWIN0MD_OHZ0);
-		dispc_reg_merge(OSD_OSDWIN0MD,
-				v_factor << OSD_OSDWIN0MD_OVZ0_SHIFT,
-				OSD_OSDWIN0MD_OVZ0);
+	case 4:
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_0 =
+		    davinci_disp_get_palette_map(osdwin, 0);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_1 =
+		    davinci_disp_get_palette_map(osdwin, 1);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_2 =
+		    davinci_disp_get_palette_map(osdwin, 2);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_3 =
+		    davinci_disp_get_palette_map(osdwin, 3);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_4 =
+		    davinci_disp_get_palette_map(osdwin, 4);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_5 =
+		    davinci_disp_get_palette_map(osdwin, 5);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_6 =
+		    davinci_disp_get_palette_map(osdwin, 6);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_7 =
+		    davinci_disp_get_palette_map(osdwin, 7);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_8 =
+		    davinci_disp_get_palette_map(osdwin, 8);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_9 =
+		    davinci_disp_get_palette_map(osdwin, 9);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_10 =
+		    davinci_disp_get_palette_map(osdwin, 10);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_11 =
+		    davinci_disp_get_palette_map(osdwin, 11);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_12 =
+		    davinci_disp_get_palette_map(osdwin, 12);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_13 =
+		    davinci_disp_get_palette_map(osdwin, 13);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_14 =
+		    davinci_disp_get_palette_map(osdwin, 14);
+		bitmap_conf_params->clut_idx.for_4bit_bitmap.bitmap_val_15 =
+		    davinci_disp_get_palette_map(osdwin, 15);
 		break;
-	case 3:
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				h_factor << OSD_OSDWIN1MD_OHZ1_SHIFT,
-				OSD_OSDWIN1MD_OHZ1);
-		dispc_reg_merge(OSD_OSDWIN1MD,
-				v_factor << OSD_OSDWIN1MD_OVZ1_SHIFT,
-				OSD_OSDWIN1MD_OVZ1);
+	default:
 		break;
 	}
+
+	return 0;
 }
 
-/* Chooses the ROM CLUT for now. Can be extended later. */
-static void set_bg_color(u8 clut, u8 color_offset)
+/*
+ * FBIO_SET_BITMAP_CONFIG_PARAMS handler
+ *
+ * The palette map is ignored unless the color depth is set to 1, 2, or 4 bits
+ * per pixel.  A default palette map is supplied for these color depths where
+ * the clut index is equal to the pixel value.  It is not necessary to change
+ * the default palette map when using the RAM clut, because the RAM clut values
+ * can be changed.  It is only necessary to modify the default palette map when
+ * using a ROM clut.
+ */
+static int vpbe_bitmap_set_params(struct fb_info *info, struct vpbe_bitmap_config_params
+				  *bitmap_conf_params)
 {
-	clut = 0;		/* 0 = ROM, 1 = RAM */
+	enum davinci_osd_layer osdwin = fb_info_to_osd_enum(info);
+	enum davinci_clut clut = ROM_CLUT;
 
-	dispc_reg_merge(OSD_MODE, OSD_MODE_BCLUT & clut, OSD_MODE_BCLUT);
-	dispc_reg_merge(OSD_MODE, color_offset << OSD_MODE_CABG_SHIFT,
-			OSD_MODE_CABG);
-}
+	if (!is_osd_win(info))
+		return -EINVAL;
 
-static void set_sdram_params(char *id, u32 addr, u32 line_length)
-{
-	/* The parameters to be written to the registers should be in
-	 * multiple of 32 bytes
-	 */
-	addr = addr;		/* div by 32 */
-	line_length = line_length / 32;
-
-	if (is_win(id, VID0)) {
-		dispc_reg_out(OSD_VIDWIN0ADR, addr);
-		dispc_reg_out(OSD_VIDWIN0OFST, line_length);
-	} else if (is_win(id, VID1)) {
-		dispc_reg_out(OSD_VIDWIN1ADR, addr);
-		dispc_reg_out(OSD_VIDWIN1OFST, line_length);
-	} else if (is_win(id, OSD0)) {
-		dispc_reg_out(OSD_OSDWIN0ADR, addr);
-		dispc_reg_out(OSD_OSDWIN0OFST, line_length);
-	} else if (is_win(id, OSD1)) {
-		dispc_reg_out(OSD_OSDWIN1ADR, addr);
-		dispc_reg_out(OSD_OSDWIN1OFST, line_length);
+	if (bitmap_conf_params->clut_select == 0)
+		davinci_disp_set_rom_clut(ROM_CLUT0);
+	else if (bitmap_conf_params->clut_select == 1)
+		davinci_disp_set_rom_clut(ROM_CLUT1);
+	else if (bitmap_conf_params->clut_select == 2)
+		clut = RAM_CLUT;
+	else
+		return -EINVAL;
+
+	davinci_disp_set_osd_clut(osdwin, clut);
+	davinci_disp_set_rec601_attenuation(osdwin,
+					    bitmap_conf_params->
+					    attenuation_enable);
+
+	switch (info->var.bits_per_pixel) {
+	case 1:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_1bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_1bit_bitmap.bitmap_val_1);
+		break;
+	case 2:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_1);
+		davinci_disp_set_palette_map(osdwin, 2,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_2);
+		davinci_disp_set_palette_map(osdwin, 3,
+					     bitmap_conf_params->clut_idx.
+					     for_2bit_bitmap.bitmap_val_3);
+		break;
+	case 4:
+		davinci_disp_set_palette_map(osdwin, 0,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_0);
+		davinci_disp_set_palette_map(osdwin, 1,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_1);
+		davinci_disp_set_palette_map(osdwin, 2,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_2);
+		davinci_disp_set_palette_map(osdwin, 3,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_3);
+		davinci_disp_set_palette_map(osdwin, 4,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_4);
+		davinci_disp_set_palette_map(osdwin, 5,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_5);
+		davinci_disp_set_palette_map(osdwin, 6,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_6);
+		davinci_disp_set_palette_map(osdwin, 7,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_7);
+		davinci_disp_set_palette_map(osdwin, 8,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_8);
+		davinci_disp_set_palette_map(osdwin, 9,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_9);
+		davinci_disp_set_palette_map(osdwin, 10,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_10);
+		davinci_disp_set_palette_map(osdwin, 11,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_11);
+		davinci_disp_set_palette_map(osdwin, 12,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_12);
+		davinci_disp_set_palette_map(osdwin, 13,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_13);
+		davinci_disp_set_palette_map(osdwin, 14,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_14);
+		davinci_disp_set_palette_map(osdwin, 15,
+					     bitmap_conf_params->clut_idx.
+					     for_4bit_bitmap.bitmap_val_15);
+		break;
+	default:
+		break;
 	}
+
+	return 0;
 }
 
-static void set_win_enable(char *id, unsigned int on)
+/*
+ * FBIO_SET_BACKG_COLOR handler
+ */
+static int vpbe_set_backg_color(struct fb_info *info,
+				struct vpbe_backg_color *backg_color)
 {
-	on = (on == 0) ? 0 : ~0;
-
-	if (is_win(id, VID0))
-		/* Turning off VID0 use due to field inversion issue */
-		dispc_reg_merge(OSD_VIDWINMD, 0, OSD_VIDWINMD_ACT0);
-	else if (is_win(id, VID1))
-		dispc_reg_merge(OSD_VIDWINMD, on, OSD_VIDWINMD_ACT1);
-	else if (is_win(id, OSD0))
-		dispc_reg_merge(OSD_OSDWIN0MD, on, OSD_OSDWIN0MD_OACT0);
-	else if (is_win(id, OSD1)) {
-		/* The OACT1 bit is applicable only if OSD1 is not used as
-		 * the attribute window
-		 */
-		if (!(dispc_reg_in(OSD_OSDWIN1MD) & OSD_OSDWIN1MD_OASW))
-			dispc_reg_merge(OSD_OSDWIN1MD, on, OSD_OSDWIN1MD_OACT1);
-	}
+	enum davinci_clut clut = ROM_CLUT;
+
+	if (backg_color->clut_select == 0)
+		davinci_disp_set_rom_clut(ROM_CLUT0);
+	else if (backg_color->clut_select == 1)
+		davinci_disp_set_rom_clut(ROM_CLUT1);
+	else if (backg_color->clut_select == 2)
+		clut = RAM_CLUT;
+	else
+		return -EINVAL;
+
+	davinci_disp_set_background(clut, backg_color->color_offset);
+
+	return 0;
 }
 
-static void set_win_mode(char *id)
+/*
+ * FBIO_SETPOS handler
+ */
+static int vpbe_setpos(struct fb_info *info,
+		       struct vpbe_window_position *win_pos)
 {
-	if (is_win(id, VID0)) ;
-	else if (is_win(id, VID1)) {
-		if (dm->vid1->info.var.bits_per_pixel == 32)
-			dispc_reg_merge(OSD_MISCCT, ~0,
-					OSD_MISCCT_RGBWIN | OSD_MISCCT_RGBEN);
-	} else if (is_win(id, OSD0))
-		/* Set RGB565 mode */
-		dispc_reg_merge(OSD_OSDWIN0MD, OSD_OSDWIN0MD_RGB0E,
-				OSD_OSDWIN0MD_RGB0E);
-	else if (is_win(id, OSD1)) {
-		/* Set as attribute window */
-		dispc_reg_merge(OSD_OSDWIN1MD, OSD_OSDWIN1MD_OASW,
-				OSD_OSDWIN1MD_OASW);
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct fb_var_screeninfo v;
+	unsigned old_xpos = win->xpos;
+	unsigned old_ypos = win->ypos;
+	int retval;
+
+	if (!win->own_window)
+		return -ENODEV;
+
+	memcpy(&v, var, sizeof(v));
+	win->xpos = win_pos->xpos;
+	win->ypos = win_pos->ypos;
+	retval = info->fbops->fb_check_var(&v, info);
+	if (retval) {
+		win->xpos = old_xpos;
+		win->ypos = old_ypos;
+		return retval;
 	}
 
+	/* update the window position */
+	memcpy(var, &v, sizeof(v));
+	retval = info->fbops->fb_set_par(info);
+
+	return retval;
 }
 
-/**
- *      davincifb_set_par - Optional function. Alters the hardware state.
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *	Using the fb_var_screeninfo in fb_info we set the resolution of the
- *	this particular framebuffer. This function alters the par AND the
- *	fb_fix_screeninfo stored in fb_info. It doesn't not alter var in
- *	fb_info since we are using that data. This means we depend on the
- *	data in var inside fb_info to be supported by the hardware.
- *	davincifb_check_var is always called before dmfb_set_par to ensure this.
- *	Again if you can't can't the resolution you don't need this function.
- *
+/*
+ * FBIO_SET_CURSOR handler
  */
-static int davincifb_set_par(struct fb_info *info)
+static int vpbe_set_cursor_params(struct fb_info *info,
+				  struct fb_cursor *fbcursor)
 {
-	struct dm_win_info *w = (struct dm_win_info *)info->par;
-	struct fb_var_screeninfo *v = &info->var;
-	u32 start = 0, offset = 0;
+	struct davinci_cursor_config cursor;
 
-	info->fix.line_length = v->xres_virtual * v->bits_per_pixel / 8;
+	if (!fbcursor->enable) {
+		davinci_disp_cursor_disable();
+		return 0;
+	}
+
+	cursor.xsize = fbcursor->image.width;
+	cursor.ysize = fbcursor->image.height;
+	cursor.xpos = fbcursor->image.dx;
+	cursor.ypos = fbcursor->image.dy;
+	cursor.interlaced = is_window_interlaced(&info->var);
+	cursor.h_width =
+	    (fbcursor->image.depth > 7) ? 7 : fbcursor->image.depth;
+	cursor.v_width = cursor.h_width;
+	cursor.clut = ROM_CLUT;
+	cursor.clut_index = fbcursor->image.fg_color;
 
-	offset = v->yoffset * info->fix.line_length +
-	    v->xoffset * v->bits_per_pixel / 8;
-	start = (u32) w->fb_base_phys + offset;
-	set_sdram_params(info->fix.id, start, info->fix.line_length);
+	davinci_disp_set_cursor_config(&cursor);
 
-	set_interlaced(info->fix.id, 1);
-	set_win_position(info->fix.id,
-			 x_pos(w), y_pos(w), v->xres, v->yres / 2);
-	set_win_mode(info->fix.id);
-	set_win_enable(info->fix.id, 1);
+	davinci_disp_cursor_enable();
 
-	return (0);
+	return 0;
 }
 
-/**
- *	davincifb_ioctl - handler for private ioctls.
+/*
+ * fb_ioctl method
  */
-static int davincifb_ioctl(struct fb_info *info, unsigned int cmd,
-			   unsigned long arg)
+static int
+davincifb_ioctl(struct fb_info *info, unsigned int cmd,	unsigned long arg)
 {
-	struct dm_win_info *w = (struct dm_win_info *)info->par;
+	struct vpbe_dm_win_info *win = info->par;
 	void __user *argp = (void __user *)arg;
 	struct fb_fillrect rect;
 	struct zoom_params zoom;
-	long std = 0;
+	int retval = 0;
+	struct vpbe_bitmap_blend_params blend_para;
+	struct vpbe_blink_option blink_option;
+	struct vpbe_video_config_params vid_conf_params;
+	struct vpbe_bitmap_config_params bitmap_conf_params;
+	struct vpbe_backg_color backg_color;
+	struct vpbe_window_position win_pos;
+	struct fb_cursor cursor;
 
 	switch (cmd) {
 	case FBIO_WAITFORVSYNC:
@@ -781,940 +1379,1074 @@ static int davincifb_ioctl(struct fb_info *info, unsigned int cmd,
 		 * display.  We only support one display, so we will
 		 * simply ignore the argument.
 		 */
-		return (davincifb_wait_for_vsync(w));
-		break;
+		return davincifb_wait_for_vsync(info);
+
 	case FBIO_SETATTRIBUTE:
 		if (copy_from_user(&rect, argp, sizeof(rect)))
 			return -EFAULT;
-		return (davincifb_set_attr_blend(&rect));
-		break;
+		return vpbe_set_attr_blend(info, &rect);
+
 	case FBIO_SETPOSX:
-		if (arg >= 0 && arg <= DISP_XRES) {
-			w->x = arg;
-			davincifb_check_var(&w->info.var, &w->info);
-			davincifb_set_par(&w->info);
-			return 0;
-		} else
-			return -EINVAL;
-		break;
+		return vpbe_setposx(info, arg);
+
 	case FBIO_SETPOSY:
-		if (arg >= 0 && arg <= DISP_YRES) {
-			w->y = arg;
-			davincifb_check_var(&w->info.var, &w->info);
-			davincifb_set_par(&w->info);
-			return 0;
-		} else
-			return -EINVAL;
-		break;
+		return vpbe_setposy(info, arg);
+
 	case FBIO_SETZOOM:
 		if (copy_from_user(&zoom, argp, sizeof(zoom)))
 			return -EFAULT;
-		if ((zoom.zoom_h == 2) || (zoom.zoom_h == 0)
-		    || (zoom.zoom_h == 1) || (zoom.zoom_v == 2)
-		    || (zoom.zoom_v == 0) || (zoom.zoom_v == 1)) {
-			set_zoom(zoom.window_id, zoom.zoom_h, zoom.zoom_v);
-			return 0;
-		} else {
-			return -EINVAL;
-		}
-		break;
-	case FBIO_GETSTD:
-		std = ((dmparams.output << 16) | (dmparams.format));	//(NTSC <<16) | (COPOSITE);
-		if (copy_to_user(argp, &std, sizeof(u_int32_t)))
-			return -EFAULT;
-		return 0;
-		break;
-	}
-	return (-EINVAL);
-}
+		return vpbe_set_zoom(info, &zoom);
 
-/**
- *  	davincifb_setcolreg - Optional function. Sets a color register.
- *      @regno: Which register in the CLUT we are programming
- *      @red: The red value which can be up to 16 bits wide
- *	@green: The green value which can be up to 16 bits wide
- *	@blue:  The blue value which can be up to 16 bits wide.
- *	@transp: If supported the alpha value which can be up to 16 bits wide.
- *      @info: frame buffer info structure
- *
- *  	Set a single color register. The values supplied have a 16 bit
- *  	magnitude which needs to be scaled in this function for the hardware.
- *	Things to take into consideration are how many color registers, if
- *	any, are supported with the current color visual. With truecolor mode
- *	no color palettes are supported. Here a psuedo palette is created
- *	which we store the value in pseudo_palette in struct fb_info. For
- *	pseudocolor mode we have a limited color palette. To deal with this
- *	we can program what color is displayed for a particular pixel value.
- *	DirectColor is similar in that we can program each color field. If
- *	we have a static colormap we don't need to implement this function.
- *
- *	Returns negative errno on error, or zero on success.
- */
-static int davincifb_setcolreg(unsigned regno, unsigned red, unsigned green,
-			       unsigned blue, unsigned transp,
-			       struct fb_info *info)
-{
-	/* only pseudo-palette (16 bpp) allowed */
-	if (regno >= 16)	/* maximum number of palette entries */
-		return (1);
+	case FBIO_ENABLE_DISABLE_WIN:
+		return vpbe_enable_disable_win(info, arg);
 
-	if (info->var.grayscale) {
-		/* grayscale = 0.30*R + 0.59*G + 0.11*B */
-		red = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;
-	}
+	case FBIO_SET_BITMAP_BLEND_FACTOR:
+		if (copy_from_user(&blend_para, argp, sizeof(blend_para)))
+			return -EFAULT;
+		return vpbe_bitmap_set_blend_factor(info, &blend_para);
 
-	/* Truecolor has hardware-independent 16-entry pseudo-palette */
-	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
-		u32 v;
+	case FBIO_SET_BITMAP_WIN_RAM_CLUT:
+		if (copy_from_user(win->dm->ram_clut[0], argp, RAM_CLUT_SIZE))
+			return -EFAULT;
+		return vpbe_bitmap_set_ram_clut(info, win->dm->ram_clut);
 
-		if (regno >= 16)
-			return (1);
+	case FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN:
+		return vpbe_enable_disable_attribute_window(info, arg);
 
-		red >>= (16 - info->var.red.length);
-		green >>= (16 - info->var.green.length);
-		blue >>= (16 - info->var.blue.length);
+	case FBIO_GET_BLINK_INTERVAL:
+		if ((retval = vpbe_get_blinking(info, &blink_option)) < 0)
+			return retval;
+		if (copy_to_user(argp, &blink_option, sizeof(blink_option)))
+			return -EFAULT;
+		return 0;
 
-		v = (red << info->var.red.offset) |
-		    (green << info->var.green.offset) |
-		    (blue << info->var.blue.offset);
+	case FBIO_SET_BLINK_INTERVAL:
+		if (copy_from_user(&blink_option, argp, sizeof(blink_option)))
+			return -EFAULT;
+		return vpbe_set_blinking(info, &blink_option);
 
-		switch (info->var.bits_per_pixel) {
-		case 16:
-			((u16 *) (info->pseudo_palette))[regno] = v;
-			break;
-		default:
-			return (1);
-		}
-		return (0);
-	}
-	return (0);
-}
+	case FBIO_GET_VIDEO_CONFIG_PARAMS:
+		if ((retval = vpbe_get_vid_params(info, &vid_conf_params)) < 0)
+			return retval;
+		if (copy_to_user
+		    (argp, &vid_conf_params, sizeof(vid_conf_params)))
+			return -EFAULT;
+		return 0;
 
-/**
- *      davincifb_pan_display - NOT a required function. Pans the display.
- *      @var: frame buffer variable screen structure
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *	Pan (or wrap, depending on the `vmode' field) the display using the
- *  	`xoffset' and `yoffset' fields of the `var' structure.
- *  	If the values don't fit, return -EINVAL.
- *
- *      Returns negative errno on error, or zero on success.
- */
-static int davincifb_pan_display(struct fb_var_screeninfo *var,
-				 struct fb_info *info)
-{
-	struct dm_win_info *w = (struct dm_win_info *)info->par;
-	u32 start = 0, offset = 0;
+	case FBIO_SET_VIDEO_CONFIG_PARAMS:
+		if (copy_from_user
+		    (&vid_conf_params, argp, sizeof(vid_conf_params)))
+			return -EFAULT;
+		return vpbe_set_vid_params(info, &vid_conf_params);
+
+	case FBIO_GET_BITMAP_CONFIG_PARAMS:
+		if ((retval =
+		     vpbe_bitmap_get_params(info, &bitmap_conf_params)) < 0)
+			return retval;
+		if (copy_to_user
+		    (argp, &bitmap_conf_params, sizeof(bitmap_conf_params)))
+			return -EFAULT;
+		return 0;
 
-	if (var->xoffset > var->xres_virtual - var->xres)
-		return (-EINVAL);
-	if (var->yoffset > var->yres_virtual - var->yres)
-		return (-EINVAL);
-	if ((var->xres_virtual * var->bits_per_pixel / 8) % 32)
-		return (-EINVAL);
+	case FBIO_SET_BITMAP_CONFIG_PARAMS:
+		if (copy_from_user
+		    (&bitmap_conf_params, argp, sizeof(bitmap_conf_params)))
+			return -EFAULT;
+		return vpbe_bitmap_set_params(info, &bitmap_conf_params);
 
-	offset = var->yoffset * info->fix.line_length +
-	    var->xoffset * var->bits_per_pixel / 8;
-	start = (u32) w->fb_base_phys + offset;
+	case FBIO_SET_BACKG_COLOR:
+		if (copy_from_user(&backg_color, argp, sizeof(backg_color)))
+			return -EFAULT;
+		return vpbe_set_backg_color(info, &backg_color);
 
-	if ((dispc_reg_in(VENC_VSTAT) & 0x00000010)==0x10)
-		set_sdram_params(info->fix.id, start, info->fix.line_length);
-	else
-		w->sdram_address = start;
+	case FBIO_SETPOS:
+		if (copy_from_user(&win_pos, argp, sizeof(win_pos)))
+			return -EFAULT;
+		return vpbe_setpos(info, &win_pos);
+
+	case FBIO_SET_CURSOR:
+		if (copy_from_user(&cursor, argp, sizeof(cursor)))
+			return -EFAULT;
+		return vpbe_set_cursor_params(info, &cursor);
 
-	return (0);
+	default:
+		return -EINVAL;
+	}
 }
 
-/**
- *      davincifb_blank - NOT a required function. Blanks the display.
- *      @blank_mode: the blank mode we want.
- *      @info: frame buffer structure that represents a single frame buffer
- *
- *      Blank the screen if blank_mode != 0, else unblank. Return 0 if
- *      blanking succeeded, != 0 if un-/blanking failed due to e.g. a
- *      video mode which doesn't support it. Implements VESA suspend
- *      and powerdown modes on hardware that supports disabling hsync/vsync:
- *      blank_mode == 2: suspend vsync
- *      blank_mode == 3: suspend hsync
- *      blank_mode == 4: powerdown
- *
- *      Returns negative errno on error, or zero on success.
- *
+
+/*
+ * fb_check_var method
  */
-static int davincifb_blank(int blank_mode, struct fb_info *info)
+static int
+davincifb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
-	return 0;
-}
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_videomode *mode = &win->dm->mode;
+	struct davinci_layer_config lconfig;
+	struct fb_fix_screeninfo fix;
+		
+	/*
+	 * Get an updated copy of the video mode from the encoder manager, just
+	 * in case the display has been switched.
+	 */
+	get_video_mode(mode);
 
-static int parse_win_params(char *wp,
-			    int *xres, int *yres, int *xpos, int *ypos)
-{
-	char *s;
+	/*
+	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
+	 * a special case.  It indicates that the window should be disabled.  If
+	 * the window is a video window, it will also be released.
+	 */
+	if (var->xres == 0 || var->yres == 0 || var->xres_virtual == 0
+	    || var->yres_virtual == 0) {
+		var->xres = 0;
+		var->yres = 0;
+		var->xres_virtual = 0;
+		var->yres_virtual = 0;
+		return 0;
+	}
 
-	if ((s = strsep(&wp, "x")) == NULL)
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+	case 16:
+		break;
+	case 24:
+		if (cpu_is_davinci_dm355())
+			return -EINVAL;
+		break;
+	case 32:
+		if (cpu_is_davinci_dm644x())
+			return -EINVAL;
+		break;
+	default:
 		return -EINVAL;
-	*xres = simple_strtoul(s, NULL, 0);
+	}
 
-	if ((s = strsep(&wp, "@")) == NULL)
+	if (var->xres_virtual < var->xres || var->yres_virtual < var->yres)
+		return -EINVAL;
+	if (var->xoffset > var->xres_virtual - var->xres)
+		return -EINVAL;
+	if (var->yoffset > var->yres_virtual - var->yres)
+		return -EINVAL;
+	if (mode->xres < var->xres || mode->yres < var->yres)
+		return -EINVAL;
+	if (win->xpos > mode->xres - var->xres)
+		return -EINVAL;
+	if (win->ypos > mode->yres - var->yres)
+		return -EINVAL;
+	convert_fb_var_to_osd(var, &lconfig, win->dm->yc_pixfmt);
+
+	update_fix_info(var, &fix);
+	lconfig.line_length = fix.line_length;
+	lconfig.xpos = win->xpos;
+	lconfig.ypos = win->ypos;
+	/* xoffset must be a multiple of xpanstep */
+	if (var->xoffset & ~(fix.xpanstep - 1))
 		return -EINVAL;
-	*yres = simple_strtoul(s, NULL, 0);
 
-	if ((s = strsep(&wp, ",")) == NULL)
+	/* check if we have enough video memory to support this mode */
+	if (!window_will_fit_framebuffer(var, info->fix.smem_len))
 		return -EINVAL;
-	*xpos = simple_strtoul(s, NULL, 0);
 
-	if ((s = strsep(&wp, ":")) == NULL)
+	/* see if the OSD manager approves of this configuration */
+	if (davinci_disp_try_layer_config(win->layer, &lconfig))
+		return -EINVAL;
+	/*
+	 * Reject this var if the OSD manager would have to modify the window
+	 * geometry to make it work.
+	 */
+	if (lconfig.xsize != var->xres || lconfig.ysize != var->yres)
+		return -EINVAL;
+	if (lconfig.xpos != win->xpos || lconfig.ypos != win->ypos)
 		return -EINVAL;
-	*ypos = simple_strtoul(s, NULL, 0);
+	
+	/*
+	 * At this point we have accepted the var, so now we convert our layer
+	 * configuration struct back to the var in order to make all of the
+	 * pixel format and geometry values consistent.  The var timing values
+	 * will be unmodified, as we have no way to verify them.
+	 */
+	convert_osd_to_fb_var(&lconfig, var);
 
 	return 0;
 }
 
 /*
- * Pass boot-time options by adding the following string to the boot params:
- * 	video=davincifb:[option[:option]]
- * Valid options:
- * 	output=[lcd|ntsc|pal]
- * 	format=[composite|s-video|component|rgb]
- * 	vid0=[off|MxN@X,Y]
- * 	vid1=[off|MxN@X,Y]
- * 	osd0=[off|MxN@X,Y]
- * 	osd1=[off|MxN@X,Y]
- * 		MxN specify the window resolution (displayed size)
- * 		X,Y specify the window position
- * 		M, N, X, Y are integers
- * 		M, X should be multiples of 16
+ * fb_set_par method
  */
-
-#ifndef MODULE
-int __init davincifb_setup(char *options)
+static int davincifb_set_par(struct fb_info *info)
 {
-	char *this_opt;
-	u32 xres, yres, xpos, ypos;
-	int format_yres = 480;
-
-	pr_debug("davincifb: Options \"%s\"\n", options);
-
-	if (!options || !*options)
-		return 0;
-
-	while ((this_opt = strsep(&options, ":")) != NULL) {
-
-		if (!*this_opt)
-			continue;
-
-		if (!strncmp(this_opt, "output=", 7)) {
-			if (!strncmp(this_opt + 7, "lcd", 3)) {
-				dmparams.output = LCD;
-				dmparams.format = 0;
-			} else if (!strncmp(this_opt + 7, "ntsc", 4))
-				dmparams.output = NTSC;
-			else if (!strncmp(this_opt + 7, "pal", 3))
-				dmparams.output = PAL;
-		} else if (!strncmp(this_opt, "format=", 7)) {
-			if (dmparams.output == LCD)
-				continue;
-			if (!strncmp(this_opt + 7, "composite", 9))
-				dmparams.format = COMPOSITE;
-			else if (!strncmp(this_opt + 7, "s-video", 7))
-				dmparams.format = SVIDEO;
-			else if (!strncmp(this_opt + 7, "component", 9))
-				dmparams.format = COMPONENT;
-			else if (!strncmp(this_opt + 7, "rgb", 3))
-				dmparams.format = RGB;
-		} else if (!strncmp(this_opt, "vid0=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dmparams.windows &= ~(1 << VID0);
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				dmparams.vid0_xres = xres;
-				dmparams.vid0_yres = yres;
-				dmparams.vid0_xpos = xpos;
-				dmparams.vid0_ypos = ypos;
-			}
-		} else if (!strncmp(this_opt, "vid1=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dmparams.windows &= ~(1 << VID1);
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				dmparams.vid1_xres = xres;
-				dmparams.vid1_yres = yres;
-				dmparams.vid1_xpos = xpos;
-				dmparams.vid1_ypos = ypos;
-			}
-		} else if (!strncmp(this_opt, "osd0=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dmparams.windows &= ~(1 << OSD0);
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				dmparams.osd0_xres = xres;
-				dmparams.osd0_yres = yres;
-				dmparams.osd0_xpos = xpos;
-				dmparams.osd0_ypos = ypos;
-			}
-		} else if (!strncmp(this_opt, "osd1=", 5)) {
-			if (!strncmp(this_opt + 5, "off", 3))
-				dmparams.windows &= ~(1 << OSD1);
-			else if (!parse_win_params(this_opt + 5,
-						   &xres, &yres, &xpos,
-						   &ypos)) {
-				dmparams.osd1_xres = xres;
-				dmparams.osd1_yres = yres;
-				dmparams.osd1_xpos = xpos;
-				dmparams.osd1_ypos = ypos;
+	struct vpbe_dm_win_info *win = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct davinci_layer_config lconfig;
+	struct fb_videomode mode;
+	unsigned start;
+
+	/* update the fix info to be consistent with the var */
+	update_fix_info(var, &info->fix);
+	convert_fb_info_to_osd(info, &lconfig);
+
+	/* See if we need to pass the timing values to the encoder manager. */
+	memcpy(&mode, &win->dm->mode, sizeof(mode));
+	fb_var_to_videomode(&mode, var);
+	mode.name = win->dm->mode.name;
+	if (mode.xres == win->dm->mode.xres && mode.yres == win->dm->mode.yres
+	    && mode.pixclock != 0) {
+		/*
+		 * If the timing parameters from the var are different than the
+		 * timing parameters from the encoder, try to update the
+		 * timing parameters with the encoder manager.
+		 */
+		if (!fb_mode_is_equal(&mode, &win->dm->mode))
+			set_video_mode(&mode);
+	}
+	/* update our copy of the encoder video mode */
+	get_video_mode(&win->dm->mode);
+
+	/* turn off ping-pong buffer and field inversion to fix
+	   the image shaking problem in 1080I mode. The problem i.d. by the
+	   DM6446 Advisory 1.3.8 is not seen in 1080I mode, but the ping-pong
+	   buffer workaround created a shaking problem. */
+/* Sandeep */
+#if 0
+	if (win->layer == WIN_VID0 &&
+	    strcmp(mode.name, VID_ENC_STD_1080I_30) == 0 &&
+	    (cpu_is_davinci_dm644x_pg1x() || cpu_is_davinci_dm357()))
+		davinci_disp_set_field_inversion(0);
+#endif
+	/*
+	 * Update the var with the encoder timing info.  The window geometry
+	 * will be preserved.
+	 */
+	construct_fb_var(var, &win->dm->mode, &lconfig);
+
+	/* need to update interlaced since the mode may have changed */
+	lconfig.interlaced = var->vmode = win->dm->mode.vmode;
+	/*
+	 * xres, yres, xres_virtual, or yres_virtual equal to zero is treated as
+	 * a special case.  It indicates that the window should be disabled.  If
+	 * the window is a video window, it will also be released.
+	 * Note that we disable the window, but we do not set the
+	 * win->disable_window flag.  This allows the window to be re-enabled
+	 * simply by using the FBIOPUT_VSCREENINFO ioctl to set a valid
+	 * configuration.
+	 */
+	if (lconfig.xsize == 0 || lconfig.ysize == 0) {
+		if (win->own_window) {
+			davinci_disp_disable_layer(win->layer);
+			if (is_vid_win(info)) {
+				win->own_window = 0;
+				davinci_disp_release_layer(win->layer);
 			}
 		}
+		return 0;
+	}
+
+	/*
+	 * If we don't currently own this window, we must claim it from the OSD
+	 * manager.
+	 */
+	if (!win->own_window) {
+		if (davinci_disp_request_layer(win->layer))
+			return -ENODEV;
+		win->own_window = 1;
 	}
-	printk(KERN_INFO "DaVinci: "
-	       "Output on %s%s, Enabled windows: %s %s %s %s\n",
-	       (dmparams.output == LCD) ? "LCD" :
-	       (dmparams.output == NTSC) ? "NTSC" :
-	       (dmparams.output == PAL) ? "PAL" : "unknown device!",
-	       (dmparams.format == 0) ? "" :
-	       (dmparams.format == COMPOSITE) ? " in COMPOSITE format" :
-	       (dmparams.format == SVIDEO) ? " in SVIDEO format" :
-	       (dmparams.format == COMPONENT) ? " in COMPONENT format" :
-	       (dmparams.format == RGB) ? " in RGB format" : "",
-	       (dmparams.windows & (1 << VID0)) ? "Video0" : "",
-	       (dmparams.windows & (1 << VID1)) ? "Video1" : "",
-	       (dmparams.windows & (1 << OSD0)) ? "OSD0" : "",
-	       (dmparams.windows & (1 << OSD1)) ? "OSD1" : "");
-	if (dmparams.output == NTSC) {
-		format_yres = 480;
-	} else if (dmparams.output == PAL) {
-		format_yres = 576;
+
+	/* DM365 YUV420 Planar */
+	if (cpu_is_davinci_dm365() &&
+			info->var.bits_per_pixel == 8 &&
+			(win->layer == WIN_VID0 || win->layer == WIN_VID1)
+			) {
+		start =
+			info->fix.smem_start +
+			(var->xoffset * 12) / 8 +
+			var->yoffset * 3 / 2 * info->fix.line_length;
 	} else {
-		printk(KERN_INFO
-		       "DaVinci:invalid format..defaulting width to 480\n");
+		start =
+		info->fix.smem_start + (var->xoffset * var->bits_per_pixel) / 8
+		+ var->yoffset * info->fix.line_length;
 	}
-	dmparams.osd0_yres = osd0_default_var.yres = format_yres;
-	dmparams.osd1_yres = osd1_default_var.yres = format_yres;
-	dmparams.vid0_yres = vid0_default_var.yres = format_yres;
-	dmparams.vid1_yres = vid1_default_var.yres = format_yres;
-
-	osd0_default_var.yres_virtual = format_yres * DOUBLE_BUF;
-	osd1_default_var.yres_virtual = format_yres * DOUBLE_BUF;
-	vid0_default_var.yres_virtual = format_yres * TRIPLE_BUF;
-	vid1_default_var.yres_virtual = format_yres * TRIPLE_BUF;
-
-	if (dmparams.windows & (1 << VID0))
-		printk(KERN_INFO "Setting Video0 size %dx%d, "
-		       "position (%d,%d)\n",
-		       dmparams.vid0_xres, dmparams.vid0_yres,
-		       dmparams.vid0_xpos, dmparams.vid0_ypos);
-	if (dmparams.windows & (1 << VID1))
-		printk(KERN_INFO "Setting Video1 size %dx%d, "
-		       "position (%d,%d)\n",
-		       dmparams.vid1_xres, dmparams.vid1_yres,
-		       dmparams.vid1_xpos, dmparams.vid1_ypos);
-	if (dmparams.windows & (1 << OSD0))
-		printk(KERN_INFO "Setting OSD0 size %dx%d, "
-		       "position (%d,%d)\n",
-		       dmparams.osd0_xres, dmparams.osd0_yres,
-		       dmparams.osd0_xpos, dmparams.osd0_ypos);
-	if (dmparams.windows & (1 << OSD1))
-		printk(KERN_INFO "Setting OSD1 size %dx%d, "
-		       "position (%d,%d)\n",
-		       dmparams.osd1_xres, dmparams.osd1_yres,
-		       dmparams.osd1_xpos, dmparams.osd1_ypos);
-	return (0);
-}
-#endif
+	davinci_disp_set_layer_config(win->layer, &lconfig);
+	davinci_disp_start_layer(win->layer, start, fb_cbcr_ofst);
+	if (win->display_window)
+		davinci_disp_enable_layer(win->layer, 0);
 
-static int mem_release(struct dm_win_info *w)
-{
-	if (!w->alloc_fb_mem) {
-		iounmap((void *)w->fb_base);
-		release_mem_region(w->fb_base_phys, w->fb_size);
-	} else
-		dma_free_coherent(NULL, w->fb_size, (void *)w->fb_base,
-				  w->fb_base_phys);
-	kfree(w);
-	return (0);
+	return 0;
 }
 
-static int mem_alloc(struct dm_win_info **win, dma_addr_t fb_base_phys,
-		     unsigned long fb_size, char *fbname)
-{
-	struct dm_win_info *w;
-	struct device *dev = dm->dev;
+/*
+ * This macro converts a 16-bit color passed to fb_setcolreg to the width
+ * supported by the pixel format.
+ */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
 
-	w = kmalloc(sizeof(struct dm_win_info), GFP_KERNEL);
-	if (!w) {
-		dev_err(dev, "%s: could not allocate memory\n", fbname);
-		return (-ENOMEM);
-	}
-	memset(w, 0, sizeof(struct dm_win_info));
+/*
+ * fb_setcolreg method
+ */
+static int davincifb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			       unsigned blue, unsigned transp,
+			       struct fb_info *info)
+{
+	unsigned r, g, b, t;
 
-	w->fb_base_phys = fb_base_phys;
-	w->fb_size = fb_size;
+	if (regno >= 256)	/* no. of hw registers */
+		return -EINVAL;
 
-	/* A null base address indicates that the framebuffer memory should be
-	 * dynamically allocated.
+	/*
+	 * An RGB color palette isn't applicable to a window with a YUV pixel
+	 * format or to a window in attribute mode.
 	 */
-	if (!w->fb_base_phys)
-		w->alloc_fb_mem = 1;
-
-	if (!w->alloc_fb_mem) {
-		if (!request_mem_region(w->fb_base_phys, w->fb_size, fbname)) {
-			dev_err(dev, "%s: cannot reserve FB region\n", fbname);
-			goto free_par;
-		}
-		w->fb_base =
-		    (unsigned long)ioremap(w->fb_base_phys, w->fb_size);
-		if (!w->fb_base) {
-			dev_err(dev, "%s: cannot map framebuffer\n", fbname);
-			goto release_fb;
-		}
-	} else {
-		/* allocate coherent memory for the framebuffer */
-		w->fb_base = (unsigned long)dma_alloc_coherent(dev,
-							       w->fb_size,
-							       &w->fb_base_phys,
-							       GFP_KERNEL |
-							       GFP_DMA);
-		if (!w->fb_base) {
-			dev_err(dev, "%s: cannot allocate framebuffer\n",
-				fbname);
-			goto free_par;
-		}
+	if (is_yuv(&info->var) || is_attribute_mode(&info->var))
+		return -EINVAL;
 
-		dev_dbg(dev, "Framebuffer allocated at 0x%x "
-			"mapped to 0x%x, size %dk\n",
-			(unsigned)w->fb_base_phys, (unsigned)w->fb_base,
-			(unsigned)w->fb_size / 1024);
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		r = CNVT_TOHW(red, info->var.red.length);
+		g = CNVT_TOHW(green, info->var.green.length);
+		b = CNVT_TOHW(blue, info->var.blue.length);
+		t = CNVT_TOHW(transp, info->var.transp.length);
+		break;
+	case FB_VISUAL_PSEUDOCOLOR:
+	default:
+		r = CNVT_TOHW(red, 8);
+		g = CNVT_TOHW(green, 8);
+		b = CNVT_TOHW(blue, 8);
+		t = 0;
+		break;
 	}
 
-	*win = w;
-	return (0);
+	/* Truecolor has hardware independent palette */
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+		u32 v;
 
-      release_fb:
-	if (!w->alloc_fb_mem)
-		release_mem_region(w->fb_base_phys, w->fb_size);
-      free_par:
-	kfree(w);
-	return (-ENOMEM);
-}
+		if (regno >= 16)
+			return -EINVAL;
 
-static struct fb_info *init_fb_info(struct dm_win_info *w,
-				    struct fb_var_screeninfo *var, char *id)
-{
-	struct fb_info *info = &(w->info);
-	struct dm_info *dm = w->dm;
+		v = (r << info->var.red.offset) |
+		    (g << info->var.green.offset) |
+		    (b << info->var.blue.offset) |
+		    (t << info->var.transp.offset);
 
-	/* initialize the fb_info structure */
-	info->flags = FBINFO_DEFAULT;
-	info->fbops = &davincifb_ops;
-	info->screen_base = (char *)(w->fb_base);
-	info->pseudo_palette = w->pseudo_palette;
-	info->par = w;
+		switch (info->var.bits_per_pixel) {
+		case 16:
+			((u16 *) (info->pseudo_palette))[regno] = v;
+			break;
+		case 24:
+		case 32:
+			((u32 *) (info->pseudo_palette))[regno] = v;
+			break;
+		}
+		return 0;
+	}
 
-	/* Initialize variable screeninfo.
-	 * The variable screeninfo can be directly specified by the user
-	 * via an ioctl.
-	 */
-	memcpy(&info->var, var, sizeof(info->var));
-	info->var.activate = FB_ACTIVATE_NOW;
+	if (!is_osd_win(info))
+		return -EINVAL;
 
-	/* Initialize fixed screeninfo.
-	 * The fixed screeninfo cannot be directly specified by the user, but
-	 * it may change to reflect changes to the var info.
-	 */
-	strlcpy(info->fix.id, id, sizeof(info->fix.id));
-	info->fix.smem_start = w->fb_base_phys;
-	info->fix.line_length =
-	    (info->var.xres_virtual * info->var.bits_per_pixel) / 8;
-	info->fix.smem_len = w->fb_size;
-	info->fix.type = FB_TYPE_PACKED_PIXELS;
-	info->fix.visual = (info->var.bits_per_pixel <= 8) ?
-	    FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
-	info->fix.xpanstep = 0;
-	info->fix.ypanstep = 1;
-	info->fix.ywrapstep = 0;
-	info->fix.type_aux = 0;
-	info->fix.mmio_start = dm->mmio_base_phys;
-	info->fix.mmio_len = dm->mmio_size;
-	info->fix.accel = FB_ACCEL_NONE;
-	w->sdram_address = 0;
-
-	return info;
+	davinci_disp_set_clut_rgb(regno, r, g, b);
+
+	return 0;
 }
 
-static void davincifb_ntsc_composite_config(int on)
+/*
+ * fb_pan_display method
+ *
+ * Pan the display using the `xoffset' and `yoffset' fields of the `var'
+ * structure.  We don't support wrapping and ignore the FB_VMODE_YWRAP flag.
+ */
+static int
+davincifb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
 {
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	struct vpbe_dm_win_info *win = info->par;
+	unsigned start;
 
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
+	if (!win->own_window)
+		return -ENODEV;
 
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+	if (var->xoffset > info->var.xres_virtual - info->var.xres)
+		return -EINVAL;
+	if (var->yoffset > info->var.yres_virtual - info->var.yres)
+		return -EINVAL;
 
-		/* Enable output mode and NTSC  */
-		dispc_reg_out(VENC_VMOD, 0x1003);
+	/* xoffset must be a multiple of xpanstep */
+	if (var->xoffset & ~(info->fix.xpanstep - 1))
+		return -EINVAL;
 
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
+	/* For DM365 video windows:
+   * using bits_per_pixel to calculate start/offset address
+   * needs to be changed for YUV420 planar format since
+   * it is 8. But consider CbCr the real (avg) bits per pixel
+   * is 12. line_length is calcuate using 8, so offset needs
+   * to time 1.5 to take C plane into account.
+   */
+	if (cpu_is_davinci_dm365() &&
+			info->var.bits_per_pixel == 8 &&
+			(win->layer == WIN_VID0 || win->layer == WIN_VID1)
+			) {
+		start =
+	    info->fix.smem_start +
+	    (var->xoffset * 12) / 8 +
+	    var->yoffset * 3 / 2 * info->fix.line_length;
 	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+		start =
+	    info->fix.smem_start +
+	    (var->xoffset * info->var.bits_per_pixel) / 8 +
+	    var->yoffset * info->fix.line_length;
 	}
+	if (davinci_disp_is_second_field()) {
+		davinci_disp_start_layer(win->layer, start, fb_cbcr_ofst);
+	} else
+		win->sdram_address = start;
+
+	return 0;
 }
 
-static void davincifb_ntsc_svideo_config(int on)
+/*
+ * fb_blank method
+ *
+ * Blank the screen if blank_mode != 0, else unblank.
+ */
+int davincifb_blank(int blank_mode, struct fb_info *info)
 {
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
-
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
-
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+	struct vpbe_dm_win_info *win = info->par;
+	int retval = 0;
 
-		/* Enable output mode and NTSC  */
-		dispc_reg_out(VENC_VMOD, 0x1003);
-
-		/* Enable S-Video Output; DAC B: S-Video Y, DAC C: S-Video C  */
-		dispc_reg_out(VENC_DACSEL, 0x210);
+	if (!win->own_window)
+		return -ENODEV;
 
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
+	if (!blank_mode) {
+		win->display_window = 1;
+		retval = info->fbops->fb_check_var(&info->var, info);
+		if (retval)
+			return retval;
+		retval = info->fbops->fb_set_par(info);
 	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+		win->display_window = 0;
+		davinci_disp_disable_layer(win->layer);
 	}
-}
 
-static void davincifb_ntsc_component_config(int on)
-{
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	return retval;
+}
 
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
+/*
+ *  Frame buffer operations
+ */
+static struct fb_ops davincifb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = davincifb_check_var,
+	.fb_set_par = davincifb_set_par,
+	.fb_setcolreg = davincifb_setcolreg,
+	.fb_blank = davincifb_blank,
+	.fb_pan_display = davincifb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_rotate = NULL,
+	.fb_sync = NULL,
+	.fb_ioctl = davincifb_ioctl,
+};
 
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+static void davincifb_release_window(struct device *dev,
+				     struct vpbe_dm_win_info *win)
+{
+	struct fb_info *info = win->info;
 
-		/* Enable output mode and NTSC  */
-		dispc_reg_out(VENC_VMOD, 0x1003);
+	if (info) {
+		unregister_framebuffer(info);
+		win->info = NULL;
+	}
 
-		/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-		dispc_reg_out(VENC_DACSEL, 0x543);
+	if (win->own_window) {
+		davinci_disp_release_layer(win->layer);
+		win->own_window = 0;
+	}
+	win->display_window = 0;
 
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
-	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	if (info) {
+		dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+				  info->fix.smem_start);
+		fb_dealloc_cmap(&info->cmap);
+		kfree(info);
 	}
 }
 
-static void davincifb_pal_composite_config(int on)
+static int davincifb_init_window(struct device *dev,
+				 struct vpbe_dm_win_info *win,
+				 struct davinci_layer_config *lconfig,
+				 unsigned fb_size, const char *name)
 {
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	struct fb_info *info;
+	int err;
 
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
+	if (!fb_size)
+		return 0;
 
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(dev, "%s: Can't allocate memory for fb_info struct.\n",
+			name);
+		return -ENOMEM;
+	}
+	win->info = info;
+
+	/* initialize fb_info */
+	info->par = win;
+	info->flags =
+	    FBINFO_DEFAULT | FBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |
+	    FBINFO_HWACCEL_IMAGEBLIT | FBINFO_HWACCEL_XPAN |
+	    FBINFO_HWACCEL_YPAN;
+	info->fbops = &davincifb_ops;
+	info->screen_size = fb_size;
+	info->pseudo_palette = win->pseudo_palette;
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		dev_err(dev, "%s: Can't allocate color map.\n", name);
+		err = -ENODEV;
+		goto cmap_out;
+	}
 
-		/* Enable output mode and PAL  */
-		dispc_reg_out(VENC_VMOD, 0x1043);
+	/* initialize fb_fix_screeninfo */
+	strlcpy(info->fix.id, name, sizeof(info->fix.id));
+	info->fix.smem_len = fb_size;
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
 
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
-	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	/* allocate the framebuffer */
+	info->screen_base =
+	    dma_alloc_coherent(dev, info->fix.smem_len,
+			       (dma_addr_t *) & info->fix.smem_start,
+			       GFP_KERNEL | GFP_DMA);
+	if (!info->screen_base) {
+		dev_err(dev, "%s: dma_alloc_coherent failed when allocating "
+			"framebuffer.\n", name);
+		err = -ENOMEM;
+		goto fb_alloc_out;
 	}
-}
 
-static void davincifb_pal_svideo_config(int on)
-{
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+	/*
+	 * Fill the framebuffer with zeros unless it is an OSD1 window in
+	 * attribute mode, in which case we fill it with 0x77 to make the OSD0
+	 * pixels opaque.
+	 */
+	memset(info->screen_base,
+	       (lconfig->pixfmt == PIXFMT_OSD_ATTR) ? 0x77 : 0,
+	       info->fix.smem_len);
+
+	/* initialize fb_var_screeninfo */
+	construct_fb_var(&info->var, &win->dm->mode, lconfig);
+	win->xpos = lconfig->xpos;
+	win->ypos = lconfig->ypos;
+	info->var.xres_virtual = info->var.xres;
+	info->var.yres_virtual = info->var.yres;
+
+	/* update the fix info to be consistent with the var */
+	update_fix_info(&info->var, &info->fix);
+
+	/*
+	 * Request ownership of the window from the OSD manager unless this is
+	 * a video window and the window size is 0.
+	 */
+	if (is_osd_win(info) || (info->var.xres != 0 && info->var.yres != 0)) {
+		if (!davinci_disp_request_layer(win->layer))
+			win->own_window = 1;
+	}
+	/* bail out if this is an OSD window and we don't own it */
+	if (is_osd_win(info) && !win->own_window) {
+		dev_err(dev, "%s: Failed to obtain ownership of OSD "
+			"window.\n", name);
+		err = -ENODEV;
+		goto own_out;
+	}
 
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
+	win->display_window = 1;
 
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+	if (win->own_window) {
+		/* check if our initial window configuration is valid */
+		if (info->fbops->fb_check_var(&info->var, info)) {
+			dev_warn(dev, "%s: Initial window configuration is "
+				 "invalid.\n", name);
+		} else
+			info->fbops->fb_set_par(info);
+	}
 
-		/* Enable output mode and PAL  */
-		dispc_reg_out(VENC_VMOD, 0x1043);
+	/* register the framebuffer */
+	if (register_framebuffer(info)) {
+		dev_err(dev, "%s: Failed to register framebuffer.\n", name);
+		err = -ENODEV;
+		goto register_out;
+	}
 
-		/* Enable S-Video Output; DAC B: S-Video Y, DAC C: S-Video C  */
-		dispc_reg_out(VENC_DACSEL, 0x210);
+	dev_info(dev, "%s: %dx%dx%d@%d,%d with framebuffer size %dKB\n",
+		 info->fix.id, info->var.xres, info->var.yres,
+		 info->var.bits_per_pixel, win->xpos, win->ypos,
+		 info->fix.smem_len >> 10);
 
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
-	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
-	}
+	return 0;
+
+      register_out:
+	if (win->own_window)
+		davinci_disp_release_layer(win->layer);
+	win->own_window = 0;
+      own_out:
+	dma_free_coherent(dev, info->fix.smem_len, info->screen_base,
+			  info->fix.smem_start);
+      fb_alloc_out:
+	fb_dealloc_cmap(&info->cmap);
+      cmap_out:
+	kfree(info);
+
+	return err;
 }
 
-static void davincifb_pal_component_config(int on)
+static int davincifb_remove(struct device *dev)
 {
-	if (on) {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
+//	struct device *dev = &pdev->dev;
+	struct vpbe_dm_info *dm = dev_get_drvdata(dev);
 
-		/* Enable Composite output and start video encoder */
-		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VIE | VENC_VMOD_VENC));
+	dev_set_drvdata(dev, NULL);
 
-		/* Set REC656 Mode */
-		dispc_reg_out(VENC_YCCCTL, 0x1);
+	davinci_disp_unregister_callback(&dm->vsync_callback);
 
-		/* Enable output mode and PAL  */
-		dispc_reg_out(VENC_VMOD, 0x1043);
+	davincifb_release_window(dev, &dm->win[WIN_VID1]);
+	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
+	davincifb_release_window(dev, &dm->win[WIN_VID0]);
+	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
 
-		/* Enable Component output; DAC A: Y, DAC B: Pb, DAC C: Pr  */
-		dispc_reg_out(VENC_DACSEL, 0x543);
-
-		/* Enable all DACs  */
-		dispc_reg_out(VENC_DACTST, 0);
-	} else {
-		/* Reset video encoder module */
-		dispc_reg_out(VENC_VMOD, 0);
-	}
-}
+	kfree(dm);
 
-static inline void fix_default_var(struct dm_win_info *w,
-				   u32 xres, u32 yres, u32 xpos, u32 ypos,
-				   int n_buf)
-{
-	struct fb_var_screeninfo *v = &w->info.var;
-
-	v->xres = xres;
-	v->yres = yres;
-	v->xres_virtual = v->xres;
-	v->yres_virtual = v->yres * n_buf;
-	x_pos(w) = xpos;
-	y_pos(w) = ypos;
+	return 0;
 }
 
 /*
- *  Cleanup
+ * Return the maximum number of bytes per screen for a display layer at a
+ * resolution specified by an fb_videomode struct.
  */
-static int davincifb_remove(struct platform_device *pdev)
+static unsigned davincifb_max_screen_size(enum davinci_disp_layer layer,
+					  const struct fb_videomode *mode)
 {
-	free_irq(IRQ_VENCINT, &dm);
-
-	/* Cleanup all framebuffers */
-	if (dm->osd0) {
-		unregister_framebuffer(&dm->osd0->info);
-		mem_release(dm->osd0);
-	}
-	if (dm->osd1) {
-		unregister_framebuffer(&dm->osd1->info);
-		mem_release(dm->osd1);
-	}
-	if (dm->vid0) {
-		unregister_framebuffer(&dm->vid0->info);
-		mem_release(dm->vid0);
-	}
-	if (dm->vid1) {
-		unregister_framebuffer(&dm->vid1->info);
-		mem_release(dm->vid1);
+	unsigned max_bpp = 32;
+	unsigned line_length;
+	unsigned size;
+
+	switch (layer) {
+	case WIN_OSD0:
+	case WIN_OSD1:
+		if (cpu_is_davinci_dm355())
+			max_bpp = 32;
+		else
+			max_bpp = 16;
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		if (cpu_is_davinci_dm355())
+			max_bpp = 16;
+		else
+			max_bpp = 24;
+		break;
 	}
 
-	/* Turn OFF the output device */
-	dm->output_device_config(0);
+	line_length = (mode->xres * max_bpp + 7) / 8;
+	line_length = ((line_length + 31) / 32) * 32;
+	size = mode->yres * line_length;
 
-	if (dm->mmio_base)
-		iounmap((void *)dm->mmio_base);
-	release_mem_region(dm->mmio_base_phys, dm->mmio_size);
-
-	return 0;
+	return size;
 }
 
-/*
- *  Initialization
- */
-static int davincifb_probe(struct platform_device *pdev)
+static void parse_win_params(struct vpbe_dm_win_info *win,
+			     struct davinci_layer_config *lconfig,
+			     unsigned *fb_size, char *opt)
 {
-	struct fb_info *info;
-
-	if (dmparams.windows == 0)
-		return 0;	/* user disabled all windows through bootargs */
-	dm->dev = &pdev->dev;
-	dm->mmio_base_phys = OSD_REG_BASE;
-	dm->mmio_size = OSD_REG_SIZE;
-
-	if (!request_mem_region
-	    (dm->mmio_base_phys, dm->mmio_size, MODULE_NAME)) {
-		dev_err(dm->dev, ": cannot reserve MMIO region\n");
-		return (-ENODEV);
+	char *s, *p, c = 0;
+	unsigned bits_per_pixel;
+
+	if (!opt)
+		return;
+
+	/* xsize */
+	p = strpbrk(opt, "x,@");
+	if (p)
+		c = *p;
+	if ((s = strsep(&opt, "x,@")) == NULL)
+		return;
+	if (*s)
+		lconfig->xsize = simple_strtoul(s, NULL, 0);
+	if (!p || !opt)
+		return;
+
+	/* ysize */
+	if (c == 'x') {
+		p = strpbrk(opt, "x,@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, "x,@")) == NULL)
+			return;
+		if (*s)
+			lconfig->ysize = simple_strtoul(s, NULL, 0);
+		if (!p || !opt)
+			return;
 	}
 
-	/* map the regions */
-	dm->mmio_base =
-	    (unsigned long)ioremap(dm->mmio_base_phys, dm->mmio_size);
-	if (!dm->mmio_base) {
-		dev_err(dm->dev, ": cannot map MMIO\n");
-		goto release_mmio;
+	/* bits per pixel */
+	if (c == 'x') {
+		p = strpbrk(opt, ",@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, ",@")) == NULL)
+			return;
+		if (*s) {
+			bits_per_pixel = simple_strtoul(s, NULL, 0);
+			switch (bits_per_pixel) {
+			case 1:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_1BPP;
+				break;
+			case 2:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_2BPP;
+				break;
+			case 4:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_4BPP;
+				break;
+			case 8:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_8BPP;
+				if (cpu_is_davinci_dm365())
+					if (win->layer == WIN_VID0 ||
+					    win->layer == WIN_VID1)
+						lconfig->pixfmt = PIXFMT_NV12;
+				break;
+			case 16:
+				if (win->layer == WIN_OSD0
+				    || win->layer == WIN_OSD1)
+					lconfig->pixfmt = PIXFMT_RGB565;
+				else
+					lconfig->pixfmt = win->dm->yc_pixfmt;
+				break;
+			case 24:
+				if (cpu_is_davinci_dm644x()
+				    && (win->layer == WIN_VID0
+					|| win->layer == WIN_VID1))
+					lconfig->pixfmt = PIXFMT_RGB888;
+				break;
+			case 32:
+				if (cpu_is_davinci_dm355()
+				    && (win->layer == WIN_OSD0
+					|| win->layer == WIN_OSD1))
+					lconfig->pixfmt = PIXFMT_RGB888;
+				break;
+			default:
+				break;
+			}
+		}
+		if (!p || !opt)
+			return;
 	}
 
-	/* initialize the vsync wait queue */
-	init_waitqueue_head(&dm->vsync_wait);
-	dm->timeout = HZ / 5;
-
-	if ((dmparams.output == NTSC) && (dmparams.format == COMPOSITE))
-		dm->output_device_config = davincifb_ntsc_composite_config;
-	else if ((dmparams.output == NTSC) && (dmparams.format == SVIDEO))
-		dm->output_device_config = davincifb_ntsc_svideo_config;
-	else if ((dmparams.output == NTSC) && (dmparams.format == COMPONENT))
-		dm->output_device_config = davincifb_ntsc_component_config;
-	else if ((dmparams.output == PAL) && (dmparams.format == COMPOSITE))
-		dm->output_device_config = davincifb_pal_composite_config;
-	else if ((dmparams.output == PAL) && (dmparams.format == SVIDEO))
-		dm->output_device_config = davincifb_pal_svideo_config;
-	else if ((dmparams.output == PAL) && (dmparams.format == COMPONENT))
-		dm->output_device_config = davincifb_pal_component_config;
-	/* Add support for other displays here */
-	else {
-		printk(KERN_WARNING "Unsupported output device!\n");
-		dm->output_device_config = NULL;
+	/* framebuffer size */
+	if (c == ',') {
+		p = strpbrk(opt, "@");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, "@")) == NULL)
+			return;
+		if (*s) {
+			*fb_size = simple_strtoul(s, &s, 0);
+			if (*s == 'K')
+				*fb_size <<= 10;
+			if (*s == 'M')
+				*fb_size <<= 20;
+		}
+		if (!p || !opt)
+			return;
 	}
 
-	printk("Setting Up Clocks for DM420 OSD\n");
-
-	/* Initialize the VPSS Clock Control register */
-	dispc_reg_out(VPSS_CLKCTL, 0x18);
-
-	/* Set Base Pixel X and Base Pixel Y */
-	dispc_reg_out(OSD_BASEPX, BASEX);
-	dispc_reg_out(OSD_BASEPY, BASEY);
-
-	/* Reset OSD registers to default. */
-	dispc_reg_out(OSD_MODE, 0);
-	dispc_reg_out(OSD_OSDWIN0MD, 0);
+	/* xpos */
+	if (c == '@') {
+		p = strpbrk(opt, ",");
+		if (p)
+			c = *p;
+		if ((s = strsep(&opt, ",")) == NULL)
+			return;
+		if (*s)
+			lconfig->xpos = simple_strtoul(s, NULL, 0);
+		if (!p || !opt)
+			return;
+	}
 
-	/* Set blue background color */
-	set_bg_color(0, 162);
+	/* ypos */
+	if (c == ',') {
+		s = opt;
+		if (*s)
+			lconfig->ypos = simple_strtoul(s, NULL, 0);
+	}
 
-	/* Field Inversion Workaround */
-	dispc_reg_out(OSD_MODE, 0x200);
+	return;
+}
 
-	/* Setup VID0 framebuffer */
-	if (!(dmparams.windows & (1 << VID0))) {
-		printk(KERN_WARNING "No video/osd windows will be enabled "
-		       "because Video0 is disabled\n");
-		return 0;	/* background will still be shown */
+/*
+ * Pass boot-time options by adding the following string to the boot params:
+ *	video=davincifb:options
+ * Valid options:
+ *	osd0=[MxNxP,S@X,Y]
+ *      osd1=[MxNxP,S@X,Y]
+ *	vid0=[off|MxNxP,S@X,Y]
+ *	vid1=[off|MxNxP,S@X,Y]
+ *		MxN are the horizontal and vertical window size
+ *		P is the color depth (bits per pixel)
+ *		S is the framebuffer size with a size suffix such as 'K' or 'M'
+ *		X,Y are the window position
+ *
+ * Only video windows can be turned off.  Turning off a video window means that
+ * no framebuffer device will be registered for it,
+ *
+ * To cause a window to be supported by the framebuffer driver but not displayed
+ * initially, pass a value of 0 for the window size.
+ *
+ * For example:
+ *      video=davincifb:osd0=720x480x16@0,0:osd1=720x480:vid0=off:vid1=off
+ *
+ * This routine returns 1 if the window is to be turned off, or 0 otherwise.
+ */
+static int davincifb_get_default_win_config(struct device *dev,
+					    struct vpbe_dm_win_info *win,
+					    struct davinci_layer_config
+					    *lconfig, unsigned *fb_size,
+					    const char *options)
+{
+	const char *win_names[] = { "osd0=", "vid0=", "osd1=", "vid1=" };
+	const char *this_opt, *next_opt;
+	int this_len, opt_len;
+	static char opt_buf[128];
+
+	/* supply default values for lconfig and fb_size */
+	switch (win->layer) {
+	case WIN_OSD0:
+		lconfig->pixfmt = PIXFMT_RGB565;
+		lconfig->xsize = win->dm->mode.xres;
+		lconfig->ysize = win->dm->mode.yres;
+		break;
+	case WIN_OSD1:
+		lconfig->pixfmt = PIXFMT_OSD_ATTR;
+		lconfig->xsize = win->dm->mode.xres;
+		lconfig->ysize = win->dm->mode.yres;
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		lconfig->pixfmt = win->dm->yc_pixfmt;
+		lconfig->xsize = 0;
+		lconfig->ysize = 0;
+		break;
 	}
-	/* Setup VID0 framebuffer */
-	if (!mem_alloc(&dm->vid0, VID0_FB_PHY, VID0_FB_SIZE, VID0_FBNAME)) {
-		dm->vid0->dm = dm;
-		fix_default_var(dm->vid0,
-				dmparams.vid0_xres, dmparams.vid0_yres,
-				dmparams.vid0_xpos, dmparams.vid0_ypos,
-				TRIPLE_BUF);
-		info = init_fb_info(dm->vid0, &vid0_default_var, VID0_FBNAME);
-		if (davincifb_check_var(&info->var, info)) {
-			dev_err(dm->dev, ": invalid default video mode\n");
-			goto exit;
+	lconfig->xpos = 0;
+	lconfig->ypos = 0;
+
+	lconfig->interlaced = is_display_interlaced(&win->dm->mode);
+	*fb_size = davincifb_max_screen_size(win->layer, &win->dm->mode);
+
+	next_opt = options;
+	while ((this_opt = next_opt)) {
+		this_len = strcspn(this_opt, ":");
+		next_opt = strpbrk(this_opt, ":");
+		if (next_opt)
+			++next_opt;
+
+		opt_len = strlen(win_names[win->layer]);
+		if (this_len >= opt_len) {
+			if (strncmp(this_opt, win_names[win->layer], opt_len))
+				continue;
+			this_len -= opt_len;
+			this_opt += opt_len;
+			if ((this_len >= strlen("off"))
+			    && !strncmp(this_opt, "off", strlen("off")))
+				return 1;
+			else {
+				strlcpy(opt_buf, this_opt,
+					min_t(int, sizeof(opt_buf),
+					      this_len + 1));
+				parse_win_params(win, lconfig, fb_size,
+						 opt_buf);
+				return 0;
+			}
 		}
-		memset((void *)dm->vid0->fb_base, 0x88, dm->vid0->fb_size);
-	} else
-		goto exit;
-
-	/* Setup OSD0 framebuffer */
-	if ((dmparams.windows & (1 << OSD0)) &&
-	    (!mem_alloc(&dm->osd0, OSD0_FB_PHY, OSD0_FB_SIZE, OSD0_FBNAME))) {
-		dm->osd0->dm = dm;
-		fix_default_var(dm->osd0,
-				dmparams.osd0_xres, dmparams.osd0_yres,
-				dmparams.osd0_xpos, dmparams.osd0_ypos,
-				DOUBLE_BUF);
-		info = init_fb_info(dm->osd0, &osd0_default_var, OSD0_FBNAME);
-		if (davincifb_check_var(&info->var, info)) {
-			dev_err(dm->dev, ": invalid default video mode\n");
-			mem_release(dm->osd0);
-		} else
-			memset((void *)dm->osd0->fb_base, 0, dm->osd0->fb_size);
 	}
 
-	/* Setup OSD1 framebuffer */
-	if ((dmparams.windows & (1 << OSD1)) &&
-	    (!mem_alloc(&dm->osd1, OSD1_FB_PHY, OSD1_FB_SIZE, OSD1_FBNAME))) {
-		dm->osd1->dm = dm;
-		fix_default_var(dm->osd1,
-				dmparams.osd1_xres, dmparams.osd1_yres,
-				dmparams.osd1_xpos, dmparams.osd1_ypos,
-				DOUBLE_BUF);
-		info = init_fb_info(dm->osd1, &osd1_default_var, OSD1_FBNAME);
-		if (davincifb_check_var(&info->var, info)) {
-			dev_err(dm->dev, ": invalid default video mode\n");
-			mem_release(dm->osd1);
-		} else
-			/* Set blend factor to show OSD windows */
-			memset((void *)dm->osd1->fb_base, 0xff,
-			       dm->osd1->fb_size);
-	}
+	return 0;
+}
 
-	/* Setup VID1 framebuffer */
-	if ((dmparams.windows & (1 << VID1)) &&
-	    (!mem_alloc(&dm->vid1, VID1_FB_PHY, VID1_FB_SIZE, VID1_FBNAME))) {
-		dm->vid1->dm = dm;
-		fix_default_var(dm->vid1,
-				dmparams.vid1_xres, dmparams.vid1_yres,
-				dmparams.vid1_xpos, dmparams.vid1_ypos,
-				TRIPLE_BUF);
-		info = init_fb_info(dm->vid1, &vid1_default_var, VID1_FBNAME);
-		if (davincifb_check_var(&info->var, info)) {
-			dev_err(dm->dev,
-				VID1_FBNAME ": invalid default video mode\n");
-			mem_release(dm->vid1);
-		} else
-			memset((void *)dm->vid1->fb_base, 0x88,
-			       dm->vid1->fb_size);
-	}
+/*
+ *     Module parameter definitions
+ */
+static char *options = "";
 
-	/* Register OSD0 framebuffer */
-	if (dm->osd0) {
-		info = &dm->osd0->info;
-		if (register_framebuffer(info) < 0) {
-			dev_err(dm->dev, OSD0_FBNAME
-				"Unable to register OSD0 framebuffer\n");
-			mem_release(dm->osd0);
-		} else {
-			printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			       info->node, info->fix.id);
-			davincifb_set_par(info);
-		}
-	}
+module_param(options, charp, S_IRUGO);
 
-	/* Register VID0 framebuffer */
-	info = &dm->vid0->info;
-	if (register_framebuffer(info) < 0) {
-		dev_err(dm->dev,
-			VID0_FBNAME "Unable to register VID0 framebuffer\n");
-		goto exit;
-	} else {
-		printk(KERN_INFO "fb%d: %s frame buffer device\n",
-		       info->node, info->fix.id);
-		davincifb_set_par(info);
+static int davincifb_probe(struct device *dev)
+{
+//	struct device *dev = &pdev->dev;
+	struct vpbe_dm_info *dm;
+	struct davinci_layer_config lconfig;
+	unsigned fb_size;
+	int err;
+
+	dm = kzalloc(sizeof(*dm), GFP_KERNEL);
+	if (!dm) {
+		dev_err(dev, "Can't allocate memory for driver state.\n");
+		return -ENOMEM;
 	}
-
-	/* Register OSD1 framebuffer */
-	if (dm->osd1) {
-		info = &dm->osd1->info;
-		if (register_framebuffer(info) < 0) {
-			dev_err(dm->dev, OSD1_FBNAME
-				"Unable to register OSD1 framebuffer\n");
-			mem_release(dm->osd1);
-		} else {
-			printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			       info->node, info->fix.id);
-			davincifb_set_par(info);
-		}
+	dev_set_drvdata(dev, dm);
+
+	/* get the video mode from the encoder manager */
+	get_video_mode(&dm->mode);
+
+	/* set the default Cb/Cr order */
+	dm->yc_pixfmt = PIXFMT_YCbCrI;
+
+	/* initialize OSD0 */
+	dm->win[WIN_OSD0].layer = WIN_OSD0;
+	dm->win[WIN_OSD0].dm = dm;
+	dm->win[WIN_OSD0].sdram_address = 0;
+	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD0], &lconfig,
+					 &fb_size, options);
+	err =
+	    davincifb_init_window(dev, &dm->win[WIN_OSD0], &lconfig, fb_size,
+				  OSD0_FBNAME);
+	if (err)
+		goto osd0_out;
+
+	/* initialize VID0 */
+	dm->win[WIN_VID0].layer = WIN_VID0;
+	dm->win[WIN_VID0].dm = dm;
+	dm->win[WIN_VID0].sdram_address = 0;
+	if (!davincifb_get_default_win_config
+	    (dev, &dm->win[WIN_VID0], &lconfig, &fb_size, options)) {
+		err =
+		    davincifb_init_window(dev, &dm->win[WIN_VID0], &lconfig,
+					  fb_size, VID0_FBNAME);
+		if (err)
+			goto vid0_out;
 	}
 
-	/* Register VID1 framebuffer */
-	if (dm->vid1) {
-		info = &dm->vid1->info;
-		if (register_framebuffer(info) < 0) {
-			mem_release(dm->vid1);
-			dev_err(dm->dev, VID1_FBNAME
-				"Unable to register VID1 framebuffer\n");
-			mem_release(dm->vid1);
-		} else {
-			printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			       info->node, info->fix.id);
-			davincifb_set_par(info);
-		}
+	/* initialize OSD1 */
+	dm->win[WIN_OSD1].layer = WIN_OSD1;
+	dm->win[WIN_OSD1].dm = dm;
+	dm->win[WIN_OSD1].sdram_address = 0;
+	davincifb_get_default_win_config(dev, &dm->win[WIN_OSD1], &lconfig,
+					 &fb_size, options);
+	err =
+	    davincifb_init_window(dev, &dm->win[WIN_OSD1], &lconfig, fb_size,
+				  OSD1_FBNAME);
+	if (err)
+		goto osd1_out;
+
+	/* initialize VID1 */
+	dm->win[WIN_VID1].layer = WIN_VID1;
+	dm->win[WIN_VID1].dm = dm;
+	dm->win[WIN_VID1].sdram_address = 0;
+	if (!davincifb_get_default_win_config
+	    (dev, &dm->win[WIN_VID1], &lconfig, &fb_size, options)) {
+		err =
+		    davincifb_init_window(dev, &dm->win[WIN_VID1], &lconfig,
+					  fb_size, VID1_FBNAME);
+		if (err)
+			goto vid1_out;
 	}
 
-	/* install our interrupt service routine */
-	if (request_irq(IRQ_VENCINT, davincifb_isr, IRQF_SHARED, MODULE_NAME,
-			dm)) {
-		dev_err(dm->dev, MODULE_NAME
-			": could not install interrupt service routine\n");
-		goto exit;
-	}
+	/* initialize the vsync wait queue */
+	init_waitqueue_head(&dm->vsync_wait);
+	dm->timeout = HZ / 5;
+
+	/* register the end-of-frame callback */
+	dm->vsync_callback.mask = DAVINCI_DISP_FIRST_FIELD |
+	    DAVINCI_DISP_SECOND_FIELD | DAVINCI_DISP_END_OF_FRAME;
+
+	dm->vsync_callback.handler = davincifb_vsync_callback;
+	dm->vsync_callback.arg = dm;
+	davinci_disp_register_callback(&dm->vsync_callback);
 
-	/* Turn ON the output device */
-	dm->output_device_config(1);
+	return 0;
 
-	return (0);
+      vid1_out:
+	davincifb_release_window(dev, &dm->win[WIN_OSD1]);
+      osd1_out:
+	davincifb_release_window(dev, &dm->win[WIN_VID0]);
+      vid0_out:
+	davincifb_release_window(dev, &dm->win[WIN_OSD0]);
+      osd0_out:
+	kfree(dm);
 
-      exit:
-	davincifb_remove(pdev);
-	iounmap((void *)dm->mmio_base);
-      release_mmio:
-	release_mem_region(dm->mmio_base_phys, dm->mmio_size);
-	return (-ENODEV);
+	return err;
 }
 
-/* ------------------------------------------------------------------------- */
+static void davincifb_release_dev(struct device *dev)
+{
+}
 
-    /*
-     *  Frame buffer operations
-     */
-static struct fb_ops davincifb_ops = {
-	.owner = THIS_MODULE,
-	.fb_check_var = davincifb_check_var,
-	.fb_set_par = davincifb_set_par,
-	.fb_setcolreg = davincifb_setcolreg,
-	.fb_blank = davincifb_blank,
-	.fb_pan_display = davincifb_pan_display,
-	.fb_fillrect = cfb_fillrect,
-	.fb_copyarea = cfb_copyarea,
-	.fb_imageblit = cfb_imageblit,
-	.fb_rotate = NULL,
-	.fb_sync = NULL,
-	.fb_ioctl = davincifb_ioctl,
+static u64 davincifb_dmamask = ~(u32) 0;
+
+/* FIXME: move to board setup file */
+static struct platform_device davincifb_device = {
+	.name = "davincifb",
+	.id = 0,
+	.dev = {
+		.release = davincifb_release_dev,
+		.dma_mask = &davincifb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.num_resources = 0,
 };
 
+static struct device_driver davincifb_driver = {
+	.name = "davincifb",
+	.bus = &platform_bus_type,
+	.probe = davincifb_probe,
+	.remove = davincifb_remove,
+	.suspend = NULL,
+	.resume = NULL,
+};
+#if 0
 static struct platform_driver davincifb_driver = {
-	.probe		= davincifb_probe,
-	.remove		= davincifb_remove,
-	.driver		= {
-		.name	= MODULE_NAME,
-		.owner	= THIS_MODULE,
-	},
+	.probe = davincifb_probe,
+	.remove = davincifb_remove,
+	.driver = {
+			.name = "davincifb",
+			.owner = THIS_MODULE,
+		},
 };
-
-/* Register both the driver and the device */
-int __init davincifb_init(void)
+#endif
+static int __init davincifb_init(void)
 {
+	struct device *dev = &davincifb_device.dev;
 #ifndef MODULE
-	/* boot-line options */
-	/* handle options for "dm64xxfb" for backwards compatability */
-	char *option;
-	char *names[] = { "davincifb", "dm64xxfb" };
-	int i, num_names = 2, done = 0;
-
-	for (i = 0; i < num_names && !done; i++) {
-		if (fb_get_options(names[i], &option)) {
-			printk(MODULE_NAME
-			       ": Disabled on command-line.\n");
-			return -ENODEV;
-		} else if (option) {
-			davincifb_setup(option);
-				done = 1;
+	{
+		char *names[] = { "davincifb", "dm64xxfb", "dm355fb" };
+		int i, num_names = 3;
+
+		for (i = 0; i < num_names; i++) {
+			if (fb_get_options(names[i], &options)) {
+				dev_err(dev, " Disabled on command-line.\n");
+				return -ENODEV;
+			}
+			if (options)
+				break;
 		}
 	}
 #endif
 
+	/* Register the device with LDM */
+	if (platform_device_register(&davincifb_device)) {
+		pr_debug("failed to register davincifb device\n");
+		return -ENODEV;
+	}
+
 	/* Register the driver with LDM */
-	if (platform_driver_register(&davincifb_driver)) {
-		pr_debug("failed to register omapfb driver\n");
+	if (driver_register(&davincifb_driver)) {
+		dev_err(dev, "failed to register davincifb driver\n");
+		platform_device_unregister(&davincifb_device);
 		return -ENODEV;
 	}
 
@@ -1723,12 +2455,13 @@ int __init davincifb_init(void)
 
 static void __exit davincifb_cleanup(void)
 {
-	platform_driver_unregister(&davincifb_driver);
+	driver_unregister(&davincifb_driver);
+	platform_device_unregister(&davincifb_device);
 }
 
 module_init(davincifb_init);
 module_exit(davincifb_cleanup);
 
 MODULE_DESCRIPTION("Framebuffer driver for TI DaVinci");
-MODULE_AUTHOR("Texas Instruments");
+MODULE_AUTHOR("MontaVista Software");
 MODULE_LICENSE("GPL");
diff --git a/drivers/video/modedb.c b/drivers/video/modedb.c
index 1618624..515a935 100644
--- a/drivers/video/modedb.c
+++ b/drivers/video/modedb.c
@@ -748,10 +748,12 @@ void fb_videomode_to_var(struct fb_var_screeninfo *var,
 {
 	var->xres = mode->xres;
 	var->yres = mode->yres;
+#if 0
 	var->xres_virtual = mode->xres;
 	var->yres_virtual = mode->yres;
 	var->xoffset = 0;
 	var->yoffset = 0;
+#endif
 	var->pixclock = mode->pixclock;
 	var->left_margin = mode->left_margin;
 	var->right_margin = mode->right_margin;
diff --git a/include/media/davinci/avnetlcd_encoder.h b/include/media/davinci/avnetlcd_encoder.h
new file mode 100644
index 0000000..1ca52c2
--- /dev/null
+++ b/include/media/davinci/avnetlcd_encoder.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef AVNETLCD_ENCODER_H
+#define AVNETLCD_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#endif
+
+#ifdef __KERNEL__
+/* encoder standard related strctures */
+#define AVNETLCD_ENCODER_MAX_NO_OUTPUTS			(1)
+#define AVNETLCD_ENCODER_GRAPHICS_NUM_STD		(1)
+
+struct avnetlcd_encoder_params {
+	int outindex;
+	char *mode;
+};
+
+struct avnetlcd_encoder_config {
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		struct vid_enc_mode_info
+		 standards[AVNETLCD_ENCODER_GRAPHICS_NUM_STD];
+	} output[AVNETLCD_ENCODER_MAX_NO_OUTPUTS];
+};
+
+struct avnetlcd_encoder_channel {
+	struct encoder_device *enc_device;
+	struct avnetlcd_encoder_params params;
+};
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef AVNETLCD_ENCODER_H */
diff --git a/include/media/davinci/davinci_display.h b/include/media/davinci/davinci_display.h
new file mode 100644
index 0000000..8524328
--- /dev/null
+++ b/include/media/davinci/davinci_display.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2005-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DAVINCI_DISPLAY_H
+#define DAVINCI_DISPLAY_H
+
+#include <linux/ioctl.h>
+
+/* Application calls this ioctl for setting the C-plane buffer offset
+ * relative to the start of Y-plane buffer address
+ */
+#define VIDIOC_S_COFST	_IOWR('V', 200, int)
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-common.h>
+#include <media/videobuf-dma-contig.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/vid_encoder_types.h>
+
+#define DAVINCI_DISPLAY_MAX_DEVICES 2
+
+enum davinci_display_device_id {
+	DAVINCI_DISPLAY_DEVICE_0,
+	DAVINCI_DISPLAY_DEVICE_1
+};
+
+#define DAVINCI_DISPLAY_MAJOR_RELEASE              1
+#define DAVINCI_DISPLAY_MINOR_RELEASE              0
+#define DAVINCI_DISPLAY_BUILD                      1
+#define DAVINCI_DISPLAY_VERSION_CODE ((DAVINCI_DISPLAY_MAJOR_RELEASE << 16) | \
+	(DAVINCI_DISPLAY_MINOR_RELEASE << 8)  | \
+	DAVINCI_DISPLAY_BUILD)
+
+#define DAVINCI_DISPLAY_VALID_FIELD(field)   ((V4L2_FIELD_NONE == field) || \
+	 (V4L2_FIELD_ANY == field) || (V4L2_FIELD_INTERLACED == field))
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a % 8))
+
+/* Exp ratio numerator and denominator constants */
+#define DAVINCI_DISPLAY_H_EXP_RATIO_N   (9)
+#define DAVINCI_DISPLAY_H_EXP_RATIO_D   (8)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_N   (6)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_D   (5)
+
+/* Zoom multiplication factor */
+#define DAVINCI_DISPLAY_ZOOM_4X (4)
+#define DAVINCI_DISPLAY_ZOOM_2X (2)
+
+#define DAVINCI_DISPLAY_PIXELASPECT_NTSC 		{11, 10}
+#define DAVINCI_DISPLAY_PIXELASPECT_PAL  		{54, 59}
+#define DAVINCI_DISPLAY_PIXELASPECT_SP    	    {1, 1}
+
+/* settings for commonly used video formats */
+#define DAVINCI_DISPLAY_WIN_NTSC     {0, 0, 720, 480}
+#define DAVINCI_DISPLAY_WIN_PAL      {0, 0, 720, 576}
+#define DAVINCI_DISPLAY_WIN_640_480  {0, 0, 640, 480}
+#define DAVINCI_DISPLAY_WIN_640_400  {0, 0, 640, 400}
+#define DAVINCI_DISPLAY_WIN_640_350  {0, 0, 640, 350}
+#define DAVINCI_DISPLAY_WIN_720P  {0, 0, 1280, 720}
+#define DAVINCI_DISPLAY_WIN_1080I  {0, 0, 1920, 1080}
+
+/* Structures */
+struct display_layer_info {
+	int enable;
+	/* Layer ID used by Display Manager */
+	enum davinci_disp_layer id;
+	struct davinci_layer_config config;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+};
+
+/* display object structure */
+struct display_obj {
+	/* Buffer specific parameters
+	 * List of buffer pointers for storing frames
+	 */
+	u32 fbuffers[VIDEO_MAX_FRAME];
+	/* number of buffers in fbuffers */
+	u32 numbuffers;
+	/* Pointer pointing to current v4l2_buffer */
+	struct videobuf_buffer *curFrm;
+	/* Pointer pointing to next v4l2_buffer */
+	struct videobuf_buffer *nextFrm;
+	/* videobuf specific parameters
+	 * Buffer queue used in video-buf
+	 */
+	struct videobuf_queue buffer_queue;
+	/* Queue of filled frames */
+	struct list_head dma_queue;
+	/* Used in video-buf */
+	spinlock_t irqlock;
+	/* V4l2 specific parameters */
+	/* Identifies video device for this layer */
+	struct video_device *video_dev;
+	/* This field keeps track of type of buffer exchange mechanism user
+	 * has selected
+	 */
+	enum v4l2_memory memory;
+	/* Used to keep track of state of the priority */
+	struct v4l2_prio_state prio;
+	/* Used to store pixel format */
+	struct v4l2_pix_format pix_fmt;
+	enum v4l2_field buf_field;
+	/* Video layer configuration params */
+	struct display_layer_info layer_info;
+	/* vpbe specific parameters
+	 * enable window for display
+	 */
+	unsigned char window_enable;
+	/* number of open instances of the layer */
+	u32 usrs;
+	/* number of users performing IO */
+	u32 io_usrs;
+	/* Indicates id of the field which is being displayed */
+	u32 field_id;
+	/* Indicates whether streaming started */
+	u8 started;
+	/* Identifies device object */
+	enum davinci_display_device_id device_id;
+};
+
+/* File handle structure */
+struct davinci_fh {
+	/* pointer to layer object for opened device */
+	struct display_obj *layer;
+	/* Indicates whether this file handle is doing IO */
+	u8 io_allowed;
+	/* Used to keep track priority of this instance */
+	enum v4l2_priority prio;
+};
+
+/* vpbe device structure */
+struct davinci_display {
+	/* layer specifc parameters */
+	/* lock used to access this structure */
+	struct mutex lock;
+	/* Display mode information */
+	struct vid_enc_mode_info mode_info;
+	/* C-Plane offset from start of y-plane */
+	unsigned int cbcr_ofst;
+	/* interrupt callback */
+	struct davinci_disp_callback event_callback;
+	struct display_obj *dev[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+struct buf_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 min_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 layer_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+#endif				/* End of __KERNEL__ */
+#endif				/* DAVINCI_DISPLAY_H */
diff --git a/include/media/davinci/davinci_enc.h b/include/media/davinci/davinci_enc.h
new file mode 100644
index 0000000..6878d3e
--- /dev/null
+++ b/include/media/davinci/davinci_enc.h
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * davinci_enc.h.
+ * This file contains APIs exported by Davinci Encoder Manager. Davinci Encoder
+ * manager uses the services from encoder interface for implementing it's
+ * functionality.
+ * It also configure the VENC/DLCD to support a specific video/graphics mode
+ * This interface allows set/get of output, mode , parameters and controls at
+ * the encoder. encoder may support multiple channels, each with a set of
+ * encoders So encoder manager support registration of encoders and APIs
+ * on a per channel basis.
+ */
+
+#ifndef DAVINCI_ENC_H
+#define DAVINCI_ENC_H
+
+#ifdef __KERNEL__
+#include <media/davinci/vid_encoder_types.h>
+
+/**
+ *  Maximum channels supported by encoder manager. Set to 1 for DM355 & DM6446.
+ * If a platform support multiple channel, this needs to be changed. Channel
+ * number starts with 0
+ */
+#define DAVINCI_ENC_MAX_CHANNELS	1
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set
+ * encoder parameters.
+ */
+int davinci_enc_setparams(int channel, void *params);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get
+ * encoder parameters.
+ */
+int davinci_enc_getparams(int channel, void *params);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info);
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure. This is updated by
+ * encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+ */
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * to set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to configure the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During configuration of the SoC hardware for timing,
+ * mgr would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name. size
+ * VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+ *   output name
+ */
+int davinci_enc_get_output(int channel, char *output);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+ * configuration of the VENC or related hardware in the VPSS and re-enabled
+ * using this API. This will switch the output DACs Off or On based on the
+ * flag.
+ */
+int davinci_enc_enable_output(int channel, int flag);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_hbi
+ * @channel: channel number (0 to MAX_CHANNELS-1)
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *service);
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @service: pointer to the structure vid_enc_sliced_vbi_service
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *services);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @channel: channel number.
+ * @data: pointer to the structure vid_enc_sliced_vbi_data
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data);
+
+#endif				/* #ifdef __KERNEL__ */
+#endif				/* #ifdef DAVINCI_ENC_H */
diff --git a/include/media/davinci/davinci_enc_mngr.h b/include/media/davinci/davinci_enc_mngr.h
new file mode 100644
index 0000000..b3fdad7
--- /dev/null
+++ b/include/media/davinci/davinci_enc_mngr.h
@@ -0,0 +1,56 @@
+
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DAVINCI_ENC_MNGR_H
+#define DAVINCI_ENC_MNGR_H
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <mach/hardware.h>
+#include <mach/mux.h>
+#include <mach/cpu.h>
+#include <mach/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+
+#ifdef __KERNEL__
+
+#define DAVINCI_ENC_MAX_ENCODERS (4)
+
+struct vid_enc_device_mgr {
+	struct semaphore lock;
+	int num_encoders;	/* number of encoders in this channel */
+	int current_encoder;	/* index to current encoder */
+	char current_output[VID_ENC_NAME_MAX_CHARS];	/* current output */
+	struct vid_enc_mode_info current_mode;	/* current mode */
+	struct vid_encoder_device *encoder[DAVINCI_ENC_MAX_ENCODERS];
+};
+
+struct enc_config {
+	char output[VID_ENC_NAME_MAX_CHARS];
+	char mode[VID_ENC_NAME_MAX_CHARS];
+};
+
+#endif				/* __KERNEL__ */
+
+#endif
diff --git a/include/media/davinci/davinci_platform.h b/include/media/davinci/davinci_platform.h
new file mode 100644
index 0000000..0b9960d
--- /dev/null
+++ b/include/media/davinci/davinci_platform.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef DAVINCI_PLATFORM_H
+#define DAVINCI_PLATFORM_H
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <mach/hardware.h>
+#include <mach/mux.h>
+#include <mach/cpu.h>
+#include <mach/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/davinci_enc_mngr.h>
+
+#ifdef __KERNEL__
+int davinci_enc_select_venc_clock(int clk);
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode);
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr);
+
+u32 venc_reg_in(u32 offset);
+u32 venc_reg_out(u32 offset, u32 val);
+u32 venc_reg_merge(u32 offset, u32 val, u32 mask);
+#endif				/* End of __KERNEL__ */
+
+#endif				/* End of ifndef DAVINCI_PLATFORM_H */
diff --git a/include/media/davinci/logicpd_encoder.h b/include/media/davinci/logicpd_encoder.h
new file mode 100644
index 0000000..7023abe
--- /dev/null
+++ b/include/media/davinci/logicpd_encoder.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LOGICPD_ENCODER_H
+#define LOGICPD_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#endif
+
+#ifdef __KERNEL__
+/* encoder standard related strctures */
+#define LOGICPD_ENCODER_MAX_NO_OUTPUTS		    (1)
+#define LOGICPD_ENCODER_GRAPHICS_NUM_STD		(4)
+
+struct logicpd_encoder_params {
+	int outindex;
+	char *mode;
+};
+
+struct logicpd_encoder_config {
+	int no_of_outputs;
+	struct {
+		char *output_name;
+		int no_of_standard;
+		struct vid_enc_mode_info
+		 standards[LOGICPD_ENCODER_GRAPHICS_NUM_STD];
+	} output[LOGICPD_ENCODER_MAX_NO_OUTPUTS];
+};
+
+struct logicpd_encoder_channel {
+	struct encoder_device *enc_device;
+	struct logicpd_encoder_params params;
+};
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef LOGICPD_ENCODER_H */
diff --git a/include/media/davinci/vid_encoder_if.h b/include/media/davinci/vid_encoder_if.h
new file mode 100644
index 0000000..618b29c
--- /dev/null
+++ b/include/media/davinci/vid_encoder_if.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * File: vid_encoder_if.h
+ * Description:
+ * ============
+ * This file defines the interface to allow abstraction of an encoder hardware
+ * to an encoder module. Each encoder module support one or more display
+ * channels. It registers with the encoder manager at init and
+ * unregisters at exit. Encoder modules implement a set of operations defines
+ * by this interface. For each display channel, encoder manager selects
+ * one of the encoder registered with it to support the user specified output
+ * and video/graphics modes on that output. First step is to set the output
+ * as requested by the user. To do so, encoder manager iterates through
+ * all supported encoders to match a given output name as requested by the user
+ * by calling enumoutput(). Once there is a match, this encoder is set as the
+ * current active encoder. Encoder manager calls initialize() to init the
+ * encoder and then calls setouput() set the output. If another encoder was
+ * active before this, encoder manager calls deinitialize() to make it
+ * inactive. Encoder must select a default mode for this output as part of
+ * setoutput() call. To set a mode, user call setmode(). All output names and
+ * mode names are defined in vid_encoder_types.h
+ */
+
+#ifndef VID_ENCODER_IF_H
+#define VID_ENCODER_IF_H
+
+#ifdef __KERNEL__
+#include <media/davinci/vid_encoder_types.h>
+
+struct vid_encoder_device;
+/**
+ * struct vid_enc_param_ops
+ * @setparams:
+ * @getparams:
+ *
+ * Description:
+ * Operation used for setting and getting encoder specific parameters.
+ * Operations are applied to the current encoder selected by the
+ * encoder manager
+ * @setparams: pointer to setparams function. This Set Encoder parameters.
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ * @getparams: pointer to getparams function. This Get encoder parameters
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_param_ops {
+	int (*setparams) (void *params, struct vid_encoder_device * enc);
+	int (*getparams) (void *params, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_mode_ops
+ * @setmode:
+ * @getmode:
+ *
+ * Description:
+ *  video/graphics mode ops structure. Operations are applied to the
+ *  current output selected by the encoder
+ * @setmode: Function pointer to setmode. set video/graphics mode or standard
+ *    for current output encoder first check if the std flag is present in the
+ *    mode_info. if yes, it will use name field to match a standard mode. If std
+ *    flag is reset, it may reject the command if non-standard mode
+ *    is not implemented. If non-standard mode is implemented, it would
+ *    save the timing information in the internal structure with a
+ *    key,VID_ENC_STD_NON_STANDARD as defined in vid_encoder_types.h
+ *    It is expected that only one such instance is defined in the video driver.
+ *    Please consider defining a mode in the vid_encoder_types.h
+ *    and use that instead if encoder is to be extended to support additional
+ *    modes not already supported by existing encoders.
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ * @getmode: Function pointer to getmode. get current video/graphics mode
+ *    information at the outpu.t
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_mode_ops {
+	int (*setmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+	int (*getmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_control_ops
+ * @setcontrol:
+ * @getcontrol:
+ *
+ * Description:
+ * Control ops structure. Control operations are performed for the current
+ * output. Control brightness, hue, contrast, saturation etc.
+ * @setcontrol: Function pointer to setcontrol. Set control value.
+ *   ctrl - control type.
+ *   val - value to be set for the control.
+ *   enc - ptr to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getcontrol: Function pointer to getcontrol. Get control value.
+ *   ctrl - control type.
+ *   val - ptr to value that gets updated
+ *   enc - ptr to encoder device
+ *   Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_control_ops {
+	int (*setcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char val, struct vid_encoder_device * enc);
+	int (*getcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char *val, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_output_ops
+ * @count: Indicates number of outputs supported
+ * @enumoutput:
+ * @setoutput:
+ * @getoutput:
+ *
+ * Description:
+ * output ops structure. enumoutput() is called to iterate
+ * through all outputs supported by the encoder. Encoder manager ues
+ * this API to select an encoder based on the output to be supported.
+ * setoutput is called to set output at the encoder. getoutput is called
+ * for getting the current output at the encoder.
+ * @enumoutput:
+ *   Function pointer.
+ *   index - index of the output.
+ *   output - ptr to char array to hold output name.(size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ *   enumerates the outputs supported by encoder. To iterate the output, caller
+ *   call this successively, starting with an index set to 0, and incrementing
+ *   the same until this function returns non-zero. Each time name of the output
+ *   at the given index is copied to output. Beware that this API assumes the
+*   passed in output array size is VID_ENC_NAME_MAX_CHARS.
+ * @setoutput:
+ *   Function pointer.
+ *   setoutput to the given output identifed by name. Encoder also must set a
+ *   default mode on the selected output.
+*   output - ptr to output name string.
+*   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getoutput:
+ *   Function pointer.
+ *   getoutput returns name of current output selected at the encoder.
+ *   output - ptr to char array to hold the output name. (size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_output_ops {
+	int count;
+	int (*enumoutput) (int index,
+			   char *output, struct vid_encoder_device * enc);
+	int (*setoutput) (char *output, struct vid_encoder_device * enc);
+	int (*getoutput) (char *output, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_misc_ops
+ * @reset:
+ * @enable: *
+ * Description:
+ *  misc ops structure. Applied for the current encoder selected by the
+ *  encoder manager
+ * @reset: Function pointer to reset.
+ *    For soft reset. Encoder may implement a soft reset that doesn't affect
+ *    any configured registers. Some of the encoder hardware may require
+ *    this if the input signal timings are changed after configuring it's
+ *    mode registers.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ * @enable: Function pointer to enable.
+ *    enable/disable output. To eliminate noise on the display during SoC mode
+ *    timing configuration, user may call this function to switch Off/On
+ *    the output. Encoder must implement this API call if there is a hardware
+ *    support for the same.
+ *    flag - 0 - disable, 1 - enable.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_misc_ops {
+	int (*reset) (struct vid_encoder_device * enc);
+	int (*enable) (int flag, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_encoder_device
+ * @name: Name of the encoder device
+ * @channel_id:  Id of the channel to which encoder is connected
+ * @capabilities: encoder capabilities. This is only for VBI capabilities
+ * @initialize: Pointer to initialize function to initialize encoder
+ * @mode_ops: Set of functions pointers for standard related functions
+ * @ctrl_ops: Set of functions pointers for control related functions
+ * @output_ops: Set of functions pointers for output related functions
+ * @fmt_ops: Set of functions pointers for format related functions
+ * @params_ops: Set of functions pointers for params related functions
+ * @misc_ops: Set of functions pointers for miscellaneous functions functions
+ * @deinitialize: functions pointer to de-initialize functio
+ * @start_display: function to start display.
+ * @stop_display: function to stop display.
+ * @write_vbi_data: function to write sliced vbi data.
+ * @enable_vbi: Function to enable support for RAW VBI.
+ * @enable_hbi: Function to enable support for RAW HBI.
+ * @set_vbi_services: function to enable sliced vbi services
+ *
+ * Description:
+ * output ops structure
+ *   Channel_id is used when encoder support multiple channels. In this case
+ *   encoder module will use the channel id to select the channel for
+ *   which the operation applies.
+ *   initialize() called by encoder manager to initialize the encoder. Usually
+ *   called before invoking any operations on the encoder.flag may be used by
+ *   the encoder module to do different level of initialization. Encoder
+ *   module must set a default output and mode in this code.
+ *   deinitialize() called to deinitialize the current encoder that is active
+ *   before initializing the new encoder.
+ */
+struct vid_encoder_device {
+	u8 name[VID_ENC_NAME_MAX_CHARS];
+	int channel_id;
+	u32 capabilities;
+	int (*initialize) (struct vid_encoder_device * enc, int flag);
+	struct vid_enc_mode_ops *mode_ops;
+	struct vid_enc_control_ops *ctrl_ops;
+	struct vid_enc_output_ops *output_ops;
+	struct vid_enc_param_ops *params_ops;
+	struct vid_enc_misc_ops *misc_ops;
+	int (*write_vbi_data) (struct vid_enc_sliced_vbi_data * data,
+			       struct vid_encoder_device * enc);
+	int (*enable_vbi) (int flag, struct vid_encoder_device * enc);
+	int (*enable_hbi) (int flag, struct vid_encoder_device * enc);
+	int (*set_vbi_services) (struct vid_enc_sliced_vbi_service * services,
+				 struct vid_encoder_device * enc);
+	int (*get_sliced_cap) (struct vid_enc_sliced_vbi_service *,
+			       struct vid_encoder_device * enc);
+	int (*deinitialize) (struct vid_encoder_device * enc);
+	int (*start_display) (struct vid_encoder_device * enc);
+	int (*stop_display) (struct vid_encoder_device * enc);
+};
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device
+			     *encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device
+			       *encoder);
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_IF_H */
diff --git a/include/media/davinci/vid_encoder_types.h b/include/media/davinci/vid_encoder_types.h
new file mode 100644
index 0000000..de8675a
--- /dev/null
+++ b/include/media/davinci/vid_encoder_types.h
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * vid_encoder_types.h
+ * This file contains data types which will be used across encoder manager
+ * , encoders and users of both interfaces */
+
+#ifndef VID_ENCODER_TYPES_H
+#define VID_ENCODER_TYPES_H
+
+#ifdef __KERNEL__
+
+/**
+ * enum vid_enc_init_flag
+ * @VID_ENC_I2C_BIND_FLAG: Only I2C bind
+ * @VID_ENC_FULL_INIT_FLAG: Full initialization
+ *
+ * Description:
+ * An enumeration of the encoder initialization flag.
+ */
+enum vid_enc_init_flag {
+	VID_ENC_I2C_BIND_FLAG,
+	VID_ENC_FULL_INIT_FLAG,
+};
+
+/**
+ * enum vid_enc_frame_type
+ * @VID_ENC_FRAME_INTERLACED: Interlaced frame
+ * @VID_ENC_FRAME_PROGRESSIVE: Progressive frame
+ *
+ * Description:
+ * An enumeration of the Frame Formats.
+ */
+enum vid_enc_frame_type {
+	VID_ENC_FRAME_INTERLACED,
+	VID_ENC_FRAME_PROGRESSIVE,
+};
+
+/** VID_ENC_NAME_MAX_CHARS
+ *
+ * Description:
+ * MAX characters in the name.
+ */
+#define VID_ENC_NAME_MAX_CHARS	30
+
+/**
+ * enum vid_enc_if_type
+ * @VID_ENC_IF_INT: for internal DAC
+ * @VID_ENC_IF_BT656: for BT656 input format
+ * @VID_ENC_IF_BT1120: for BT1120 input format
+ * @VID_ENC_IF_YCC8: for YCC8 input format
+ * @VID_ENC_IF_YCC16: for YCC16 input format
+ * @VID_ENC_IF_SRGB: for SRGB input format
+ * @VID_ENC_IF_PRGB: for PRGB input format
+ *
+ * Description:
+ * An enumeration of the encoder interface types.
+ *
+ */
+enum vid_enc_if_type {
+	VID_ENC_IF_INT,
+	VID_ENC_IF_BT656,
+	VID_ENC_IF_BT1120,
+	VID_ENC_IF_YCC8,
+	VID_ENC_IF_YCC16,
+	VID_ENC_IF_SRGB,
+	VID_ENC_IF_PRGB,
+};
+
+/**
+ * constant strings for standard names or mode names. All modules uses this to
+ * refer a specific standard or mode name
+ */
+#define VID_ENC_STD_NTSC         "NTSC"
+#define VID_ENC_STD_NTSC_RGB     "NTSC-RGB"
+#define VID_ENC_STD_PAL          "PAL"
+#define VID_ENC_STD_PAL_RGB      "PAL-RGB"
+#define VID_ENC_STD_720P_24      "720P-24"
+#define VID_ENC_STD_720P_25      "720P-25"
+#define VID_ENC_STD_720P_30      "720P-30"
+#define VID_ENC_STD_720P_50      "720P-50"
+#define VID_ENC_STD_720P_60      "720P-60"
+#define VID_ENC_STD_1080I_25     "1080I-25"
+#define VID_ENC_STD_1080I_30     "1080I-30"
+#define VID_ENC_STD_1080P_24	 "1080P-24"
+#define VID_ENC_STD_1080P_25     "1080P-25"
+#define VID_ENC_STD_1080P_30     "1080P-30"
+#define VID_ENC_STD_1080P_50     "1080P-50"
+#define VID_ENC_STD_1080P_60     "1080P-60"
+#define VID_ENC_STD_480P_60      "480P-60"
+#define VID_ENC_STD_576P_50      "576P-50"
+#define VID_ENC_STD_640x480      "640x480"
+#define VID_ENC_STD_640x400      "640x400"
+#define VID_ENC_STD_640x350      "640x350"
+#define VID_ENC_STD_800x480      "800x480"
+#define VID_ENC_STD_NON_STANDARD "NON-STANDARD"
+
+/**
+ * enum vid_enc_ctrl_id
+ * @VID_ENC_CTRL_GAIN: Gain control
+ * @VID_ENC_CTRL_BRIGHTNESS: Brighness control
+ * @VID_ENC_CTRL_CONTRAST: Contrast control
+ * @VID_ENC_CTRL_HUE: Hue control
+ * @VID_ENC_CTRL_SATURATION: Saturation Control
+ *
+ * Description:
+ * Constants used for control type IDs
+*/
+enum vid_enc_ctrl_id {
+	VID_ENC_CTRL_GAIN,
+	VID_ENC_CTRL_BRIGHTNESS,
+	VID_ENC_CTRL_CONTRAST,
+	VID_ENC_CTRL_HUE,
+	VID_ENC_CTRL_SATURATION,
+};
+
+/**
+ * constant strings for output names. All modules uses this to
+ * refer a specific output at the encoder hardware or VPBE analog output.
+ * May add additional output names as per following convention. First
+ * output of a type is always with out a suffix, and subsequent outputs
+ * of the same type is defined with suffix x increasing from 1 to max
+ * output names supported as shown below.
+ */
+#define VID_ENC_OUTPUT_COMPOSITE  "COMPOSITE"
+#define VID_ENC_OUTPUT_COMPOSITE1 "COMPOSITE1"
+#define VID_ENC_OUTPUT_SVIDEO     "SVIDEO"
+#define VID_ENC_OUTPUT_SVIDEO1    "SVIDEO1"
+#define	VID_ENC_OUTPUT_COMPONENT  "COMPONENT"
+#define	VID_ENC_OUTPUT_COMPONENT1 "COMPONENT1"
+#define VID_ENC_OUTPUT_LCD        "LCD"
+#define VID_ENC_OUTPUT_LCD1       "LCD1"
+
+/**
+ * struct vid_enc_fract
+ * @numerator: numerator part of a fractional number
+ * @denominator: denominator part of a fractional number
+ *
+ * Description:
+ *  Structure used to represent fractional numbers
+ */
+struct vid_enc_fract {
+	unsigned int numerator;
+	unsigned int denominator;
+};
+
+/* Set of macros for sliced vbi services */
+#define VID_ENC_SLICED_VBI_WSS_PAL	0x0001
+#define VID_ENC_SLICED_VBI_CGMS_NTSC	0x0002
+#define VID_ENC_SLICED_VBI_CC_NTSC	0x0004
+
+/**
+ * struct vid_enc_sliced_vbi_service
+ * @service_set: set of services to be enabled in encoder
+ * @line: line number of the field in which data for these
+ * services is to be included.
+ *
+ * Description:
+ *  Structure used to enable set of sliced VBI services in encoder
+ */
+struct vid_enc_sliced_vbi_data {
+
+	unsigned int service_id;
+	unsigned char field;
+	unsigned char data[48];
+};
+
+struct vid_enc_sliced_vbi_service {
+	unsigned short service_set;
+	unsigned int line[2][23];
+};
+
+/**
+ * struct vid_enc_mode_info
+ * @name: ptr to name string of the standard, "NTSC", "PAL" etc
+ * @std: standard or non-standard mode. 1 - standard, 0 - nonstandard
+ * @if_type: interface type used for this standard configuration
+ * @interlaced: 1 - interlaced, 0 - non interlaced/progressive
+ * @xres: x or horizontal resolution of the display
+ * @yres: y or vertical resolution of the display
+ * @fps: frame per second
+ * @left_margin: left margin of the display
+ * @right_margin: right margin of the display
+ * @upper_margin: upper margin of the display
+ * @lower_margin: lower margin of the display
+ * @hsync_len: h-sync length
+ * @vsync_len: v-sync length
+ * @flags: bit field: bit usage is documented below
+ *
+ * Description:
+ *  Structure holding timing and resolution information of a standard.
+ *  Notes
+ *  ------
+ *  if_type should be used only by encoder manager and encoder.
+ *  flags usage
+ *     b0 (LSB) - hsync polarity, 0 - negative, 1 - positive
+ *     b1       - vsync polarity, 0 - negative, 1 - positive
+ *     b2       - field id polarity, 0 - negative, 1  - positive
+ */
+struct vid_enc_mode_info {
+	unsigned char *name;
+	unsigned int std;
+	enum vid_enc_if_type if_type;
+	unsigned int interlaced;
+	unsigned int xres;
+	unsigned int yres;
+	struct vid_enc_fract fps;
+	unsigned int left_margin;
+	unsigned int right_margin;
+	unsigned int upper_margin;
+	unsigned int lower_margin;
+	unsigned int hsync_len;
+	unsigned int vsync_len;
+	unsigned int flags;
+};
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_TYPES_H */
diff --git a/include/media/davinci/vpbe_encoder.h b/include/media/davinci/vpbe_encoder.h
new file mode 100644
index 0000000..21dfeae
--- /dev/null
+++ b/include/media/davinci/vpbe_encoder.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef VPBE_ENCODER_H
+#define VPBE_ENCODER_H
+
+#ifdef __KERNEL__
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#endif
+
+#ifdef __KERNEL__
+/* encoder standard related strctures */
+#define VPBE_ENCODER_MAX_NO_OUTPUTS		            (3)
+#define VPBE_ENCODER_MAX_NUM_STD			(13)
+#define VPBE_DM355_ENCODER_MAX_NO_OUTPUTS		    (1)
+#define VPBE_DM355_ENCODER_COMPOSITE_NUM_STD        (2)
+#define VPBE_DM355_ENCODER_MAX_NUM_STD              (2)
+
+#define VPBE_DM644X_ENCODER_MAX_NO_OUTPUTS		    (3)
+#define VPBE_DM644X_ENCODER_COMPONENT_NUM_STD		(6)
+#define VPBE_DM644X_ENCODER_SVIDEO_NUM_STD		    (2)
+#define VPBE_DM644X_ENCODER_COMPOSITE_NUM_STD       (2)
+
+#define VPBE_DM365_ENCODER_MAX_NO_OUTPUTS		(3)
+#define VPBE_DM365_ENCODER_COMPOSITE_NUM_STD		(2)
+#define VPBE_DM365_ENCODER_COMPONENT_NUM_STD		(9)
+#define VPBE_DM365_ENCODER_SVIDEO_NUM_STD		(2)
+
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef VPBE_VENC_H */
diff --git a/include/media/davinci/vpss.h b/include/media/davinci/vpss.h
new file mode 100644
index 0000000..3f4b0ad
--- /dev/null
+++ b/include/media/davinci/vpss.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * vpss - video processing subsystem module header file.
+ *
+ * Include this header file if a driver needs to configure vpss system
+ * module. It exports a set of library functions  for video drivers to
+ * configure vpss system module functions such as clock enable/disable,
+ * vpss interrupt mux to arm, and other common vpss system module
+ * functions.
+ */
+#ifndef _VPSS_H
+#define _VPSS_H
+
+
+/* selector for ccdc input selection on DM355 */
+enum vpss_ccdc_source_sel {
+	VPSS_CCDCIN,
+	VPSS_HSSIIN,
+	VPSS_PGLPBK,
+	VPSS_CCDCPG
+};
+
+struct vpss_sync_pol {
+	unsigned int ccdpg_hdpol:1;
+	unsigned int ccdpg_vdpol:1;
+};
+
+struct vpss_pg_frame_size {
+	short hlpfr;
+	short pplen;
+};
+
+/* Used for enable/diable VPSS Clock */
+enum vpss_clock_sel {
+	/* DM355/DM365 */
+	VPSS_CCDC_CLOCK,
+	VPSS_IPIPE_CLOCK,
+	VPSS_H3A_CLOCK,
+	VPSS_CFALD_CLOCK,
+	/*
+	 * When using VPSS_VENC_CLOCK_SEL in vpss_enable_clock() api
+	 * following applies:-
+	 * en = 0 selects ENC_CLK
+	 * en = 1 selects ENC_CLK/2
+	 */
+	VPSS_VENC_CLOCK_SEL,
+	VPSS_VPBE_CLOCK,
+	/* DM365 only clocks */
+	VPSS_IPIPEIF_CLOCK,
+	VPSS_RSZ_CLOCK,
+	VPSS_BL_CLOCK,
+	/*
+	 * When using VPSS_PCLK_INTERNAL in vpss_enable_clock() api
+	 * following applies:-
+	 * en = 0 disable internal PCLK
+	 * en = 1 enables internal PCLK
+	 */
+	VPSS_PCLK_INTERNAL,
+	/*
+	 * When using VPSS_PSYNC_CLOCK_SEL in vpss_enable_clock() api
+	 * following applies:-
+	 * en = 0 enables MMR clock
+	 * en = 1 enables VPSS clock
+	 */
+	VPSS_PSYNC_CLOCK_SEL,
+	VPSS_LDC_CLOCK_SEL,
+	VPSS_OSD_CLOCK_SEL,
+	VPSS_FDIF_CLOCK,
+	VPSS_LDC_CLOCK
+};
+
+/* select input to ccdc on dm355 */
+int vpss_select_ccdc_source(enum vpss_ccdc_source_sel src_sel);
+/* enable/disable a vpss clock, 0 - success, -1 - failure */
+int vpss_enable_clock(enum vpss_clock_sel clock_sel, int en);
+/* set sync polarity, only applicable for DM365*/
+void vpss_set_sync_pol(struct vpss_sync_pol);
+/* set the PG_FRAME_SIZE register, only implemented for DM365 */
+void vpss_set_pg_frame_size(struct vpss_pg_frame_size);
+
+/* wbl reset for dm644x */
+enum vpss_wbl_sel {
+	VPSS_PCR_AEW_WBL_0 = 16,
+	VPSS_PCR_AF_WBL_0,
+	VPSS_PCR_RSZ4_WBL_0,
+	VPSS_PCR_RSZ3_WBL_0,
+	VPSS_PCR_RSZ2_WBL_0,
+	VPSS_PCR_RSZ1_WBL_0,
+	VPSS_PCR_PREV_WBL_0,
+	VPSS_PCR_CCDC_WBL_O,
+};
+/* clear wbl overflow flag for DM6446 */
+int vpss_clear_wbl_overflow(enum vpss_wbl_sel wbl_sel);
+
+enum dm355_int_mem_sel {
+	DM355_INT_MEM_IPIPE,
+	DM355_INT_MEM_CFALD,
+};
+void vpss_dm355_assign_int_memory_master(enum dm355_int_mem_sel master);
+
+enum dm355_dfc_mem_sel {
+	DM355_DFC_MEM_IPIPE,
+	DM355_DFC_MEM_CCDC,
+};
+void vpss_dm355_assign_dfc_memory_master(enum dm355_dfc_mem_sel master);
+
+enum dm355_rblctrl {
+	DM355_RBLCTRL_IPIPEIF,
+	DM355_RBLCTRL_CFALD,
+	DM355_RBLCTRL_H3A,
+};
+void vpss_dm355_assign_rblctrl_master(enum dm355_rblctrl master);
+
+enum dm355_wblctrl {
+	DM355_WBLCTRL_IPIPE,
+	DM355_WBLCTRL_CFALD,
+};
+void vpss_dm355_assign_wblctrl_master(enum dm355_wblctrl master);
+void vpss_dm355_ipipe_enable_any_address(int en);
+/**
+ * vpss_check_and_clear_interrupt - check and clear interrupt
+ * @irq - common enumerator for IRQ
+ *
+ * Following return values used:-
+ * 0 - interrupt occured and cleared
+ * 1 - interrupt not occured 
+ * 2 - interrupt status not available
+ */
+int vpss_dma_complete_interrupt(void);
+
+#endif
diff --git a/include/video/davinci_osd.h b/include/video/davinci_osd.h
new file mode 100644
index 0000000..40f29e6
--- /dev/null
+++ b/include/video/davinci_osd.h
@@ -0,0 +1,910 @@
+/*
+ * Header file for the TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef _DAVINCI_OSD_H
+#define _DAVINCI_OSD_H
+
+enum soc_type {
+	DM6446 = 0,
+	DM355,
+	DM365,
+};
+
+struct davinci_osd_platform_data {
+	enum soc_type type;
+};
+
+/**
+ * enum davinci_disp_layer
+ * @WIN_OSD0: On-Screen Display Window 0
+ * @WIN_VID0: Video Window 0
+ * @WIN_OSD1: On-Screen Display Window 1
+ * @WIN_VID1: Video Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci display layers.
+ */
+enum davinci_disp_layer {
+	WIN_OSD0,
+	WIN_VID0,
+	WIN_OSD1,
+	WIN_VID1,
+};
+
+/**
+ * enum davinci_osd_layer
+ * @OSDWIN_OSD0: On-Screen Display Window 0
+ * @OSDWIN_OSD1: On-Screen Display Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci OSD layers.
+ */
+enum davinci_osd_layer {
+	OSDWIN_OSD0,
+	OSDWIN_OSD1,
+};
+
+/**
+ * enum davinci_pix_format
+ * @PIXFMT_1BPP: 1-bit-per-pixel bitmap
+ * @PIXFMT_2BPP: 2-bits-per-pixel bitmap
+ * @PIXFMT_4BPP: 4-bits-per-pixel bitmap
+ * @PIXFMT_8BPP: 8-bits-per-pixel bitmap
+ * @PIXFMT_RGB565: 16-bits-per-pixel RGB565
+ * @PIXFMT_YCbCrI: YUV 4:2:2
+ * @PIXFMT_RGB888: 24-bits-per-pixel RGB888
+ * @PIXFMT_YCrCbI: YUV 4:2:2 with chroma swap
+ * @PIXFMT_NV12: YUV 4:2:0 planar
+ * @PIXFMT_OSD_ATTR: OSD Attribute Window pixel format (4bpp)
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel formats.
+ */
+enum davinci_pix_format {
+	PIXFMT_1BPP = 0,
+	PIXFMT_2BPP,
+	PIXFMT_4BPP,
+	PIXFMT_8BPP,
+	PIXFMT_RGB565,
+	PIXFMT_YCbCrI,
+	PIXFMT_RGB888,
+	PIXFMT_YCrCbI,
+	PIXFMT_NV12,
+	PIXFMT_OSD_ATTR,
+};
+
+/**
+ * enum davinci_h_exp_ratio
+ * @H_EXP_OFF: no expansion (1/1)
+ * @H_EXP_9_OVER_8: 9/8 expansion ratio
+ * @H_EXP_3_OVER_2: 3/2 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available horizontal expansion ratios.
+ */
+enum davinci_h_exp_ratio {
+	H_EXP_OFF,
+	H_EXP_9_OVER_8,
+	H_EXP_3_OVER_2,
+};
+
+/**
+ * enum davinci_v_exp_ratio
+ * @V_EXP_OFF: no expansion (1/1)
+ * @V_EXP_6_OVER_5: 6/5 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available vertical expansion ratios.
+ */
+enum davinci_v_exp_ratio {
+	V_EXP_OFF,
+	V_EXP_6_OVER_5,
+};
+
+/**
+ * enum davinci_zoom_factor
+ * @ZOOM_X1: no zoom (x1)
+ * @ZOOM_X2: x2 zoom
+ * @ZOOM_X4: x4 zoom
+ *
+ * Description:
+ * An enumeration of the available zoom factors.
+ */
+enum davinci_zoom_factor {
+	ZOOM_X1,
+	ZOOM_X2,
+	ZOOM_X4,
+};
+
+/**
+ * enum davinci_clut
+ * @ROM_CLUT: ROM CLUT
+ * @RAM_CLUT: RAM CLUT
+ *
+ * Description:
+ * An enumeration of the available Color Lookup Tables (CLUTs).
+ */
+enum davinci_clut {
+	ROM_CLUT,
+	RAM_CLUT,
+};
+
+/**
+ * enum davinci_rom_clut
+ * @ROM_CLUT0: Macintosh CLUT
+ * @ROM_CLUT1: CLUT from DM270 and prior devices
+ *
+ * Description:
+ * An enumeration of the ROM Color Lookup Table (CLUT) options.
+ */
+enum davinci_rom_clut {
+	ROM_CLUT0,
+	ROM_CLUT1,
+};
+
+/**
+ * enum davinci_blending_factor
+ * @OSD_0_VID_8: OSD pixels are fully transparent
+ * @OSD_1_VID_7: OSD pixels contribute 1/8, video pixels contribute 7/8
+ * @OSD_2_VID_6: OSD pixels contribute 2/8, video pixels contribute 6/8
+ * @OSD_3_VID_5: OSD pixels contribute 3/8, video pixels contribute 5/8
+ * @OSD_4_VID_4: OSD pixels contribute 4/8, video pixels contribute 4/8
+ * @OSD_5_VID_3: OSD pixels contribute 5/8, video pixels contribute 3/8
+ * @OSD_6_VID_2: OSD pixels contribute 6/8, video pixels contribute 2/8
+ * @OSD_8_VID_0: OSD pixels are fully opaque
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blending factor options.
+ */
+enum davinci_blending_factor {
+	OSD_0_VID_8,
+	OSD_1_VID_7,
+	OSD_2_VID_6,
+	OSD_3_VID_5,
+	OSD_4_VID_4,
+	OSD_5_VID_3,
+	OSD_6_VID_2,
+	OSD_8_VID_0,
+};
+
+/**
+ * enum davinci_blink_interval
+ * @BLINK_X1: blink interval is 1 vertical refresh cycle
+ * @BLINK_X2: blink interval is 2 vertical refresh cycles
+ * @BLINK_X3: blink interval is 3 vertical refresh cycles
+ * @BLINK_X4: blink interval is 4 vertical refresh cycles
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blinking interval options.
+ */
+enum davinci_blink_interval {
+	BLINK_X1,
+	BLINK_X2,
+	BLINK_X3,
+	BLINK_X4,
+};
+
+/**
+ * enum davinci_cursor_h_width
+ * @H_WIDTH_1: horizontal line width is 1 pixel
+ * @H_WIDTH_4: horizontal line width is 4 pixels
+ * @H_WIDTH_8: horizontal line width is 8 pixels
+ * @H_WIDTH_12: horizontal line width is 12 pixels
+ * @H_WIDTH_16: horizontal line width is 16 pixels
+ * @H_WIDTH_20: horizontal line width is 20 pixels
+ * @H_WIDTH_24: horizontal line width is 24 pixels
+ * @H_WIDTH_28: horizontal line width is 28 pixels
+ */
+enum davinci_cursor_h_width {
+	H_WIDTH_1,
+	H_WIDTH_4,
+	H_WIDTH_8,
+	H_WIDTH_12,
+	H_WIDTH_16,
+	H_WIDTH_20,
+	H_WIDTH_24,
+	H_WIDTH_28,
+};
+
+/**
+ * enum davinci_cursor_v_width
+ * @V_WIDTH_1: vertical line width is 1 line
+ * @V_WIDTH_2: vertical line width is 2 lines
+ * @V_WIDTH_4: vertical line width is 4 lines
+ * @V_WIDTH_6: vertical line width is 6 lines
+ * @V_WIDTH_8: vertical line width is 8 lines
+ * @V_WIDTH_10: vertical line width is 10 lines
+ * @V_WIDTH_12: vertical line width is 12 lines
+ * @V_WIDTH_14: vertical line width is 14 lines
+ */
+enum davinci_cursor_v_width {
+	V_WIDTH_1,
+	V_WIDTH_2,
+	V_WIDTH_4,
+	V_WIDTH_6,
+	V_WIDTH_8,
+	V_WIDTH_10,
+	V_WIDTH_12,
+	V_WIDTH_14,
+};
+
+/**
+ * struct davinci_cursor_config
+ * @xsize: horizontal size in pixels
+ * @ysize: vertical size in lines
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ * @h_width: horizontal line width
+ * @v_width: vertical line width
+ * @clut: the CLUT selector (ROM or RAM) for the cursor color
+ * @clut_index: an index into the CLUT for the cursor color
+ *
+ * Description:
+ * A structure describing the configuration parameters of the hardware
+ * rectangular cursor.
+ */
+struct davinci_cursor_config {
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+	enum davinci_cursor_h_width h_width;
+	enum davinci_cursor_v_width v_width;
+	enum davinci_clut clut;
+	unsigned char clut_index;
+};
+
+/**
+ * struct davinci_disp_callback
+ * @next: used internally by the display manager to maintain a liked list of
+ *        callbacks
+ * @mask: a bitmask specifying the display manager event(s) for which the
+ *        callback will be invoked
+ * @handler: the callback routine
+ * @arg: a null pointer that is passed as the second argument to the callback
+ *       routine
+ */
+struct davinci_disp_callback {
+	struct davinci_disp_callback *next;
+	unsigned mask;
+	void (*handler) (unsigned event, void *arg);
+	void *arg;
+};
+
+/* display manager events */
+#define DAVINCI_DISP_END_OF_FRAME	1
+#define DAVINCI_DISP_FIRST_FIELD	2
+#define DAVINCI_DISP_SECOND_FIELD	4
+
+/**
+ * struct davinci_layer_config
+ * @pixfmt: pixel format
+ * @line_length: offset in bytes between start of each line in memory
+ * @xsize: number of horizontal pixels displayed per line
+ * @ysize: number of lines displayed
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ *
+ * Description:
+ * A structure describing the configuration parameters of an On-Screen Display
+ * (OSD) or video layer related to how the image is stored in memory.
+ * @line_length must be a multiple of the cache line size (32 bytes).
+ */
+struct davinci_layer_config {
+	enum davinci_pix_format pixfmt;
+	unsigned line_length;
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+};
+
+/**
+ * davinci_disp_request_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Request to use an On-Screen Display (OSD) or video layer (window).
+ */
+int davinci_disp_request_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_release_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Release a layer previously obtained via davinci_disp_request_layer().
+ */
+void davinci_disp_release_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_init_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Initialize all parameters that are uniquely associated with the specified
+ * display layer to their default values.  Parameters that are common to
+ * multiple display layers (e.g. expansion ratios) are not affected.  The
+ * default state of a layer is disabled with X1 zoom.  The OSD layers default
+ * to 8-bits-per-pixel bitmap format, RAM CLUT, REC601 attenuation disabled,
+ * color key blending disabled, and are fully opaque.  Video layers maintain
+ * their current pixel format, either YCbCrI or YCrCbI, but will default to
+ * YCbCrI when first initialized.
+ * In general, it is not necessary for a display manager user to call this
+ * routine.  The display manager calls this routine automatically for every
+ * layer at initialization time and for an individual layer when the layer is
+ * released.
+ */
+void davinci_disp_init_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_enable_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Enable a video layer so that it is displayed.
+ */
+int davinci_disp_enable_layer(enum davinci_disp_layer layer, int otherwin);
+
+/**
+ * davinci_disp_disable_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Disable a video layer so that it is not displayed.
+ */
+void davinci_disp_disable_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_layer_is_enabled
+ * @layer: layer id
+ * Returns: 1 if the layer is enabled, or 0 otherwise
+ *
+ * Description:
+ * Determine whether or not a video layer is enabled..
+ */
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_set_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Configure the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On entry, the values of the
+ * members of the @lconfig struct specify the desired configuration.  On exit,
+ * the values of the members of the @lconfig struct will be updated to reflect
+ * the actual configuration, which is subject to the constraints of the
+ * DaVinci OSD controller.
+ */
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_try_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Evaluate the parameters of an On-Screen Display (OSD) or video layer
+ * configuration.  On entry, the values of the members of the @lconfig struct
+ * specify the desired configuration.  On exit, the values of the members of the
+ * @lconfig struct will be updated to reflect the closest actual configuration
+ * which could currently be set and enabled subject to the constraints of the
+ * DaVinci OSD controller.  The actual layer configuration is not modified by
+ * this routine.
+ *
+ * Note that some of the constraints depend on the current configuration of
+ * other windows, so it is possible for a configuration returned by
+ * davinci_disp_try_layer_config() to fail to be set or enabled successfully
+ * if the configuration of other windows has changed.
+ */
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_get_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ *
+ * Description:
+ * Get the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On exit, the values of the
+ * members of the @lconfig struct will be updated to reflect the current
+ * configuration.
+ */
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_start_layer
+ * @layer: layer id
+ * @fb_base_phys: physical base address of the framebuffer
+ *
+ * Description:
+ * Initialize the framebuffer base address \of an On-Screen Display (OSD) or
+ * video layer.  Display of the layer may be either enabled or disabled on
+ * entry and will be unchanged on exit.  @fb_base_phys must be cache-line
+ * (32-byte) aligned.
+ */
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys,
+			      unsigned long cbcr_ofst);
+
+/**
+ * davinci_disp_set_interpolation_filter
+ * @filter: non-zero to enable the interpolation filter, or zero to disable
+ *
+ * Description:
+ * Globally enable or disable the scaling (zoom and expansion) interpolation
+ * filter.  It applies to all OSD and video windows.
+ */
+void davinci_disp_set_interpolation_filter(int filter);
+
+/**
+ * davinci_disp_get_interpolation_filter
+ * Returns: 1 if the interpolation filter is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the enabled/disabled status of the scaling (zoom and expansion)
+ * interpolation filter.
+ */
+int davinci_disp_get_interpolation_filter(void);
+
+/**
+ * davinci_disp_set_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the OSD windows.
+ */
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the OSD windows.
+ */
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the video windows.
+ */
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the video windows.
+ */
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Set the horizontal and vertical zoom factors.
+ */
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom);
+
+/**
+ * davinci_disp_get_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Get the horizontal and vertical zoom factors.
+ */
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom);
+
+/**
+ * davinci_disp_set_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Set the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index);
+
+/**
+ * davinci_disp_get_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Get the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index);
+
+/**
+ * davinci_disp_set_rom_clut
+ * @rom_clut: the ROM CLUT selector
+ *
+ * Description:
+ * Choose which of the two ROM Color Lookup Tables will be used.
+ */
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut);
+
+/**
+ * davinci_disp_get_rom_clut
+ * Returns: the ROM CLUT selector
+ *
+ * Description:
+ * Query which of the two ROM Color Lookup Tables is currently selected.
+ */
+enum davinci_rom_clut davinci_disp_get_rom_clut(void);
+
+/**
+ * davinci_disp_set_clut_ycbcr
+ * @clut_index: an index into the CLUT
+ * @y: Luma (Y) value
+ * @cb: Blue Chroma (Cb) value
+ * @cr: Red Chroma (Cr) value
+ *
+ * Description:
+ * Set a YCbCr value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr);
+
+/**
+ * davinci_disp_set_clut_rgb
+ * @clut_index: an index into the CLUT
+ * @r: Red value
+ * @g: Green value
+ * @b: Blue value
+ *
+ * Description:
+ * Set an RGB value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b);
+
+/**
+ * davinci_disp_set_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * @clut: the CLUT selector
+ *
+ * Description:
+ * Select whether the RAM CLUT or the ROM CLUT is to be used for an OSD window.
+ * The selection is only significant if the window is using a 1-, 2-, 4-, or
+ * 8-bit pixel format.
+ */
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut);
+
+/**
+ * davinci_disp_get_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the CLUT selector
+ *
+ * Description:
+ * Query whether the RAM CLUT or the ROM CLUT is currently selected for an OSD
+ * window.  The selection is only significant if the window is using a 1-, 2-,
+ * 4-, or 8-bit pixel format.
+ */
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_enable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ * @colorkey: the transparency color key
+ *
+ * Description:
+ * Enable transparency color key blending.  Any pixel in the specified OSD
+ * window which matches the color key will be transparent (or partially
+ * transparent) and allow the underlying video pixel to be displayed based on
+ * the blending factor.
+ *
+ * Interpretation of the @colorkey argument is determined by the pixel format
+ * assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ *
+ * %PIXFMT_1BPP pixels matching @colorkey bit 0 are blended.
+ * %PIXFMT_2BPP pixels matching @colorkey bits 1-0 are blended.
+ * %PIXFMT_4BPP pixels matching @colorkey bits 3-0 are blended.
+ * %PIXFMT_8BPP pixels matching @colorkey bits 7-0 are blended.
+ * %PIXFMT_RGB565 pixels matching @colorkey bits 15-0 are blended.
+ * %PIXFMT_YCbCrI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * %PIXFMT_RGB888 pixels matching @colorkey bits 23-0 are blended.
+ * %PIXFMT_YCrCbI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * Color keying is not applicable to %PIXFMT_OSD_ATTR pixels.
+ *
+ * For DM644x processors, only the four %PIXFMT_nBPP pixel formats and
+ * %PIXFMT_RGB565 are supported.  The color key for the bitmap formats is fixed
+ * at zero on DM644x processors, so the value passed in the @colorkey argument
+ * is only significant for the %PIXFMT_RGB565 pixel format.
+ */
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey);
+
+/**
+ * davinci_disp_disable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ *
+ * Description:
+ * Disable transparency color key blending for the specified OSD layer.  All
+ * pixels in the OSD window will be blended with video pixels according to the
+ * blending factor.
+ */
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * @blend: the blending factor
+ *
+ * Description:
+ * Set the blending factor for an OSD window.  The blending factor determines
+ * the degree of opacity or transparency of OSD pixels.  Transparent or
+ * partially transparent pixels allow the underlying video pixels to be
+ * displayed based on the blending factor.  All OSD pixels are blended unless
+ * color keying is enabled, in which case only pixels matching the color key
+ * are blended.
+ */
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend);
+
+/**
+ * davinci_disp_get_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the blending factor
+ *
+ * Description:
+ * Get the blending factor for an OSD window.
+ */
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin);
+
+/**
+ * davinci_disp_set_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * @enable: non-zero to enable REC601 attenuation, or zero to disable
+ *
+ * Description:
+ * Enable or disable REC601 attenuation of data in an OSD window.
+ */
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable);
+
+/**
+ * davinci_disp_get_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: 1 if REC601 attenuation is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the REC601 attenuation status for an OSD window.
+ */
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * A 256-entry Color Lookup Table (CLUT) is used for bitmap pixel formats.
+ * Every entry in the CLUT is used when the color depth is 8 bits.  However,
+ * only a subset of the CLUT entries are needed for color depths of 1, 2,
+ * or 4 bits.  Each pixel value for color depths of 1, 2, or 4 bits can be
+ * mapped to any of the 256 CLUT entries.  Two CLUT entries are used for a
+ * color depth of 1 bit, four CLUT entries are used for a color depth of
+ * 2 bits, and sixteen CLUT entries are used for a color depth of 4 bits.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index);
+
+/**
+ * davinci_disp_get_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * Returns: an index into the CLUT
+ *
+ * Description:
+ * Given a pixel value, return the corresponding clut index from the palette
+ * map.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value);
+
+/**
+ * davinci_disp_set_blink_attribute
+ * @enable: non-zero to enable blinking, zero to disable
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Set the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink);
+
+/**
+ * davinci_disp_get_blink_attribute
+ * @enable: one if blinking is enabled, or zero if disabled
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Get the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink);
+
+/**
+ * davinci_disp_cursor_enable
+ *
+ * Description:
+ * Enable display of the hardware cursor.
+ */
+void davinci_disp_cursor_enable(void);
+
+/**
+ * davinci_disp_cursor_disable
+ *
+ * Description:
+ * Disable display of the hardware cursor.
+ */
+void davinci_disp_cursor_disable(void);
+
+/**
+ * davinci_disp_cursor_is_enabled
+ * Returns: 1 if cursor is enabled, or 0 otherwise
+ *
+ * Description:
+ * Query whether or not display of the hardware cursor is enabled.
+ */
+int davinci_disp_cursor_is_enabled(void);
+
+/**
+ * davinci_disp_set_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Set the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_get_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Get the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_set_field_inversion
+ * @enable: non-zero to enable field signal inversion, or zero to disable
+ *
+ * Description:
+ * Enable or disable field signal inversion, which inverts the polarity of the
+ * field ID signal from the video encoder.  This setting applies to all OSD and
+ * video windows.  It is only significant when the display is interlaced.
+ */
+void davinci_disp_set_field_inversion(int enable);
+
+/**
+ * davinci_disp_get_field_inversion
+ * Returns: 1 if field signal inversion is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the field signal inversion state.
+ */
+int davinci_disp_get_field_inversion(void);
+
+/**
+ * davinci_disp_register_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register a callback routine for a DaVinci display manager event.
+ * @callback->handler is a pointer to the callback routine.  The first argument
+ * passed to the callback routine is the display manager event bitmask
+ * indicating which event(s) occurred.  The second argument passed to the
+ * callback routine is @callback->arg.  @callback->mask is a bitmask specifying
+ * the events for which the caller wishes to be notified.  @callback->next is
+ * used internally by the display manager and need not be initialized by the
+ * caller.  Once a callback routine has been registered, the caller must not
+ * modify the @callback struct until the callback has been unregistered.
+ *
+ * The display manager events are %DAVINCI_DISP_END_OF_FRAME,
+ * %DAVINCI_DISP_FIRST_FIELD, and %DAVINCI_DISP_SECOND_FIELD.
+ */
+int davinci_disp_register_callback(struct davinci_disp_callback *callback);
+
+/**
+ * davinci_disp_unregister_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister a display manager callback routine previously registered with
+ * davinci_disp_register_callback().
+ */
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback);
+
+#ifdef __KERNEL__
+void osd_write_left_margin(u32 val);
+
+void osd_write_upper_margin(u32 val);
+
+u32 osd_read_left_margin(void);
+
+u32 osd_read_upper_margin(void);
+#endif
+
+#endif
diff --git a/include/video/davinci_vpbe.h b/include/video/davinci_vpbe.h
new file mode 100644
index 0000000..d2efbf1
--- /dev/null
+++ b/include/video/davinci_vpbe.h
@@ -0,0 +1,551 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef _DAVINCI_VPBE_H_
+#define _DAVINCI_VPBE_H_
+
+enum venc_soc_type {
+	DM644x = 0,
+	DM35x,
+	DM36x,
+};
+
+struct davinci_venc_platform_data {
+	enum venc_soc_type soc;
+};
+
+/* VPBE register base addresses */
+#define DM644X_VENC_REG_BASE		0x01C72400
+#define DM644X_OSD_REG_BASE		0x01C72600
+#define DM644X_VPBE_REG_BASE		0x01C72780
+
+#define DM355_VPSSCLK_REG_BASE		0x01C70000
+#define DM355_OSD_REG_BASE		0x01C70200
+#define DM355_VENC_REG_BASE		0x01C70400
+
+#define DM365_VENC_REG_BASE		0x01C71E00
+#define DM365_OSD_REG_BASE		0x01C71C00
+#define DM365_ISP5_REG_BASE		0x01C70000
+
+#define OSD_REG_SIZE			0x00000100
+
+/* SYS register addresses */
+#define SYS_VPSS_CLKCTL			0x01C40044
+
+#define DM3XX_VDAC_CONFIG		0x01C4002C
+#define DM355_USB_PHY_CTRL		0x01c40034
+
+/* VPBE Global Registers */
+#define VPBE_PID				0x0
+#define VPBE_PCR				0x4
+
+/* VPSS CLock Registers */
+#define VPSSCLK_PID				0x00
+#define VPSSCLK_CLKCTRL				0x04
+
+/* VPSS Buffer Logic Registers */
+#define VPSSBL_PID				0x00
+#define VPSSBL_PCR				0x04
+#define VPSSBL_BCR				0x08
+#define VPSSBL_INTSTAT				0x0C
+#define VPSSBL_INTSEL				0x10
+#define VPSSBL_EVTSEL				0x14
+#define VPSSBL_MEMCTRL				0x18
+#define VPSSBL_CCDCMUX				0x1C
+
+/* DM365 ISP5 system configuration */
+#define ISP5_PID				0x0
+#define ISP5_PCCR				0x4
+#define ISP5_BCR				0x8
+#define ISP5_INTSTAT				0xC
+#define ISP5_INTSEL1				0x10
+#define ISP5_INTSEL2				0x14
+#define ISP5_INTSEL3				0x18
+#define ISP5_EVTSEL				0x1c
+#define ISP5_CCDCMUX				0x20
+
+/* VPBE Video Encoder / Digital LCD Subsystem Registers (VENC) */
+#define VENC_VMOD				0x00
+#define VENC_VIDCTL				0x04
+#define VENC_VDPRO				0x08
+#define VENC_SYNCCTL				0x0C
+#define VENC_HSPLS				0x10
+#define VENC_VSPLS				0x14
+#define VENC_HINT				0x18
+#define VENC_HSTART				0x1C
+#define VENC_HVALID				0x20
+#define VENC_VINT				0x24
+#define VENC_VSTART				0x28
+#define VENC_VVALID				0x2C
+#define VENC_HSDLY				0x30
+#define VENC_VSDLY				0x34
+#define VENC_YCCCTL				0x38
+#define VENC_RGBCTL				0x3C
+#define VENC_RGBCLP				0x40
+#define VENC_LINECTL				0x44
+#define VENC_CULLLINE				0x48
+#define VENC_LCDOUT				0x4C
+#define VENC_BRTS				0x50
+#define VENC_BRTW				0x54
+#define VENC_ACCTL				0x58
+#define VENC_PWMP				0x5C
+#define VENC_PWMW				0x60
+#define VENC_DCLKCTL				0x64
+#define VENC_DCLKPTN0				0x68
+#define VENC_DCLKPTN1				0x6C
+#define VENC_DCLKPTN2				0x70
+#define VENC_DCLKPTN3				0x74
+#define VENC_DCLKPTN0A				0x78
+#define VENC_DCLKPTN1A				0x7C
+#define VENC_DCLKPTN2A				0x80
+#define VENC_DCLKPTN3A				0x84
+#define VENC_DCLKHS				0x88
+#define VENC_DCLKHSA				0x8C
+#define VENC_DCLKHR				0x90
+#define VENC_DCLKVS				0x94
+#define VENC_DCLKVR				0x98
+#define VENC_CAPCTL				0x9C
+#define VENC_CAPDO				0xA0
+#define VENC_CAPDE				0xA4
+#define VENC_ATR0				0xA8
+#define VENC_ATR1				0xAC
+#define VENC_ATR2				0xB0
+#define VENC_VSTAT				0xB8
+#define VENC_RAMADR				0xBC
+#define VENC_RAMPORT				0xC0
+#define VENC_DACTST				0xC4
+#define VENC_YCOLVL				0xC8
+#define VENC_SCPROG				0xCC
+#define VENC_CVBS				0xDC
+#define VENC_CMPNT				0xE0
+#define VENC_ETMG0				0xE4
+#define VENC_ETMG1				0xE8
+#define VENC_ETMG2				0xEC
+#define VENC_ETMG3				0xF0
+#define VENC_DACSEL				0xF4
+#define VENC_ARGBX0				0x100
+#define VENC_ARGBX1				0x104
+#define VENC_ARGBX2				0x108
+#define VENC_ARGBX3				0x10C
+#define VENC_ARGBX4				0x110
+#define VENC_DRGBX0				0x114
+#define VENC_DRGBX1				0x118
+#define VENC_DRGBX2				0x11C
+#define VENC_DRGBX3				0x120
+#define VENC_DRGBX4				0x124
+#define VENC_VSTARTA				0x128
+#define VENC_OSDCLK0				0x12C
+#define VENC_OSDCLK1				0x130
+#define VENC_HVLDCL0				0x134
+#define VENC_HVLDCL1				0x138
+#define VENC_OSDHADV				0x13C
+#define VENC_CLKCTL				0x140
+#define VENC_GAMCTL				0x144
+#define VENC_XHINTVL				0x174
+
+/* VPBE On-Screen Display Subsystem Registers (OSD) */
+#define OSD_MODE				0x00
+#define OSD_VIDWINMD				0x04
+#define OSD_OSDWIN0MD				0x08
+#define OSD_OSDWIN1MD				0x0C
+#define OSD_OSDATRMD				0x0C
+#define OSD_RECTCUR				0x10
+#define OSD_VIDWIN0OFST				0x18
+#define OSD_VIDWIN1OFST				0x1C
+#define OSD_OSDWIN0OFST				0x20
+#define OSD_OSDWIN1OFST				0x24
+#define OSD_VIDWINADH				0x28
+#define OSD_VIDWIN0ADL				0x2C
+#define OSD_VIDWIN0ADR				0x2C
+#define OSD_VIDWIN1ADL				0x30
+#define OSD_VIDWIN1ADR				0x30
+#define OSD_OSDWINADH				0x34
+#define OSD_OSDWIN0ADL				0x38
+#define OSD_OSDWIN0ADR				0x38
+#define OSD_OSDWIN1ADL				0x3C
+#define OSD_OSDWIN1ADR				0x3C
+#define OSD_BASEPX				0x40
+#define OSD_BASEPY				0x44
+#define OSD_VIDWIN0XP				0x48
+#define OSD_VIDWIN0YP				0x4C
+#define OSD_VIDWIN0XL				0x50
+#define OSD_VIDWIN0YL				0x54
+#define OSD_VIDWIN1XP				0x58
+#define OSD_VIDWIN1YP				0x5C
+#define OSD_VIDWIN1XL				0x60
+#define OSD_VIDWIN1YL				0x64
+#define OSD_OSDWIN0XP				0x68
+#define OSD_OSDWIN0YP				0x6C
+#define OSD_OSDWIN0XL				0x70
+#define OSD_OSDWIN0YL				0x74
+#define OSD_OSDWIN1XP				0x78
+#define OSD_OSDWIN1YP				0x7C
+#define OSD_OSDWIN1XL				0x80
+#define OSD_OSDWIN1YL				0x84
+#define OSD_CURXP				0x88
+#define OSD_CURYP				0x8C
+#define OSD_CURXL				0x90
+#define OSD_CURYL				0x94
+#define OSD_W0BMP01				0xA0
+#define OSD_W0BMP23				0xA4
+#define OSD_W0BMP45				0xA8
+#define OSD_W0BMP67				0xAC
+#define OSD_W0BMP89				0xB0
+#define OSD_W0BMPAB				0xB4
+#define OSD_W0BMPCD				0xB8
+#define OSD_W0BMPEF				0xBC
+#define OSD_W1BMP01				0xC0
+#define OSD_W1BMP23				0xC4
+#define OSD_W1BMP45				0xC8
+#define OSD_W1BMP67				0xCC
+#define OSD_W1BMP89				0xD0
+#define OSD_W1BMPAB				0xD4
+#define OSD_W1BMPCD				0xD8
+#define OSD_W1BMPEF				0xDC
+#define OSD_VBNDRY				0xE0
+#define OSD_EXTMODE				0xE4
+#define OSD_MISCCTL				0xE8
+#define OSD_CLUTRAMYCB				0xEC
+#define OSD_CLUTRAMCR				0xF0
+#define OSD_TRANSPVAL				0xF4
+#define OSD_TRANSPVALL				0xF4
+#define OSD_TRANSPVALU				0xF8
+#define OSD_TRANSPBMPIDX			0xFC
+#define OSD_PPVWIN0ADR				0xFC
+
+/* bit definitions */
+#define VPBE_PCR_VENC_DIV			(1 << 1)
+#define VPBE_PCR_CLK_OFF			(1 << 0)
+
+#define VPSSBL_INTSTAT_HSSIINT			(1 << 14)
+#define VPSSBL_INTSTAT_CFALDINT			(1 << 13)
+#define VPSSBL_INTSTAT_IPIPE_INT5		(1 << 12)
+#define VPSSBL_INTSTAT_IPIPE_INT4		(1 << 11)
+#define VPSSBL_INTSTAT_IPIPE_INT3		(1 << 10)
+#define VPSSBL_INTSTAT_IPIPE_INT2		(1 << 9)
+#define VPSSBL_INTSTAT_IPIPE_INT1		(1 << 8)
+#define VPSSBL_INTSTAT_IPIPE_INT0		(1 << 7)
+#define VPSSBL_INTSTAT_IPIPEIFINT		(1 << 6)
+#define VPSSBL_INTSTAT_OSDINT			(1 << 5)
+#define VPSSBL_INTSTAT_VENCINT			(1 << 4)
+#define VPSSBL_INTSTAT_H3AINT			(1 << 3)
+#define VPSSBL_INTSTAT_CCDC_VDINT2		(1 << 2)
+#define VPSSBL_INTSTAT_CCDC_VDINT1		(1 << 1)
+#define VPSSBL_INTSTAT_CCDC_VDINT0		(1 << 0)
+
+/* DM365 ISP5 bit definitions */
+#define ISP5_INTSTAT_VENCINT			(1 << 21)
+#define ISP5_INTSTAT_OSDINT			(1 << 20)
+
+#define VENC_VMOD_VDMD_SHIFT			12
+#define VENC_VMOD_VDMD_YCBCR16			0
+#define VENC_VMOD_VDMD_YCBCR8			1
+#define VENC_VMOD_VDMD_RGB666			2
+#define VENC_VMOD_VDMD_RGB8			3
+#define VENC_VMOD_VDMD_EPSON			4
+#define VENC_VMOD_VDMD_CASIO			5
+#define VENC_VMOD_VDMD_UDISPQVGA		6
+#define VENC_VMOD_VDMD_STNLCD			7
+#define VENC_VMOD_VIE_SHIFT			1
+#define VENC_VMOD_VDMD				(7 << 12)
+#define VENC_VMOD_ITLCL				(1 << 11)
+#define VENC_VMOD_ITLC				(1 << 10)
+#define VENC_VMOD_NSIT				(1 << 9)
+#define VENC_VMOD_HDMD				(1 << 8)
+#define VENC_VMOD_TVTYP_SHIFT			6
+#define VENC_VMOD_TVTYP				(3 << 6)
+#define VENC_VMOD_SLAVE				(1 << 5)
+#define VENC_VMOD_VMD				(1 << 4)
+#define VENC_VMOD_BLNK				(1 << 3)
+#define VENC_VMOD_VIE				(1 << 1)
+#define VENC_VMOD_VENC				(1 << 0)
+
+/* VMOD TVTYP options for HDMD=0 */
+#define SDTV_NTSC				0
+#define SDTV_PAL				1
+/* VMOD TVTYP options for HDMD=1 */
+#define HDTV_525P				0
+#define HDTV_625P				1
+#define HDTV_1080I				2
+#define HDTV_720P				3
+
+#define VENC_VIDCTL_VCLKP			(1 << 14)
+#define VENC_VIDCTL_VCLKE_SHIFT			13
+#define VENC_VIDCTL_VCLKE			(1 << 13)
+#define VENC_VIDCTL_VCLKZ_SHIFT			12
+#define VENC_VIDCTL_VCLKZ			(1 << 12)
+#define VENC_VIDCTL_SYDIR_SHIFT			8
+#define VENC_VIDCTL_SYDIR			(1 << 8)
+#define VENC_VIDCTL_DOMD_SHIFT			4
+#define VENC_VIDCTL_DOMD			(3 << 4)
+#define VENC_VIDCTL_YCDIR_SHIFT			0
+#define VENC_VIDCTL_YCDIR			(1 << 0)
+
+#define VENC_VDPRO_ATYCC_SHIFT			5
+#define VENC_VDPRO_ATYCC			(1 << 5)
+#define VENC_VDPRO_ATCOM_SHIFT			4
+#define VENC_VDPRO_ATCOM			(1 << 4)
+#define VENC_VDPRO_DAFRQ			(1 << 3)
+#define VENC_VDPRO_DAUPS			(1 << 2)
+#define VENC_VDPRO_CUPS				(1 << 1)
+#define VENC_VDPRO_YUPS				(1 << 0)
+
+#define VENC_SYNCCTL_VPL_SHIFT    		3
+#define VENC_SYNCCTL_VPL  			(1 << 3)
+#define VENC_SYNCCTL_HPL_SHIFT 	  		2
+#define VENC_SYNCCTL_HPL  			(1 << 2)
+#define VENC_SYNCCTL_SYEV_SHIFT   		1
+#define VENC_SYNCCTL_SYEV  			(1 << 1)
+#define VENC_SYNCCTL_SYEH_SHIFT   		0
+#define VENC_SYNCCTL_SYEH  			(1 << 0)
+#define VENC_SYNCCTL_OVD_SHIFT   		14
+#define VENC_SYNCCTL_OVD  			(1 << 14)
+
+#define VENC_DCLKCTL_DCKEC_SHIFT		11
+#define VENC_DCLKCTL_DCKEC			(1 << 11)
+#define VENC_DCLKCTL_DCKPW_SHIFT		0
+#define VENC_DCLKCTL_DCKPW			(0x3f << 0)
+
+#define VENC_VSTAT_FIDST			(1 << 4)
+
+#define VENC_CMPNT_MRGB_SHIFT			14
+#define VENC_CMPNT_MRGB				(1 << 14)
+
+#define OSD_MODE_CS				(1 << 15)
+#define OSD_MODE_OVRSZ				(1 << 14)
+#define OSD_MODE_OHRSZ				(1 << 13)
+#define OSD_MODE_EF				(1 << 12)
+#define OSD_MODE_VVRSZ				(1 << 11)
+#define OSD_MODE_VHRSZ				(1 << 10)
+#define OSD_MODE_FSINV				(1 << 9)
+#define OSD_MODE_BCLUT				(1 << 8)
+#define OSD_MODE_CABG_SHIFT			0
+#define OSD_MODE_CABG				(0xff << 0)
+
+#define OSD_VIDWINMD_VFINV			(1 << 15)
+#define OSD_VIDWINMD_V1EFC			(1 << 14)
+#define OSD_VIDWINMD_VHZ1_SHIFT			12
+#define OSD_VIDWINMD_VHZ1			(3 << 12)
+#define OSD_VIDWINMD_VVZ1_SHIFT			10
+#define OSD_VIDWINMD_VVZ1			(3 << 10)
+#define OSD_VIDWINMD_VFF1			(1 << 9)
+#define OSD_VIDWINMD_ACT1			(1 << 8)
+#define OSD_VIDWINMD_V0EFC			(1 << 6)
+#define OSD_VIDWINMD_VHZ0_SHIFT			4
+#define OSD_VIDWINMD_VHZ0			(3 << 4)
+#define OSD_VIDWINMD_VVZ0_SHIFT			2
+#define OSD_VIDWINMD_VVZ0			(3 << 2)
+#define OSD_VIDWINMD_VFF0			(1 << 1)
+#define OSD_VIDWINMD_ACT0			(1 << 0)
+
+#define OSD_OSDWIN0MD_ATN0E			(1 << 14)
+#define OSD_OSDWIN0MD_RGB0E			(1 << 13)
+#define OSD_OSDWIN0MD_BMP0MD_SHIFT		13
+#define OSD_OSDWIN0MD_BMP0MD			(3 << 13)
+#define OSD_OSDWIN0MD_CLUTS0			(1 << 12)
+#define OSD_OSDWIN0MD_OHZ0_SHIFT		10
+#define OSD_OSDWIN0MD_OHZ0			(3 << 10)
+#define OSD_OSDWIN0MD_OVZ0_SHIFT		8
+#define OSD_OSDWIN0MD_OVZ0			(3 << 8)
+#define OSD_OSDWIN0MD_BMW0_SHIFT		6
+#define OSD_OSDWIN0MD_BMW0			(3 << 6)
+#define OSD_OSDWIN0MD_BLND0_SHIFT		3
+#define OSD_OSDWIN0MD_BLND0			(7 << 3)
+#define OSD_OSDWIN0MD_TE0			(1 << 2)
+#define OSD_OSDWIN0MD_OFF0			(1 << 1)
+#define OSD_OSDWIN0MD_OACT0			(1 << 0)
+
+#define OSD_OSDWIN1MD_OASW			(1 << 15)
+#define OSD_OSDWIN1MD_ATN1E			(1 << 14)
+#define OSD_OSDWIN1MD_RGB1E			(1 << 13)
+#define OSD_OSDWIN1MD_BMP1MD_SHIFT		13
+#define OSD_OSDWIN1MD_BMP1MD			(3 << 13)
+#define OSD_OSDWIN1MD_CLUTS1			(1 << 12)
+#define OSD_OSDWIN1MD_OHZ1_SHIFT		10
+#define OSD_OSDWIN1MD_OHZ1			(3 << 10)
+#define OSD_OSDWIN1MD_OVZ1_SHIFT		8
+#define OSD_OSDWIN1MD_OVZ1			(3 << 8)
+#define OSD_OSDWIN1MD_BMW1_SHIFT		6
+#define OSD_OSDWIN1MD_BMW1			(3 << 6)
+#define OSD_OSDWIN1MD_BLND1_SHIFT		3
+#define OSD_OSDWIN1MD_BLND1			(7 << 3)
+#define OSD_OSDWIN1MD_TE1			(1 << 2)
+#define OSD_OSDWIN1MD_OFF1			(1 << 1)
+#define OSD_OSDWIN1MD_OACT1			(1 << 0)
+
+#define OSD_OSDATRMD_OASW			(1 << 15)
+#define OSD_OSDATRMD_OHZA_SHIFT			10
+#define OSD_OSDATRMD_OHZA			(3 << 10)
+#define OSD_OSDATRMD_OVZA_SHIFT			8
+#define OSD_OSDATRMD_OVZA			(3 << 8)
+#define OSD_OSDATRMD_BLNKINT_SHIFT		6
+#define OSD_OSDATRMD_BLNKINT			(3 << 6)
+#define OSD_OSDATRMD_OFFA			(1 << 1)
+#define OSD_OSDATRMD_BLNK			(1 << 0)
+
+#define OSD_RECTCUR_RCAD_SHIFT			8
+#define OSD_RECTCUR_RCAD			(0xff << 8)
+#define OSD_RECTCUR_CLUTSR			(1 << 7)
+#define OSD_RECTCUR_RCHW_SHIFT			4
+#define OSD_RECTCUR_RCHW			(7 << 4)
+#define OSD_RECTCUR_RCVW_SHIFT			1
+#define OSD_RECTCUR_RCVW			(7 << 1)
+#define OSD_RECTCUR_RCACT			(1 << 0)
+
+#define OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
+
+#define OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
+
+#define OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
+
+#define OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
+
+#define OSD_WINOFST_AH_SHIFT			9
+
+#define OSD_VIDWIN0OFST_V0AH			(0xf << 9)
+#define OSD_VIDWIN1OFST_V1AH			(0xf << 9)
+#define OSD_OSDWIN0OFST_O0AH			(0xf << 9)
+#define OSD_OSDWIN1OFST_O1AH			(0xf << 9)
+
+#define OSD_VIDWINADH_V1AH_SHIFT		8
+#define OSD_VIDWINADH_V1AH			(0x7f << 8)
+#define OSD_VIDWINADH_V0AH_SHIFT		0
+#define OSD_VIDWINADH_V0AH			(0x7f << 0)
+
+#define OSD_VIDWIN0ADL_V0AL			(0xffff << 0)
+
+#define OSD_VIDWIN1ADL_V1AL			(0xffff << 0)
+
+#define OSD_OSDWINADH_O1AH_SHIFT		8
+#define OSD_OSDWINADH_O1AH			(0x7f << 8)
+#define OSD_OSDWINADH_O0AH_SHIFT		0
+#define OSD_OSDWINADH_O0AH			(0x7f << 0)
+
+#define OSD_OSDWIN0ADL_O0AL			(0xffff << 0)
+
+#define OSD_OSDWIN1ADL_O1AL			(0xffff << 0)
+
+#define OSD_BASEPX_BPX				(0x3ff << 0)
+
+#define OSD_BASEPY_BPY				(0x1ff << 0)
+
+#define OSD_VIDWIN0XP_V0X			(0x7ff << 0)
+
+#define OSD_VIDWIN0YP_V0Y			(0x7ff << 0)
+
+#define OSD_VIDWIN0XL_V0W			(0x7ff << 0)
+
+#define OSD_VIDWIN0YL_V0H			(0x7ff << 0)
+
+#define OSD_VIDWIN1XP_V1X			(0x7ff << 0)
+
+#define OSD_VIDWIN1YP_V1Y			(0x7ff << 0)
+
+#define OSD_VIDWIN1XL_V1W			(0x7ff << 0)
+
+#define OSD_VIDWIN1YL_V1H			(0x7ff << 0)
+
+#define OSD_OSDWIN0XP_W0X			(0x7ff << 0)
+
+#define OSD_OSDWIN0YP_W0Y			(0x7ff << 0)
+
+#define OSD_OSDWIN0XL_W0W			(0x7ff << 0)
+
+#define OSD_OSDWIN0YL_W0H			(0x7ff << 0)
+
+#define OSD_OSDWIN1XP_W1X			(0x7ff << 0)
+
+#define OSD_OSDWIN1YP_W1Y			(0x7ff << 0)
+
+#define OSD_OSDWIN1XL_W1W			(0x7ff << 0)
+
+#define OSD_OSDWIN1YL_W1H			(0x7ff << 0)
+
+#define OSD_CURXP_RCSX				(0x7ff << 0)
+
+#define OSD_CURYP_RCSY				(0x7ff << 0)
+
+#define OSD_CURXL_RCSW				(0x7ff << 0)
+
+#define OSD_CURYL_RCSH				(0x7ff << 0)
+
+#define OSD_EXTMODE_EXPMDSEL			(1 << 15)
+#define OSD_EXTMODE_SCRNHEXP_SHIFT		13
+#define OSD_EXTMODE_SCRNHEXP			(3 << 13)
+#define OSD_EXTMODE_SCRNVEXP			(1 << 12)
+#define OSD_EXTMODE_OSD1BLDCHR			(1 << 11)
+#define OSD_EXTMODE_OSD0BLDCHR			(1 << 10)
+#define OSD_EXTMODE_ATNOSD1EN			(1 << 9)
+#define OSD_EXTMODE_ATNOSD0EN			(1 << 8)
+#define OSD_EXTMODE_OSDHRSZ15			(1 << 7)
+#define OSD_EXTMODE_VIDHRSZ15			(1 << 6)
+#define OSD_EXTMODE_ZMFILV1HEN			(1 << 5)
+#define OSD_EXTMODE_ZMFILV1VEN			(1 << 4)
+#define OSD_EXTMODE_ZMFILV0HEN			(1 << 3)
+#define OSD_EXTMODE_ZMFILV0VEN			(1 << 2)
+#define OSD_EXTMODE_EXPFILHEN			(1 << 1)
+#define OSD_EXTMODE_EXPFILVEN			(1 << 0)
+
+#define OSD_MISCCTL_BLDSEL			(1 << 15)
+#define OSD_MISCCTL_S420D			(1 << 14)
+#define OSD_MISCCTL_BMAPT			(1 << 13)
+#define OSD_MISCCTL_DM365M			(1 << 12)
+#define OSD_MISCCTL_RGBEN			(1 << 7)
+#define OSD_MISCCTL_RGBWIN			(1 << 6)
+#define OSD_MISCCTL_DMANG			(1 << 6)
+#define OSD_MISCCTL_TMON			(1 << 5)
+#define OSD_MISCCTL_RSEL			(1 << 4)
+#define OSD_MISCCTL_CPBSY			(1 << 3)
+#define OSD_MISCCTL_PPSW			(1 << 2)
+#define OSD_MISCCTL_PPRV			(1 << 1)
+
+#define OSD_CLUTRAMYCB_Y_SHIFT			8
+#define OSD_CLUTRAMYCB_Y			(0xff << 8)
+#define OSD_CLUTRAMYCB_CB_SHIFT			0
+#define OSD_CLUTRAMYCB_CB			(0xff << 0)
+
+#define OSD_CLUTRAMCR_CR_SHIFT			8
+#define OSD_CLUTRAMCR_CR			(0xff << 8)
+#define OSD_CLUTRAMCR_CADDR_SHIFT		0
+#define OSD_CLUTRAMCR_CADDR			(0xff << 0)
+
+#define OSD_TRANSPVAL_RGBTRANS			(0xffff << 0)
+
+#define OSD_TRANSPVALL_RGBL			(0xffff << 0)
+
+#define OSD_TRANSPVALU_Y_SHIFT			8
+#define OSD_TRANSPVALU_Y 			(0xff << 8)
+#define OSD_TRANSPVALU_RGBU_SHIFT		0
+#define OSD_TRANSPVALU_RGBU			(0xff << 0)
+
+#define OSD_TRANSPBMPIDX_BMP1_SHIFT		8
+#define OSD_TRANSPBMPIDX_BMP1			(0xff << 8)
+#define OSD_TRANSPBMPIDX_BMP0_SHIFT		0
+#define OSD_TRANSPBMPIDX_BMP0			0xff
+
+/**
+ * davinci_disp_is_second_field
+ *
+ * Returns: non-zero if true, zero otherwise
+ *
+ * Description:
+ * Check the Video Status Register (VSTAT) field FIDST to see if it's set
+ * if true then it is second field
+ */
+int davinci_disp_is_second_field(void);
+
+#endif				/* _DAVINCI_VPBE_H_ */
diff --git a/include/video/davincifb.h b/include/video/davincifb.h
index b1aa38a..e7f722b 100644
--- a/include/video/davincifb.h
+++ b/include/video/davincifb.h
@@ -1,442 +1,66 @@
 /*
- * include/video/davincifb.h
+ * Copyright (C) 2009 MontaVista Software Inc.
+ * Copyright (C) 2006 Texas Instruments Inc
  *
- * Framebuffer driver for Texas Instruments DM644x display controller.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
  *
- * Copyright (C) 2006 Texas Instruments, Inc.
- * Rishi Bhattacharya <support@ti.com>
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
  *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
-#ifndef _DAVINCIFB_H_
-#define _DAVINCIFB_H_
 
-//#include <mach/io.h>
-
-/* Base registers */
-#define	VPBE_REG_BASE				0x01c72780
-#define	VENC_REG_BASE				0x01c72400
-#define	OSD_REG_BASE				0x01c72600
-#define OSD_REG_SIZE				0x00000180
-
-/* VPBE Global Registers */
-#define	VPBE_PID				(VPBE_BASE + 0x0)
-#define	VPBE_PCR				(VPBE_BASE + 0x4)
-
-/* VPSS Clock Control Register */
-#define	VPSS_CLKCTL				0x01c40044
-
-/* VPBE Video Encoder / Digital LCD Subsystem Registers (VENC) */
-#define	VENC_VMOD				(VENC_REG_BASE + 0x00)
-#define	VENC_VIDCTL				(VENC_REG_BASE + 0x04)
-#define	VENC_VDPRO				(VENC_REG_BASE + 0x08)
-#define	VENC_SYNCCTL				(VENC_REG_BASE + 0x0C)
-#define	VENC_HSPLS				(VENC_REG_BASE + 0x10)
-#define	VENC_VSPLS				(VENC_REG_BASE + 0x14)
-#define	VENC_HINT				(VENC_REG_BASE + 0x18)
-#define	VENC_HSTART				(VENC_REG_BASE + 0x1C)
-#define	VENC_HVALID				(VENC_REG_BASE + 0x20)
-#define	VENC_VINT				(VENC_REG_BASE + 0x24)
-#define	VENC_VSTART				(VENC_REG_BASE + 0x28)
-#define	VENC_VVALID				(VENC_REG_BASE + 0x2C)
-#define	VENC_HSDLY				(VENC_REG_BASE + 0x30)
-#define	VENC_VSDLY				(VENC_REG_BASE + 0x34)
-#define	VENC_YCCCTL				(VENC_REG_BASE + 0x38)
-#define	VENC_RGBCTL				(VENC_REG_BASE + 0x3C)
-#define	VENC_RGBCLP				(VENC_REG_BASE + 0x40)
-#define	VENC_LINECTL				(VENC_REG_BASE + 0x44)
-#define	VENC_CULLLINE				(VENC_REG_BASE + 0x48)
-#define	VENC_LCDOUT				(VENC_REG_BASE + 0x4C)
-#define	VENC_BRTS				(VENC_REG_BASE + 0x50)
-#define	VENC_BRTW				(VENC_REG_BASE + 0x54)
-#define	VENC_ACCTL				(VENC_REG_BASE + 0x58)
-#define	VENC_PWMP				(VENC_REG_BASE + 0x5C)
-#define	VENC_PWMW				(VENC_REG_BASE + 0x60)
-#define	VENC_DCLKCTL				(VENC_REG_BASE + 0x64)
-#define	VENC_DCLKPTN0				(VENC_REG_BASE + 0x68)
-#define	VENC_DCLKPTN1				(VENC_REG_BASE + 0x6C)
-#define	VENC_DCLKPTN2				(VENC_REG_BASE + 0x70)
-#define	VENC_DCLKPTN3				(VENC_REG_BASE + 0x74)
-#define	VENC_DCLKPTN0A				(VENC_REG_BASE + 0x78)
-#define	VENC_DCLKPTN1A				(VENC_REG_BASE + 0x7C)
-#define	VENC_DCLKPTN2A				(VENC_REG_BASE + 0x80)
-#define	VENC_DCLKPTN3A				(VENC_REG_BASE + 0x84)
-#define	VENC_DCLKHS				(VENC_REG_BASE + 0x88)
-#define	VENC_DCLKHSA				(VENC_REG_BASE + 0x8C)
-#define	VENC_DCLKHR				(VENC_REG_BASE + 0x90)
-#define	VENC_DCLKVS				(VENC_REG_BASE + 0x94)
-#define	VENC_DCLKVR				(VENC_REG_BASE + 0x98)
-#define	VENC_CAPCTL				(VENC_REG_BASE + 0x9C)
-#define	VENC_CAPDO				(VENC_REG_BASE + 0xA0)
-#define	VENC_CAPDE				(VENC_REG_BASE + 0xA4)
-#define	VENC_ATR0				(VENC_REG_BASE + 0xA8)
-#define	VENC_ATR1				(VENC_REG_BASE + 0xAC)
-#define	VENC_ATR2				(VENC_REG_BASE + 0xB0)
-#define	VENC_EPSON_LCDCTL			(VENC_REG_BASE + 0xB4)
-#define	VENC_CASIO_LCDCTL			(VENC_REG_BASE + 0xB4)
-#define	VENC_UDISP_LCDCT			(VENC_REG_BASE + 0xB4)
-#define	VENC_STN_LCDCT				(VENC_REG_BASE + 0xB4)
-#define	VENC_VSTAT				(VENC_REG_BASE + 0xB8)
-#define	VENC_RAMADR				(VENC_REG_BASE + 0xBC)
-#define	VENC_RAMPORT				(VENC_REG_BASE + 0xC0)
-#define	VENC_DACTST				(VENC_REG_BASE + 0xC4)
-#define	VENC_YCOLVL				(VENC_REG_BASE + 0xC8)
-#define	VENC_SCPROG				(VENC_REG_BASE + 0xCC)
-#define	VENC_CVBS				(VENC_REG_BASE + 0xDC)
-#define	VENC_CMPNT				(VENC_REG_BASE + 0xE0)
-#define	VENC_ETMG0				(VENC_REG_BASE + 0xE4)
-#define	VENC_ETMG1				(VENC_REG_BASE + 0xE8)
-#define	VENC_ETMG2				(VENC_REG_BASE + 0xEC)
-#define	VENC_ETMG3				(VENC_REG_BASE + 0xF0)
-#define	VENC_DACSEL				(VENC_REG_BASE + 0xF4)
-#define	VENC_ARGBX0				(VENC_REG_BASE + 0x100)
-#define	VENC_ARGBX1				(VENC_REG_BASE + 0x104)
-#define	VENC_ARGBX2				(VENC_REG_BASE + 0x108)
-#define	VENC_ARGBX3				(VENC_REG_BASE + 0x10C)
-#define	VENC_ARGBX4				(VENC_REG_BASE + 0x110)
-#define	VENC_DRGBX0				(VENC_REG_BASE + 0x114)
-#define	VENC_DRGBX1				(VENC_REG_BASE + 0x118)
-#define	VENC_DRGBX2				(VENC_REG_BASE + 0x11C)
-#define	VENC_DRGBX3				(VENC_REG_BASE + 0x120)
-#define	VENC_DRGBX4				(VENC_REG_BASE + 0x124)
-#define	VENC_VSTARTA				(VENC_REG_BASE + 0x128)
-#define	VENC_OSDCLK0				(VENC_REG_BASE + 0x12C)
-#define	VENC_OSDCLK1				(VENC_REG_BASE + 0x130)
-#define	VENC_HVLDCL0				(VENC_REG_BASE + 0x134)
-#define	VENC_HVLDCL1				(VENC_REG_BASE + 0x138)
-#define	VENC_OSDHAD				(VENC_REG_BASE + 0x13C)
-
-#define VID0	0
-#define VID1	1
-#define OSD0	3
-#define OSD1	4
-
-/* VPBE On-Screen Display Subsystem Registers (OSD) */
-#define	OSD_MODE				(OSD_REG_BASE + 0x00)
-#define	OSD_VIDWINMD				(OSD_REG_BASE + 0x04)
-#define	OSD_OSDWIN0MD				(OSD_REG_BASE + 0x08)
-#define	OSD_OSDWIN1MD				(OSD_REG_BASE + 0x0C)
-#define	OSD_OSDATRMD				(OSD_REG_BASE + 0x0C)
-#define	OSD_RECTCUR				(OSD_REG_BASE + 0x10)
-#define		OSD_WINOFST(i)			(OSD_REG_BASE + 0x18 + (i)*0x4)
-#define	OSD_VIDWIN0OFST				(OSD_REG_BASE + 0x18)
-#define	OSD_VIDWIN1OFST				(OSD_REG_BASE + 0x1C)
-#define	OSD_OSDWIN0OFST				(OSD_REG_BASE + 0x20)
-#define	OSD_OSDWIN1OFST				(OSD_REG_BASE + 0x24)
-#define		OSD_WINADR(i)			(OSD_REG_BASE + 0x2C + (i)*0x4)
-#define	OSD_VIDWIN0ADR				(OSD_REG_BASE + 0x2C)
-#define	OSD_VIDWIN1ADR				(OSD_REG_BASE + 0x30)
-#define	OSD_OSDWIN0ADR				(OSD_REG_BASE + 0x38)
-#define	OSD_OSDWIN1ADR				(OSD_REG_BASE + 0x3C)
-#define	OSD_BASEPX				(OSD_REG_BASE + 0x40)
-#define	OSD_BASEPY				(OSD_REG_BASE + 0x44)
-#define	OSD_WINXP(i)				(OSD_REG_BASE + 0x48 + (i)*0x10)
-#define	OSD_WINYP(i)				(OSD_REG_BASE + 0x4C + (i)*0x10)
-#define	OSD_WINXL(i)				(OSD_REG_BASE + 0x50 + (i)*0x10)
-#define	OSD_WINYL(i)				(OSD_REG_BASE + 0x54 + (i)*0x10)
-#define	OSD_VIDWIN0XP				(OSD_REG_BASE + 0x48)
-#define	OSD_VIDWIN0YP				(OSD_REG_BASE + 0x4C)
-#define	OSD_VIDWIN0XL				(OSD_REG_BASE + 0x50)
-#define	OSD_VIDWIN0YL				(OSD_REG_BASE + 0x54)
-#define	OSD_VIDWIN1XP				(OSD_REG_BASE + 0x58)
-#define	OSD_VIDWIN1YP				(OSD_REG_BASE + 0x5C)
-#define	OSD_VIDWIN1XL				(OSD_REG_BASE + 0x60)
-#define	OSD_VIDWIN1YL				(OSD_REG_BASE + 0x64)
-#define	OSD_OSDWIN0XP				(OSD_REG_BASE + 0x68)
-#define	OSD_OSDWIN0YP				(OSD_REG_BASE + 0x6C)
-#define	OSD_OSDWIN0XL				(OSD_REG_BASE + 0x70)
-#define	OSD_OSDWIN0YL				(OSD_REG_BASE + 0x74)
-#define	OSD_OSDWIN1XP				(OSD_REG_BASE + 0x78)
-#define	OSD_OSDWIN1YP				(OSD_REG_BASE + 0x7C)
-#define	OSD_OSDWIN1XL				(OSD_REG_BASE + 0x80)
-#define	OSD_OSDWIN1YL				(OSD_REG_BASE + 0x84)
-#define	OSD_CURXP				(OSD_REG_BASE + 0x88)
-#define	OSD_CURYP				(OSD_REG_BASE + 0x8C)
-#define	OSD_CURXL				(OSD_REG_BASE + 0x90)
-#define	OSD_CURYL				(OSD_REG_BASE + 0x94)
-#define	OSD_W0BMP01				(OSD_REG_BASE + 0xA0)
-#define	OSD_W0BMP23				(OSD_REG_BASE + 0xA4)
-#define	OSD_W0BMP45				(OSD_REG_BASE + 0xA8)
-#define	OSD_W0BMP67				(OSD_REG_BASE + 0xAC)
-#define	OSD_W0BMP89				(OSD_REG_BASE + 0xB0)
-#define	OSD_W0BMPAB				(OSD_REG_BASE + 0xB4)
-#define	OSD_W0BMPCD				(OSD_REG_BASE + 0xB8)
-#define	OSD_W0BMPEF				(OSD_REG_BASE + 0xBC)
-#define	OSD_W1BMP0				(OSD_REG_BASE + 0xC0)
-#define	OSD_W1BMP2				(OSD_REG_BASE + 0xC4)
-#define	OSD_W1BMP4				(OSD_REG_BASE + 0xC8)
-#define	OSD_W1BMP6				(OSD_REG_BASE + 0xCC)
-#define	OSD_W1BMP8				(OSD_REG_BASE + 0xD0)
-#define	OSD_W1BMPA				(OSD_REG_BASE + 0xD4)
-#define	OSD_W1BMPC				(OSD_REG_BASE + 0xD8)
-#define	OSD_W1BMPE				(OSD_REG_BASE + 0xDC)
-#define	OSD_TI_TES				(OSD_REG_BASE + 0xE0)
-#define	OSD_MISCCT				(OSD_REG_BASE + 0xE8)
-#define	OSD_CLUTRAMYC				(OSD_REG_BASE + 0xEC)
-#define	OSD_CLUTRAMC				(OSD_REG_BASE + 0xF0)
-#define	OSD_TRANSPVA				(OSD_REG_BASE + 0xF0)
-#define	OSD_PPVWIN0AD				(OSD_REG_BASE + 0xFC)
-
-/* bit definitions */
-#define VPBE_PCR_VENC_DIV			(1 << 1)
-#define VPBE_PCR_CLK_OFF			(1 << 0)
-#define VENC_VMOD_VDMD_SHIFT			12
-#define VENC_VMOD_VDMD_YCBCR16			0
-#define VENC_VMOD_VDMD_YCBCR8			1
-#define VENC_VMOD_VDMD_RGB666			2
-#define VENC_VMOD_VDMD_RGB8			3
-#define VENC_VMOD_VDMD_EPSON			4
-#define VENC_VMOD_VDMD_CASIO			5
-#define VENC_VMOD_VDMD_UDISPQVGA		6
-#define VENC_VMOD_VDMD_STNLCD			7
-#define VENC_VMOD_VDMD				(7 << 12)
-#define VENC_VMOD_ITLCL				(1 << 11)
-#define VENC_VMOD_ITLC				(1 << 10)
-#define VENC_VMOD_NSIT				(1 << 9)
-#define VENC_VMOD_HDMD				(1 << 8)
-#define VENC_VMOD_TVTYP				(3 << 6)
-#define VENC_VMOD_SLAVE				(1 << 5)
-#define VENC_VMOD_VMD				(1 << 4)
-#define VENC_VMOD_BLNK				(1 << 3)
-#define VENC_VMOD_VIE				(1 << 1)
-#define VENC_VMOD_VENC				(1 << 0)
-/* other VENC registers' bit positions not defined yet */
-
-#define	OSD_MODE_CS				(1 << 15)
-#define	OSD_MODE_OVRSZ				(1 << 14)
-#define	OSD_MODE_OHRSZ				(1 << 13)
-#define	OSD_MODE_EF				(1 << 12)
-#define	OSD_MODE_VVRSZ				(1 << 11)
-#define	OSD_MODE_VHRSZ				(1 << 10)
-#define	OSD_MODE_FSINV				(1 << 9)
-#define	OSD_MODE_BCLUT				(1 << 8)
-#define	OSD_MODE_CABG				(0xff << 0)
-#define	OSD_MODE_CABG_SHIFT			0
-
-#define	OSD_VIDWINMD_VFINV			(1 << 15)
-#define	OSD_VIDWINMD_V1EFC			(1 << 14)
-#define	OSD_VIDWINMD_VHZ1			(3 << 12)
-#define	OSD_VIDWINMD_VHZ1_SHIFT			12
-#define	OSD_VIDWINMD_VVZ1			(3 << 10)
-#define	OSD_VIDWINMD_VVZ1_SHIFT			10
-#define	OSD_VIDWINMD_VFF1			(1 << 9)
-#define	OSD_VIDWINMD_ACT1			(1 << 8)
-#define	OSD_VIDWINMD_V0EFC			(1 << 6)
-#define	OSD_VIDWINMD_VHZ0			(3 << 4)
-#define	OSD_VIDWINMD_VHZ0_SHIFT			4
-#define	OSD_VIDWINMD_VVZ0			(3 << 2)
-#define	OSD_VIDWINMD_VVZ0_SHIFT			2
-#define	OSD_VIDWINMD_VFF0			(1 << 1)
-#define	OSD_VIDWINMD_ACT0			(1 << 0)
-
-#define	OSD_OSDWIN0MD_ATN0E			(1 << 14)
-#define	OSD_OSDWIN0MD_RGB0E			(1 << 13)
-#define	OSD_OSDWIN0MD_CLUTS0			(1 << 12)
-#define	OSD_OSDWIN0MD_OHZ0			(3 << 10)
-#define	OSD_OSDWIN0MD_OHZ0_SHIFT		10
-#define	OSD_OSDWIN0MD_OVZ0			(3 << 8)
-#define	OSD_OSDWIN0MD_OVZ0_SHIFT		8
-#define	OSD_OSDWIN0MD_BMW0			(3 << 6)
-#define	OSD_OSDWIN0MD_BMW0_SHIFT		6
-#define	OSD_OSDWIN0MD_BLND0			(3 << 3)
-#define	OSD_OSDWIN0MD_BLND0_SHIFT		3
-#define	OSD_OSDWIN0MD_TE0			(1 << 2)
-#define	OSD_OSDWIN0MD_OFF0			(1 << 1)
-#define	OSD_OSDWIN0MD_OACT0			(1 << 0)
-
-#define	OSD_OSDWIN1MD_OASW			(1 << 15)
-#define	OSD_OSDWIN1MD_ATN1E			(1 << 14)
-#define	OSD_OSDWIN1MD_RGB1E			(1 << 13)
-#define	OSD_OSDWIN1MD_CLUTS1			(1 << 12)
-#define	OSD_OSDWIN1MD_OHZ1			(3 << 10)
-#define	OSD_OSDWIN1MD_OHZ1_SHIFT		10
-#define	OSD_OSDWIN1MD_OVZ1			(3 << 8)
-#define	OSD_OSDWIN1MD_OVZ1_SHIFT		8
-#define	OSD_OSDWIN1MD_BMW1			(3 << 6)
-#define	OSD_OSDWIN1MD_BMW1_SHIFT		6
-#define	OSD_OSDWIN1MD_BLND1			(3 << 3)
-#define	OSD_OSDWIN1MD_BLND1_SHIFT		3
-#define	OSD_OSDWIN1MD_TE1			(1 << 2)
-#define	OSD_OSDWIN1MD_OFF1			(1 << 1)
-#define	OSD_OSDWIN1MD_OACT1			(1 << 0)
-
-
-#define	OSD_OSDATRMD_OASW			(1 << 15)
-#define	OSD_OSDATRMD_OHZA			(3 << 10)
-#define	OSD_OSDATRMD_OHZA_SHIFT			10
-#define	OSD_OSDATRMD_OVZA			(3 << 8)
-#define	OSD_OSDATRMD_OVZA_SHIFT			8
-#define	OSD_OSDATRMD_BLNKINT			(3 << 6)
-#define	OSD_OSDATRMD_BLNKINT_SHIFT		6
-#define	OSD_OSDATRMD_OFFA			(1 << 1)
-#define	OSD_OSDATRMD_BLNK			(1 << 0)
-
-#define	OSD_RECTCUR_RCAD			(0xff << 8)
-#define	OSD_RECTCUR_RCAD_SHIFT			8
-#define	OSD_RECTCUR_CLUTSR			(1 << 7)
-#define	OSD_RECTCUR_RCHW			(3 << 4)
-#define	OSD_RECTCUR_RCHW_SHIFT			4
-#define	OSD_RECTCUR_RCVW			(3 << 1)
-#define	OSD_RECTCUR_RCVW_SHIFT			1
-#define	OSD_RECTCUR_RCACT			(1 << 0)
-
-#define	OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
-#define	OSD_VIDWIN0OFST_V0LO_SHIFT		0
-#define	OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
-#define	OSD_VIDWIN1OFST_V1LO_SHIFT		0
-#define	OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
-#define	OSD_OSDWIN0OFST_O0LO_SHIFT		0
-#define	OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
-#define	OSD_OSDWIN1OFST_O1LO_SHIFT		0
-#define	OSD_BASEPX_BPX				(0x3ff << 0)
-#define	OSD_BASEPX_BPX_SHIFT			0
-#define	OSD_BASEPY_BPY				(0x1ff << 0)
-#define	OSD_BASEPY_BPY_SHIFT			0
-#define	OSD_VIDWIN0XP_V0X			(0x3ff << 0)
-#define	OSD_VIDWIN0XP_V0X_SHIFT			0
-#define	OSD_VIDWIN0YP_V0Y			(0x1ff << 0)
-#define	OSD_VIDWIN0YP_V0Y_SHIFT			0
-#define	OSD_VIDWIN0XL_V0W			(0xfff << 0)
-#define	OSD_VIDWIN0XL_V0W_SHIFT			0
-#define	OSD_VIDWIN0YL_V0H			(0x7ff << 0)
-#define	OSD_VIDWIN0YL_V0H_SHIFT			0
-#define	OSD_VIDWIN1XP_V1X			(0x3ff << 0)
-#define	OSD_VIDWIN1XP_V1X_SHIFT			0
-#define	OSD_VIDWIN1YP_V1Y			(0x1ff << 0)
-#define	OSD_VIDWIN1YP_V1Y_SHIFT			0
-#define	OSD_VIDWIN1XL_V1W			(0xfff << 0)
-#define	OSD_VIDWIN1XL_V1W_SHIFT			0
-#define	OSD_VIDWIN1YL_V1H			(0x7ff << 0)
-#define	OSD_VIDWIN1YL_V1H_SHIFT			0
-#define	OSD_OSDWIN0XP_W0X			(0x3ff << 0)
-#define	OSD_OSDWIN0XP_W0X_SHIFT			0
-#define	OSD_OSDWIN0YP_W0Y			(0x1ff << 0)
-#define	OSD_OSDWIN0YP_W0Y_SHIFT			0
-#define	OSD_OSDWIN0XL_W0W			(0xfff << 0)
-#define	OSD_OSDWIN0XL_W0W_SHIFT			0
-#define	OSD_OSDWIN0YL_W0H			(0x7ff << 0)
-#define	OSD_OSDWIN0YL_W0H_SHIFT			0
-#define	OSD_OSDWIN1XP_W1X			(0x3ff << 0)
-#define	OSD_OSDWIN1XP_W1X_SHIFT			0
-#define	OSD_OSDWIN1YP_W1Y			(0x1ff << 0)
-#define	OSD_OSDWIN1YP_W1Y_SHIFT			0
-#define	OSD_OSDWIN1XL_W1W			(0xfff << 0)
-#define	OSD_OSDWIN1XL_W1W_SHIFT			0
-#define	OSD_OSDWIN1YL_W1H			(0x7ff << 0)
-#define	OSD_OSDWIN1YL_W1H_SHIFT			0
-#define	OSD_CURXP_RCSX				(0x3ff << 0)
-#define	OSD_CURXP_RCSX_SHIFT			0
-#define	OSD_CURYP_RCSY				(0x1ff << 0)
-#define	OSD_CURYP_RCSY_SHIFT			0
-#define	OSD_CURYL_RCSH				(0x7ff << 0)
-#define	OSD_CURYL_RCSH_SHIFT			0
-#define	OSD_W0BMP01_PAL01			(0xff << 8)
-#define	OSD_W0BMP01_PAL01_SHIFT			8
-#define	OSD_W0BMP01_PAL00			(0xff << 0)
-#define	OSD_W0BMP01_PAL00_SHIFT			0
-#define	OSD_W0BMP23_PAL03			(0xff << 8)
-#define	OSD_W0BMP23_PAL03_SHIFT			8
-#define	OSD_W0BMP23_PAL02			(0xff << 0)
-#define	OSD_W0BMP23_PAL02_SHIFT			0
-#define	OSD_W0BMP45_PAL05			(0xff << 8)
-#define	OSD_W0BMP45_PAL05_SHIFT			8
-#define	OSD_W0BMP45_PAL04			(0xff << 0)
-#define	OSD_W0BMP45_PAL04_SHIFT			0
-#define	OSD_W0BMP67_PAL07			(0xff << 8)
-#define	OSD_W0BMP67_PAL07_SHIFT			8
-#define	OSD_W0BMP67_PAL06			(0xff << 0)
-#define	OSD_W0BMP67_PAL06_SHIFT			0
-#define	OSD_W0BMP89_PAL09			(0xff << 8)
-#define	OSD_W0BMP89_PAL09_SHIFT			8
-#define	OSD_W0BMP89_PAL08			(0xff << 0)
-#define	OSD_W0BMP89_PAL08_SHIFT			0
-#define	OSD_W0BMPAB_PAL11			(0xff << 8)
-#define	OSD_W0BMPAB_PAL11_SHIFT			8
-#define	OSD_W0BMPAB_PAL10			(0xff << 0)
-#define	OSD_W0BMPAB_PAL10_SHIFT			0
-#define	OSD_W0BMPCD_PAL13			(0xff << 8)
-#define	OSD_W0BMPCD_PAL13_SHIFT			8
-#define	OSD_W0BMPCD_PAL12			(0xff << 0)
-#define	OSD_W0BMPCD_PAL12_SHIFT			0
-#define	OSD_W0BMPEF_PAL15			(0xff << 8)
-#define	OSD_W0BMPEF_PAL15_SHIFT			8
-#define	OSD_W0BMPEF_PAL14			(0xff << 0)
-#define	OSD_W0BMPEF_PAL14_SHIFT			0
-#define	OSD_W1BMP0_PAL01			(0xff << 8)
-#define	OSD_W1BMP0_PAL01_SHIFT			8
-#define	OSD_W1BMP0_PAL00			(0xff << 0)
-#define	OSD_W1BMP0_PAL00_SHIFT			0
-#define	OSD_W1BMP2_PAL03			(0xff << 8)
-#define	OSD_W1BMP2_PAL03_SHIFT			8
-#define	OSD_W1BMP2_PAL02			(0xff << 0)
-#define	OSD_W1BMP2_PAL02_SHIFT			0
-#define	OSD_W1BMP4_PAL05			(0xff << 8)
-#define	OSD_W1BMP4_PAL05_SHIFT			8
-#define	OSD_W1BMP4_PAL04			(0xff << 0)
-#define	OSD_W1BMP4_PAL04_SHIFT			0
-#define	OSD_W1BMP6_PAL07			(0xff << 8)
-#define	OSD_W1BMP6_PAL07_SHIFT			8
-#define	OSD_W1BMP6_PAL06			(0xff << 0)
-#define	OSD_W1BMP6_PAL06_SHIFT			0
-#define	OSD_W1BMP8_PAL09			(0xff << 8)
-#define	OSD_W1BMP8_PAL09_SHIFT			8
-#define	OSD_W1BMP8_PAL08			(0xff << 0)
-#define	OSD_W1BMP8_PAL08_SHIFT			0
-#define	OSD_W1BMPA_PAL11			(0xff << 8)
-#define	OSD_W1BMPA_PAL11_SHIFT			8
-#define	OSD_W1BMPA_PAL10			(0xff << 0)
-#define	OSD_W1BMPA_PAL10_SHIFT			0
-#define	OSD_W1BMPC_PAL13			(0xff << 8)
-#define	OSD_W1BMPC_PAL13_SHIFT			8
-#define	OSD_W1BMPC_PAL12			(0xff << 0)
-#define	OSD_W1BMPC_PAL12_SHIFT			0
-#define	OSD_W1BMPE_PAL15			(0xff << 8)
-#define	OSD_W1BMPE_PAL15_SHIFT			8
-#define	OSD_W1BMPE_PAL14			(0xff << 0)
-#define	OSD_W1BMPE_PAL14_SHIFT			0
-
-#define	OSD_MISCCT_RGBEN			(1 << 7)
-#define	OSD_MISCCT_RGBWIN			(1 << 6)
-#define	OSD_MISCCT_TMON				(1 << 5)
-#define	OSD_MISCCT_RSEL				(1 << 4)
-#define	OSD_MISCCT_CPBSY			(1 << 3)
-#define	OSD_MISCCT_PPSW				(1 << 2)
-#define	OSD_MISCCT_PPRV				(1 << 1)
-
-#define	OSD_CLUTRAMY_Y				(0xff << 8)
-#define	OSD_CLUTRAMY_Y_SHIFT			8
-#define	OSD_CLUTRAMY_CB				(0xff << 0)
-#define	OSD_CLUTRAMY_CB_SHIFT			0
-#define	OSD_CLUTRAM_CR				(0xff << 8)
-#define	OSD_CLUTRAM_CR_SHIFT			8
-#define	OSD_CLUTRAM_CADDR			(0xff << 0)
-#define	OSD_CLUTRAM_CADDR_SHIFT			0
-#define	OSD_TRANSPVA_RGBTRANS			(0xff << 0)
-#define	OSD_TRANSPVA_RGBTRANS_SHIFT		0
+#ifndef DAVINCIFB_H
+#define DAVINCIFB_H
+
+#include <video/davinci_osd.h>
+#include <linux/poll.h>
+#include <linux/wait.h>
+
+#define DAVINCIFB_NAME "davincifb"
+
+/* There are 4 framebuffer devices, one per window. */
+#define OSD0_FBNAME "dm_osd0_fb"
+#define OSD1_FBNAME "dm_osd1_fb"
+#define VID0_FBNAME "dm_vid0_fb"
+#define VID1_FBNAME "dm_vid1_fb"
+
+/*  Structure for each window */
+struct vpbe_dm_win_info {
+	struct fb_info *info;
+	struct vpbe_dm_info *dm;
+	enum davinci_disp_layer layer;
+	unsigned xpos;
+	unsigned ypos;
+	unsigned own_window; /* Does the framebuffer driver own this window? */
+	unsigned display_window;
+	unsigned sdram_address;
+	unsigned int pseudo_palette[16];
+};
 
+/*
+ * Structure for the driver holding information of windows,
+ *  memory base addresses etc.
+ */
+struct vpbe_dm_info {
+	struct vpbe_dm_win_info win[4];
 
-#define LCD             0
-#define NTSC            1
-#define PAL             2
+	wait_queue_head_t vsync_wait;
+	unsigned int vsync_cnt;
+	int timeout;
+	struct davinci_disp_callback vsync_callback;
 
-#define COMPOSITE       1
-#define SVIDEO          2
-#define COMPONENT       3
-#define RGB             4
+	unsigned char ram_clut[256][3];
+	enum davinci_pix_format yc_pixfmt;
 
-/* define the custom FBIO_WAITFORVSYNC ioctl */
-#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
-#define FBIO_SETATTRIBUTE       _IOW('F', 0x21, struct fb_fillrect)
-#define FBIO_SETPOSX		_IOW('F', 0x22, u_int32_t)
-#define FBIO_SETPOSY		_IOW('F', 0x23, u_int32_t)
-struct zoom_params
-{
-	u_int32_t window_id;
-	u_int32_t zoom_h;
-	u_int32_t zoom_v;
+	struct fb_videomode mode;
 };
-#define FBIO_SETZOOM		_IOW('F', 0x24, struct zoom_params)
-#define FBIO_GETSTD		_IOR('F', 0x25, u_int32_t)
-#endif /* _DAVINCIFB_H_ */
+
+#endif				/* ifndef DAVINCIFB__H */
diff --git a/include/video/davincifb_ioctl.h b/include/video/davincifb_ioctl.h
new file mode 100644
index 0000000..7ce3788
--- /dev/null
+++ b/include/video/davincifb_ioctl.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef DAVINCIFB_IOCTL_H
+#define DAVINCIFB_IOCTL_H
+
+/*
+ * Enumerations
+ */
+
+/*  Enum for Boolean variables  */
+typedef enum {
+	SET_0 = 0,
+	SET_1 = 1
+} CB_CR_ORDER, ATTRIBUTE;
+
+/*  Enable/Disable enum */
+typedef enum {
+	VPBE_DISABLE = 0,
+	VPBE_ENABLE = 1
+} ATTENUATION, EXPANSION, BLINKING;
+
+/*
+ * Structures and Union Definitions
+ */
+
+typedef struct zoom_params {
+	u_int32_t window_id;
+	u_int32_t zoom_h;
+	u_int32_t zoom_v;
+} zoom_params_t;
+
+/* Structure for transparency and the blending factor for the bitmap window */
+typedef struct vpbe_bitmap_blend_params {
+	unsigned int colorkey;	/* color key to be blended */
+	unsigned int enable_colorkeying;	/* enable color keying */
+	unsigned int bf;	/* valid range from 0 to 7 only. */
+} vpbe_bitmap_blend_params_t;
+
+/*  Structure for window expansion  */
+typedef struct vpbe_win_expansion {
+	EXPANSION horizontal;
+	EXPANSION vertical;	/* 1: Enable 0:disable */
+} vpbe_win_expansion_t;
+
+/*  Structure for OSD window blinking options */
+typedef struct vpbe_blink_option {
+	BLINKING blinking;	/* 1: Enable blinking 0: Disable */
+	unsigned int interval;	/* Valid only if blinking is 1 */
+} vpbe_blink_option_t;
+
+/*  Structure for background color  */
+typedef struct vpbe_backg_color {
+	unsigned char clut_select;	/* 2: RAM CLUT 1:ROM1 CLUT 0:ROM0 CLUT */
+	unsigned char color_offset;	/* index of color */
+} vpbe_backg_color_t;
+
+/*  Structure for Video window configurable parameters  */
+typedef struct vpbe_video_config_params {
+	CB_CR_ORDER cb_cr_order;	/* Cb/Cr order in input data for a pixel. */
+	/*    0: cb cr  1:  cr cb */
+	vpbe_win_expansion_t exp_info;	/* HZ/VT Expansion enable disable */
+} vpbe_video_config_params_t;
+
+/*
+ * Union of structures giving the CLUT index for the 1, 2, 4 bit bitmap values
+ */
+typedef union vpbe_clut_idx {
+	struct _for_4bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char bitmap_val_1;
+		unsigned char bitmap_val_2;
+		unsigned char bitmap_val_3;
+		unsigned char bitmap_val_4;
+		unsigned char bitmap_val_5;
+		unsigned char bitmap_val_6;
+		unsigned char bitmap_val_7;
+		unsigned char bitmap_val_8;
+		unsigned char bitmap_val_9;
+		unsigned char bitmap_val_10;
+		unsigned char bitmap_val_11;
+		unsigned char bitmap_val_12;
+		unsigned char bitmap_val_13;
+		unsigned char bitmap_val_14;
+		unsigned char bitmap_val_15;
+	} for_4bit_bitmap;
+	struct _for_2bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char dummy0[4];
+		unsigned char bitmap_val_1;
+		unsigned char dummy1[4];
+		unsigned char bitmap_val_2;
+		unsigned char dummy2[4];
+		unsigned char bitmap_val_3;
+	} for_2bit_bitmap;
+	struct _for_1bit_bitmap {
+		unsigned char bitmap_val_0;
+		unsigned char dummy0[14];
+		unsigned char bitmap_val_1;
+	} for_1bit_bitmap;
+} vpbe_clut_idx_t;
+
+/* Structure for bitmap window configurable parameters */
+typedef struct vpbe_bitmap_config_params {
+	/* Only for bitmap width = 1,2,4 bits */
+	vpbe_clut_idx_t clut_idx;
+	/* Attenuation value for YUV o/p for bitmap window */
+	unsigned char attenuation_enable;
+	/* 0: ROM DM270, 1:ROM DM320, 2:RAM CLUT */
+	unsigned char clut_select;
+} vpbe_bitmap_config_params_t;
+
+/* Structure to hold window position */
+typedef struct vpbe_window_position {
+	unsigned int xpos;	/* X position of the window */
+	unsigned int ypos;	/* Y position of the window */
+} vpbe_window_position_t;
+
+#define	RAM_CLUT_SIZE	256*3
+
+/* custom ioctl definitions */
+#define FBIO_WAITFORVSYNC	_IOW('F', 0x20, u_int32_t)
+#define FBIO_SETATTRIBUTE	_IOW('F', 0x21, struct fb_fillrect)
+#define FBIO_SETPOSX		_IOW('F', 0x22, u_int32_t)
+#define FBIO_SETPOSY		_IOW('F', 0x23, u_int32_t)
+#define FBIO_SETZOOM		_IOW('F', 0x24, struct zoom_params)
+#define FBIO_ENABLE_DISABLE_WIN		\
+	_IOW('F', 0x30, unsigned char)
+#define FBIO_SET_BITMAP_BLEND_FACTOR	\
+	_IOW('F', 0x31, vpbe_bitmap_blend_params_t)
+#define FBIO_SET_BITMAP_WIN_RAM_CLUT	\
+	_IOW('F', 0x32, unsigned char[RAM_CLUT_SIZE])
+#define FBIO_ENABLE_DISABLE_ATTRIBUTE_WIN \
+	_IOW('F', 0x33, unsigned int)
+#define FBIO_GET_BLINK_INTERVAL		\
+	_IOR('F', 0x34, vpbe_blink_option_t)
+#define FBIO_SET_BLINK_INTERVAL		\
+	_IOW('F', 0x35, vpbe_blink_option_t)
+#define FBIO_GET_VIDEO_CONFIG_PARAMS	\
+	_IOR('F', 0x36, vpbe_video_config_params_t)
+#define FBIO_SET_VIDEO_CONFIG_PARAMS	\
+	_IOW('F', 0x37, vpbe_video_config_params_t)
+#define FBIO_GET_BITMAP_CONFIG_PARAMS	\
+	_IOR('F', 0x38, vpbe_bitmap_config_params_t)
+#define FBIO_SET_BITMAP_CONFIG_PARAMS	\
+	_IOW('F', 0x39, vpbe_bitmap_config_params_t)
+#define FBIO_SET_BACKG_COLOR		\
+	_IOW('F', 0x47, vpbe_backg_color_t)
+#define FBIO_SETPOS			\
+	_IOW('F', 0x49, u_int32_t)
+#define FBIO_SET_CURSOR			\
+	_IOW('F', 0x50, struct fb_cursor)
+
+/*  Window ID definitions */
+#define OSD0 0
+#define VID0 1
+#define OSD1 2
+#define VID1 3
+
+#endif				/* ifndef DAVINCIFB_IOCTL_H */
-- 
1.6.0.4

