Index: linux-2.6.29/arch/arm/boot/compressed/head-davinci.S
===================================================================
--- linux-2.6.29.orig/arch/arm/boot/compressed/head-davinci.S	2009-11-20 10:07:08.177854427 -0600
+++ linux-2.6.29/arch/arm/boot/compressed/head-davinci.S	2009-11-20 10:07:18.477791794 -0600
@@ -13,7 +13,6 @@
 		adr	r0, davinci_machine_no
 		str	r7, [r0]
 
-		.text
 		.globl	davinci_machine_no
 davinci_machine_no:
 		.word	0x00000000
Index: linux-2.6.29/arch/arm/configs/davinci_all_defconfig
===================================================================
--- linux-2.6.29.orig/arch/arm/configs/davinci_all_defconfig	2009-11-20 10:07:08.157955803 -0600
+++ linux-2.6.29/arch/arm/configs/davinci_all_defconfig	2009-11-20 10:07:18.481791746 -0600
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.29-rc4-davinci1
-# Tue Feb 10 20:29:48 2009
+# Linux kernel version: 2.6.29-davinci1
+# Thu Mar 26 14:20:44 2009
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -69,6 +69,7 @@
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
 CONFIG_EMBEDDED=y
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
@@ -79,10 +80,8 @@
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
-CONFIG_COMPAT_BRK=y
 CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
-CONFIG_ANON_INODES=y
 CONFIG_EPOLL=y
 CONFIG_SIGNALFD=y
 CONFIG_TIMERFD=y
@@ -91,6 +90,7 @@
 CONFIG_AIO=y
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
 # CONFIG_SLAB is not set
 CONFIG_SLUB=y
 # CONFIG_SLOB is not set
@@ -218,6 +218,7 @@
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
 # CONFIG_OUTER_CACHE is not set
+CONFIG_COMMON_CLKDEV=y
 
 #
 # Bus support
@@ -522,7 +523,6 @@
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-# CONFIG_MTD_QINFO_PROBE is not set
 
 #
 # UBI - Unsorted block images
@@ -657,6 +657,7 @@
 # CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
 # CONFIG_SMC911X is not set
 # CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
 # CONFIG_IBM_NEW_EMAC_ZMII is not set
 # CONFIG_IBM_NEW_EMAC_RGMII is not set
 # CONFIG_IBM_NEW_EMAC_TAH is not set
@@ -780,8 +781,8 @@
 #
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=2
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
 # CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
@@ -1089,6 +1090,7 @@
 CONFIG_SND_DAVINCI_SOC=m
 CONFIG_SND_DAVINCI_SOC_I2S=m
 CONFIG_SND_DAVINCI_SOC_EVM=m
+# CONFIG_SND_DAVINCI_SOC_SFFSDR is not set
 CONFIG_SND_SOC_I2C_AND_SPI=m
 # CONFIG_SND_SOC_ALL_CODECS is not set
 CONFIG_SND_SOC_TLV320AIC3X=m
Index: linux-2.6.29/arch/arm/mach-davinci/Kconfig
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/Kconfig	2009-11-20 10:07:08.061906135 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/Kconfig	2009-11-20 10:07:18.481791746 -0600
@@ -9,15 +9,12 @@
 
 config ARCH_DAVINCI_DM644x
 	bool "DaVinci 644x based system"
-	select CPU_V5
 
 config ARCH_DAVINCI_DM646x
         bool "DaVinci 646x based system"
-	select CPU_V5
 
 config ARCH_DAVINCI_DM355
         bool "DaVinci 355 based system"
-	select CPU_V5
 
 comment "DaVinci Board Type"
 
Index: linux-2.6.29/arch/arm/mach-davinci/board-dm355-evm.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/board-dm355-evm.c	2009-11-20 10:07:08.121842823 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/board-dm355-evm.c	2009-11-20 10:08:11.345853213 -0600
@@ -20,6 +20,9 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/clk.h>
+#include <media/v4l2-int-device.h>
+#include <media/tvp514x.h>
+#include <media/mt9v113_davinci.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/eeprom.h>
 
@@ -134,12 +137,101 @@
 	dm355evm_mmc_gpios = gpio;
 }
 
+#define TVP5146_I2C_ADDR		0x5D
+static struct v4l2_ifparm tvp5146_ifparm = {
+	.if_type = V4L2_IF_TYPE_BT656,
+	.u = {
+	      .bt656 = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct = 0,
+			.swap = 0,
+			.latch_clk_inv = 0,
+			.nobt_hs_inv = 0,	/* active high */
+			.nobt_vs_inv = 0,	/* active high */
+			.mode = V4L2_IF_TYPE_BT656_MODE_BT_8BIT,
+			.clock_min = TVP514X_XCLK_BT656,
+			.clock_max = TVP514X_XCLK_BT656,
+			},
+	      },
+};
+
+/**
+ * @brief tvp5146_g_ifparm - Returns the TVP5146 decoder interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_g_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = tvp5146_ifparm;
+	return 0;
+}
+
+#define TVP5146_NUM_INPUTS		ARRAY_SIZE(tvp5146_input_list)
+
+static struct tvp514x_platform_data tvp5146_pdata = {
+	.master = CAPTURE_DRV_NAME,
+	.ifparm = tvp5146_g_ifparm,
+	.hs_polarity = 1,
+	.vs_polarity = 1
+};
+
+/* for MT9V113 image sensor - BEGIN*/
+static struct v4l2_ifparm mt9v113_ifparm = {
+	.if_type = V4L2_IF_TYPE_PARALLEL,
+	.u = {
+	      .parallel = {
+			.frame_start_on_rising_vs = 1,
+			.swap = 0,
+			.latch_clk_inv = 0,
+			.no_hs_inv = 0,	/* active high */
+			.no_vs_inv = 0,	/* active high */
+			.clock_min = 6000000, /* 6Mhz */
+			.clock_max = 27000000, /*27Mhz*/
+			},
+	      },
+};
+
+/**
+ * @brief mt9v113_g_ifparm - Returns the mt9v113 decoder interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ * @return result of operation - 0 is success
+ */
+static int mt9v113_g_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = mt9v113_ifparm;
+	return 0;
+}
+
+static struct mt9v113_platform_data mt9v113_pdata = {
+	.master = CAPTURE_DRV_NAME,
+	.ifparm = mt9v113_g_ifparm,
+	.hs_polarity = 1,
+	.vs_polarity = 1
+};
+/* for MT9V113 image sensor - END*/
+
 static struct i2c_board_info dm355evm_i2c_info[] = {
-	{ I2C_BOARD_INFO("dm355evm_msp", 0x25),
+	{	I2C_BOARD_INFO("dm355evm_msp", 0x25),
 		.platform_data = dm355evm_mmcsd_gpios,
-		/* plus irq */ },
+	},
+	{
+		I2C_BOARD_INFO("tvp5146", TVP5146_I2C_ADDR),
+		.platform_data = &tvp5146_pdata,
+	},
+	{
+		I2C_BOARD_INFO("mt9v113", MT9V113_I2C_ADDR),
+		.platform_data = &mt9v113_pdata,
+	},	
+	/* { plus irq  }, */
 	/* { I2C_BOARD_INFO("tlv320aic3x", 0x1b), }, */
-	/* { I2C_BOARD_INFO("tvp5146", 0x5d), }, */
 };
 
 static void __init evm_init_i2c(void)
@@ -154,6 +246,24 @@
 			ARRAY_SIZE(dm355evm_i2c_info));
 }
 
+#ifdef CONFIG_MACH_DM355_LEOPARD
+static struct resource dm355evm_dm9000_rsrc[] = {
+	{
+		/* addr */
+		.start	= 0x04000000,
+		.end	= 0x04000001,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		/* data */
+		.start	= 0x04000016,
+		.end	= 0x04000017,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.flags	= IORESOURCE_IRQ
+			| IORESOURCE_IRQ_HIGHEDGE /* rising (active high) */,
+	},
+};
+#else
 static struct resource dm355evm_dm9000_rsrc[] = {
 	{
 		/* addr */
@@ -170,6 +280,7 @@
 			| IORESOURCE_IRQ_HIGHEDGE /* rising (active high) */,
 	},
 };
+#endif
 
 static struct platform_device dm355evm_dm9000 = {
 	.name		= "dm9000",
@@ -178,6 +289,41 @@
 	.num_resources	= ARRAY_SIZE(dm355evm_dm9000_rsrc),
 };
 
+#define TVP514X_STD_ALL	(V4L2_STD_NTSC | V4L2_STD_PAL)
+
+static struct vpfe_capture_input vpfe_capture_inputs = {
+	.num_inputs = VPFE_MAX_DEC_INPUTS,
+	.current_input = 0,
+	.inputs[0] = {
+		.dec_name = TVP514X_MODULE_NAME,
+		.input = {
+			.index = 0,
+			.name = "COMPOSITE",
+			.type = V4L2_INPUT_TYPE_CAMERA,
+			.std = TVP514X_STD_ALL,
+		},
+		.route = {
+			.input = INPUT_CVBS_VI2B,
+			.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+		},
+		.routing_supported = 1,
+	},
+	.inputs[1] = {
+		.dec_name = TVP514X_MODULE_NAME,
+		.input = {
+			.index = 1,
+			.name = "SVIDEO",
+			.type = V4L2_INPUT_TYPE_CAMERA,
+			.std = TVP514X_STD_ALL,
+		},
+		.route = {
+			.input = INPUT_SVIDEO_VI2C_VI1C,
+			.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+		},
+		.routing_supported = 1,
+	},
+};
+
 static struct platform_device *davinci_evm_devices[] __initdata = {
 	&dm355evm_dm9000,
 	&davinci_nand_device,
@@ -190,6 +336,8 @@
 static void __init dm355_evm_map_io(void)
 {
 	davinci_map_common_io();
+	/* setup input configuration for VPFE input devices */
+	setup_vpfe_input_config(&vpfe_capture_inputs);
 	dm355_init();
 }
 
@@ -251,9 +399,15 @@
 {
 	struct clk *aemif;
 
+#ifdef CONFIG_MACH_DM355_LEOPARD
+	gpio_request(9, "dm9000");
+	gpio_direction_input(9);
+	dm355evm_dm9000_rsrc[2].start = gpio_to_irq(9);
+#else
 	gpio_request(1, "dm9000");
 	gpio_direction_input(1);
 	dm355evm_dm9000_rsrc[2].start = gpio_to_irq(1);
+#endif
 
 	aemif = clk_get(&dm355evm_dm9000.dev, "aemif");
 	clk_enable(aemif);
Index: linux-2.6.29/arch/arm/mach-davinci/board-dm355-leopard.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/board-dm355-leopard.c	2009-11-20 10:07:08.089851316 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/board-dm355-leopard.c	2009-11-20 10:08:11.598160223 -0600
@@ -39,7 +39,7 @@
 #include <mach/mmc.h>
 
 #define DAVINCI_ASYNC_EMIF_CONTROL_BASE		0x01e10000
-#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE	0x02000000
+#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE		0x02000000
 
 /* NOTE:  this is geared for the standard config, with a socketed
  * 2 GByte Micron NAND (MT29F16G08FAA) using 128KB sectors.  If you
@@ -137,8 +137,6 @@
 	{ I2C_BOARD_INFO("dm355leopard_msp", 0x25),
 		.platform_data = dm355leopard_mmcsd_gpios,
 		/* plus irq */ },
-	/* { I2C_BOARD_INFO("tlv320aic3x", 0x1b), }, */
-	/* { I2C_BOARD_INFO("tvp5146", 0x5d), }, */
 };
 
 static void __init leopard_init_i2c(void)
Index: linux-2.6.29/arch/arm/mach-davinci/board-dm644x-evm.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/board-dm644x-evm.c	2009-11-20 10:07:08.114031771 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/board-dm644x-evm.c	2009-11-20 10:07:18.481791746 -0600
@@ -15,6 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>
+#include <linux/memory.h>
 
 #include <linux/i2c.h>
 #include <linux/i2c/pcf857x.h>
@@ -27,7 +28,9 @@
 #include <linux/io.h>
 #include <linux/phy.h>
 #include <linux/clk.h>
-
+#include <linux/videodev2.h>
+#include <media/v4l2-int-device.h>
+#include <media/tvp514x.h>
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 
@@ -169,6 +172,41 @@
 	.num_resources = 0,
 };
 
+
+#define TVP514X_STD_ALL	(V4L2_STD_NTSC | V4L2_STD_PAL)
+static struct vpfe_capture_input vpfe_capture_inputs = {
+	.num_inputs = VPFE_MAX_DEC_INPUTS,
+	.current_input = 0,
+	.inputs[0] = {
+		.dec_name = TVP514X_MODULE_NAME,
+		.input = {
+			.index = 0,
+			.name = "COMPOSITE",
+			.type = V4L2_INPUT_TYPE_CAMERA,
+			.std = TVP514X_STD_ALL,
+		},
+		.route = {
+			.input = INPUT_CVBS_VI2B,
+			.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+		},
+		.routing_supported = 1,
+	},
+	.inputs[1] = {
+		.dec_name = TVP514X_MODULE_NAME,
+		.input = {
+			.index = 1,
+			.name = "SVIDEO",
+			.type = V4L2_INPUT_TYPE_CAMERA,
+			.std = TVP514X_STD_ALL,
+		},
+		.route = {
+			.input = INPUT_SVIDEO_VI2C_VI1C,
+			.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+		},
+		.routing_supported = 1,
+	},
+};
+
 static struct platform_device rtc_dev = {
 	.name           = "rtc_davinci_evm",
 	.id             = -1,
@@ -412,17 +450,17 @@
  *  - 0x0039, 1 byte NTSC vs PAL (bit 0x80 == PAL)
  *  - ... newer boards may have more
  */
-static struct at24_iface *at24_if;
+static struct memory_accessor *at24_mem_acc;
 
-static int at24_setup(struct at24_iface *iface, void *context)
+static int at24_setup(struct memory_accessor *mem_acc, void *context)
 {
 	DECLARE_MAC_BUF(mac_str);
 	char mac_addr[6];
 
-	at24_if = iface;
+	at24_mem_acc = mem_acc;
 
 	/* Read MAC addr from EEPROM */
-	if (at24_if->read(at24_if, mac_addr, 0x7f00, 6) == 6) {
+	if (at24_mem_acc->read(at24_mem_acc, mac_addr, 0x7f00, 6) == 6) {
 		printk(KERN_INFO "Read MAC addr from EEPROM: %s\n",
 		       print_mac(mac_str, mac_addr));
 
@@ -441,20 +479,62 @@
 
 int dm6446evm_eeprom_read(void *buf, off_t off, size_t count)
 {
-	if (at24_if)
-		return at24_if->read(at24_if, buf, off, count);
+	if (at24_mem_acc)
+		return at24_mem_acc->read(at24_mem_acc, buf, off, count);
 	return -ENODEV;
 }
 EXPORT_SYMBOL(dm6446evm_eeprom_read);
 
 int dm6446evm_eeprom_write(void *buf, off_t off, size_t count)
 {
-	if (at24_if)
-		return at24_if->write(at24_if, buf, off, count);
+	if (at24_mem_acc)
+		return at24_mem_acc->write(at24_mem_acc, buf, off, count);
 	return -ENODEV;
 }
 EXPORT_SYMBOL(dm6446evm_eeprom_write);
 
+#define TVP5146_I2C_ADDR		(0x5D)
+static struct v4l2_ifparm tvp5146_ifparm = {
+	.if_type = V4L2_IF_TYPE_BT656,
+	.u = {
+	      .bt656 = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct = 0,
+			.swap = 0,
+			.latch_clk_inv = 0,
+			.nobt_hs_inv = 0,	/* active high */
+			.nobt_vs_inv = 0,	/* active high */
+			.mode = V4L2_IF_TYPE_BT656_MODE_BT_8BIT,
+			.clock_min = TVP514X_XCLK_BT656,
+			.clock_max = TVP514X_XCLK_BT656,
+			},
+	      },
+};
+
+/**
+ * @brief tvp5146_g_ifparm - Returns the TVP5146 decoder interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_g_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = tvp5146_ifparm;
+	return 0;
+}
+
+#define TVP5146_NUM_INPUTS		ARRAY_SIZE(tvp5146_input_list)
+
+static struct tvp514x_platform_data tvp5146_pdata = {
+	.master = CAPTURE_DRV_NAME,
+	.ifparm = tvp5146_g_ifparm,
+	.hs_polarity = 1,
+	.vs_polarity = 1
+};
+
 /*
  * MSP430 supports RTC, card detection, input from IR remote, and
  * a bit more.  It triggers interrupts on GPIO(7) from pressing
@@ -566,9 +646,12 @@
 		I2C_BOARD_INFO("24c256", 0x50),
 		.platform_data	= &eeprom_info,
 	},
+	{
+		I2C_BOARD_INFO("tvp5146", TVP5146_I2C_ADDR),
+		.platform_data = &tvp5146_pdata,
+	},
 	/* ALSO:
 	 * - tvl320aic33 audio codec (0x1b)
-	 * - tvp5146 video decoder (0x5d)
 	 */
 };
 
@@ -600,6 +683,8 @@
 davinci_evm_map_io(void)
 {
 	davinci_map_common_io();
+	/* setup input configuration for VPFE input devices */
+	setup_vpfe_input_config(&vpfe_capture_inputs);
 	dm644x_init();
 }
 
Index: linux-2.6.29/arch/arm/mach-davinci/board-dm646x-evm.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/board-dm646x-evm.c	2009-11-20 10:07:08.078031653 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/board-dm646x-evm.c	2009-11-20 10:07:18.481791746 -0600
@@ -39,6 +39,7 @@
 #include <mach/serial.h>
 #include <mach/i2c.h>
 #include <mach/mmc.h>
+#include <mach/mux.h>
 
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
@@ -49,6 +50,19 @@
 #define DM646X_EVM_PHY_MASK		(0x2)
 #define DM646X_EVM_MDIO_FREQUENCY	(2200000) /* PHY bus frequency */
 
+#define VIDCLKCTL_OFFSET	(0x38)
+#define VSCLKDIS_OFFSET		(0x6c)
+
+#define VCH2CLK_MASK		(BIT_MASK(10) | BIT_MASK(9) | BIT_MASK(8))
+#define VCH2CLK_SYSCLK8		(BIT(9))
+#define VCH2CLK_AUXCLK		(BIT(9) | BIT(8))
+#define VCH3CLK_MASK		(BIT_MASK(14) | BIT_MASK(13) | BIT_MASK(12))
+#define VCH3CLK_SYSCLK8		(BIT(13))
+#define VCH3CLK_AUXCLK		(BIT(14) | BIT(13))
+
+#define VIDCH2CLK		(BIT(10))
+#define VIDCH3CLK		(BIT(11))
+
 static struct emac_platform_data dm646x_evm_emac_pdata = {
 	.phy_mask	= DM646X_EVM_PHY_MASK,
 	.mdio_max_freq	= DM646X_EVM_MDIO_FREQUENCY,
@@ -62,17 +76,17 @@
  *  - 0x7f00, 6 bytes Ethernet Address
  *  - ... newer boards may have more
  */
-static struct at24_iface *at24_if;
+static struct memory_accessor *at24_mem_acc;
 
-static int at24_setup(struct at24_iface *iface, void *context)
+static int at24_setup(struct memory_accessor *mem_acc, void *context)
 {
 	DECLARE_MAC_BUF(mac_str);
 	char mac_addr[6];
 
-	at24_if = iface;
+	at24_mem_acc = mem_acc;
 
 	/* Read MAC addr from EEPROM */
-	if (at24_if->read(at24_if, mac_addr, 0x7f00, 6) == 6) {
+	if (at24_mem_acc->read(at24_mem_acc, mac_addr, 0x7f00, 6) == 6) {
 		printk(KERN_INFO "Read MAC addr from EEPROM: %s\n",
 		print_mac(mac_str, mac_addr));
 
@@ -89,25 +103,68 @@
 
 int dm646xevm_eeprom_read(void *buf, off_t off, size_t count)
 {
-	if (at24_if)
-		return at24_if->read(at24_if, buf, off, count);
+	if (at24_mem_acc)
+		return at24_mem_acc->read(at24_mem_acc, buf, off, count);
 	return -ENODEV;
 }
 EXPORT_SYMBOL(dm646xevm_eeprom_read);
 
 int dm646xevm_eeprom_write(void *buf, off_t off, size_t count)
 {
-	if (at24_if)
-		return at24_if->write(at24_if, buf, off, count);
+	if (at24_mem_acc)
+		return at24_mem_acc->write(at24_mem_acc, buf, off, count);
 	return -ENODEV;
 }
 EXPORT_SYMBOL(dm646xevm_eeprom_write);
 
+static struct i2c_client *cpld_client;
+
+static int cpld_video_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	cpld_client = client;
+	return 0;
+}
+
+static int __devexit cpld_video_remove(struct i2c_client *client)
+{
+	cpld_client = NULL;
+	return 0;
+}
+
+static const struct i2c_device_id cpld_video_id[] = {
+	{ "cpld_video", 0 },
+	{ }
+};
+
+static struct i2c_driver cpld_video_driver = {
+	.driver = {
+		.name	= "cpld_video",
+	},
+	.probe		= cpld_video_probe,
+	.remove		= cpld_video_remove,
+	.id_table	= cpld_video_id,
+};
+
+static void evm_init_cpld(void)
+{
+	i2c_add_driver(&cpld_video_driver);
+}
+
 static struct i2c_board_info __initdata i2c_info[] =  {
 	{
 		I2C_BOARD_INFO("24c256", 0x50),
 		.platform_data  = &eeprom_info,
 	},
+	{
+		I2C_BOARD_INFO("adv7343", 0x2A),
+	},
+	{
+		I2C_BOARD_INFO("ths7303", 0x2C),
+	},
+	{
+		I2C_BOARD_INFO("cpld_video", 0x3B),
+	},
 };
 
 static struct davinci_i2c_platform_data i2c_pdata = {
@@ -115,10 +172,90 @@
 	.bus_delay      = 0 /* usec */,
 };
 
+static int set_vpif_clock(int mux_mode, int hd)
+{
+	int val = 0;
+	int err = 0;
+	unsigned int value;
+	void __iomem *base = IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE);
+
+	/* disable the clock */
+	value = __raw_readl(base + VSCLKDIS_OFFSET);
+	value |= (VIDCH3CLK | VIDCH2CLK);
+	__raw_writel(value, base + VSCLKDIS_OFFSET);
+
+	val = i2c_smbus_read_byte(cpld_client);
+	if (val < 0)
+		return val;
+
+	if (mux_mode == 1)
+		val &= ~0x40;
+	else
+		val |= 0x40;
+
+	err = i2c_smbus_write_byte(cpld_client, val);
+	if (err)
+		return err;
+
+	value = __raw_readl(base + VIDCLKCTL_OFFSET);
+	value &= ~(VCH2CLK_MASK);
+	value &= ~(VCH3CLK_MASK);
+
+	if (hd >= 1)
+		value |= (VCH2CLK_SYSCLK8 | VCH3CLK_SYSCLK8);
+	else
+		value |= (VCH2CLK_AUXCLK | VCH3CLK_AUXCLK);
+
+	__raw_writel(value, base + VIDCLKCTL_OFFSET);
+
+	/* enable the clock */
+	value = __raw_readl(base + VSCLKDIS_OFFSET);
+	value &= ~(VIDCH3CLK | VIDCH2CLK);
+	__raw_writel(value, base + VSCLKDIS_OFFSET);
+
+	return 0;
+}
+
+static const struct subdev_info dm646x_vpif_subdev[] = {
+	{
+		.addr	= 0x2A,
+		.name	= "adv7343",
+	},
+	{
+		.addr	= 0x2C,
+		.name	= "ths7303",
+	},
+};
+
+static struct vpif_output output[] = {
+	{
+		.id	= 0,
+		.name	= "Composite"
+	},
+	{
+		.id	= 1,
+		.name	= "Component"
+	},
+	{
+		.id	= 2,
+		.name	= "S-Video"
+	},
+};
+
+static struct vpif_config dm646x_vpif_config = {
+	.set_clock	= set_vpif_clock,
+	.subdevinfo	= (struct subdev_info *)dm646x_vpif_subdev,
+	.subdev_count	= ARRAY_SIZE(dm646x_vpif_subdev),
+	.output		= output,
+	.output_count	= ARRAY_SIZE(output),
+	.card_name	= "DM646x EVM",
+};
+
 static void __init evm_init_i2c(void)
 {
 	davinci_init_i2c(&i2c_pdata);
 	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
+	evm_init_cpld();
 }
 
 static void __init davinci_map_io(void)
@@ -132,6 +269,7 @@
 	evm_init_i2c();
 	davinci_serial_init(&uart_config);
 	davinci_init_emac(&dm646x_evm_emac_pdata);
+	dm646x_setup_vpif(&dm646x_vpif_config);
 }
 
 static __init void davinci_dm646x_evm_irq_init(void)
Index: linux-2.6.29/arch/arm/mach-davinci/dm355.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/dm355.c	2009-11-20 10:07:08.098031688 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/dm355.c	2009-11-20 10:08:11.337832639 -0600
@@ -463,6 +463,14 @@
 EVT_CFG(DM355,  EVT8_ASP1_TX,	      0,    1,    0,     false)
 EVT_CFG(DM355,  EVT9_ASP1_RX,	      1,    1,    0,     false)
 EVT_CFG(DM355,  EVT26_MMC0_RX,	      2,    1,    0,     false)
+
+MUX_CFG(DM355,	VIN_PCLK,	0,   14,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_WEN,	0,   13,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_VD,	0,   12,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CAM_HD,	0,   11,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_YIN_EN,	0,   10,    1,    1,	 false)
+MUX_CFG(DM355,	VIN_CINL_EN,	0,   0,   0xff, 0x55,	 false)
+MUX_CFG(DM355,	VIN_CINH_EN,	0,   8,     3,    3,	 false)
 };
 
 /*----------------------------------------------------------------------*/
@@ -520,6 +528,47 @@
 	.resource		= edma_resources,
 };
 
+static struct resource vpfe_resources[] = {
+	{
+		.start          = IRQ_VDINT0,
+		.end            = IRQ_VDINT0,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = IRQ_VDINT1,
+		.end            = IRQ_VDINT1,
+		.flags          = IORESOURCE_IRQ,
+	},
+	/* CCDC Base address */
+	{
+		.flags          = IORESOURCE_MEM,
+		.start          = 0x01c70600,
+		.end            = 0x01c70600 + 0x1ff,
+	},
+	/* VPSS Base address */
+	{
+		.start          = 0x01c70800,
+		.end            = 0x01c70800 + 0xff,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static u64 vpfe_capture_dma_mask = DMA_32BIT_MASK;
+static struct platform_device vpfe_capture_dev = {
+	.name		= CAPTURE_DRV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(vpfe_resources),
+	.resource	= vpfe_resources,
+	.dev = {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_32BIT_MASK,
+	},
+};
+
+void setup_vpfe_input_config(struct vpfe_capture_input *input_config)
+{
+	vpfe_capture_dev.dev.platform_data = input_config;
+}
 /*----------------------------------------------------------------------*/
 
 void __init dm355_init(void)
@@ -528,13 +577,28 @@
 	davinci_mux_register(dm355_pins, ARRAY_SIZE(dm355_pins));;
 }
 
+#define DM355_VPSSCLK_CLKCTRL_REG	0x1c70004
 static int __init dm355_init_devices(void)
 {
+	void __iomem *base = IO_ADDRESS(DM355_VPSSCLK_CLKCTRL_REG);
 	if (!cpu_is_davinci_dm355())
 		return 0;
 
 	davinci_cfg_reg(DM355_INT_EDMA_CC);
 	platform_device_register(&dm355_edma_device);
+	/* setup clock for vpss modules */
+	__raw_writel(0x79, base);
+	/* setup Mux configuration for vpfe input and register
+	 * vpfe capture platform device
+	 */
+	davinci_cfg_reg(DM355_VIN_PCLK);
+	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+	davinci_cfg_reg(DM355_VIN_CAM_VD);
+	davinci_cfg_reg(DM355_VIN_CAM_HD);
+	davinci_cfg_reg(DM355_VIN_YIN_EN);
+	davinci_cfg_reg(DM355_VIN_CINL_EN);
+	davinci_cfg_reg(DM355_VIN_CINH_EN);
+	platform_device_register(&vpfe_capture_dev);
 	return 0;
 }
 postcore_initcall(dm355_init_devices);
Index: linux-2.6.29/arch/arm/mach-davinci/dm644x.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/dm644x.c	2009-11-20 10:07:08.085780127 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/dm644x.c	2009-11-20 10:07:18.481791746 -0600
@@ -443,6 +443,46 @@
 	.resource		= edma_resources,
 };
 
+static struct resource vpfe_resources[] = {
+	{
+		.start          = IRQ_VDINT0,
+		.end            = IRQ_VDINT0,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = IRQ_VDINT1,
+		.end            = IRQ_VDINT1,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		.start          = 0x01c70400,
+		.end            = 0x01c70400 + 0xff,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		.start          = 0x01c73400,
+		.end            = 0x01c73400 + 0xff,
+		.flags          = IORESOURCE_MEM,
+	},
+};
+
+static u64 vpfe_capture_dma_mask = DMA_32BIT_MASK;
+static struct platform_device vpfe_capture_dev = {
+	.name		= CAPTURE_DRV_NAME,
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(vpfe_resources),
+	.resource	= vpfe_resources,
+	.dev = {
+		.dma_mask		= &vpfe_capture_dma_mask,
+		.coherent_dma_mask	= DMA_32BIT_MASK,
+	},
+};
+
+void setup_vpfe_input_config(struct vpfe_capture_input *input_config)
+{
+	vpfe_capture_dev.dev.platform_data = input_config;
+}
+
 /*----------------------------------------------------------------------*/
 #if defined(CONFIG_TI_DAVINCI_EMAC) || defined(CONFIG_TI_DAVINCI_EMAC_MODULE)
 
@@ -475,6 +515,8 @@
 		return 0;
 
 	platform_device_register(&dm644x_edma_device);
+	/* Register VPFE capture device */
+	platform_device_register(&vpfe_capture_dev);
 	return 0;
 }
 postcore_initcall(dm644x_init_devices);
Index: linux-2.6.29/arch/arm/mach-davinci/dm646x.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/dm646x.c	2009-11-20 10:07:08.106049190 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/dm646x.c	2009-11-20 10:07:18.481791746 -0600
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 
 #include <mach/dm646x.h>
 #include <mach/clock.h>
@@ -24,6 +25,15 @@
 #include "clock.h"
 #include "mux.h"
 
+#define DAVINCI_VPIF_BASE       (0x01C12000)
+#define VDD3P3V_PWDN_OFFSET	(0x48)
+#define VSCLKDIS_OFFSET		(0x6C)
+
+#define VDD3P3V_VID_MASK	(BIT_MASK(7) | BIT_MASK(6) | BIT_MASK(5) |\
+					BIT_MASK(4))
+#define VSCLKDIS_MASK		(BIT_MASK(11) | BIT_MASK(10) | BIT_MASK(9) |\
+					BIT_MASK(8))
+
 /*
  * Device specific clocks
  */
@@ -421,8 +431,61 @@
 	.resource		= edma_resources,
 };
 
+static u64 vpif_dma_mask = DMA_32BIT_MASK;
+
+static struct resource vpif_resource[] = {
+	{
+		.start	= DAVINCI_VPIF_BASE,
+		.end	= DAVINCI_VPIF_BASE + 0x03fff,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start = IRQ_DM646X_VP_VERTINT2,
+		.end   = IRQ_DM646X_VP_VERTINT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = IRQ_DM646X_VP_VERTINT3,
+		.end   = IRQ_DM646X_VP_VERTINT3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device vpif_display_dev = {
+	.name		= "vpif_display",
+	.id		= -1,
+	.dev		= {
+			.dma_mask 		= &vpif_dma_mask,
+			.coherent_dma_mask	= DMA_32BIT_MASK,
+	},
+	.resource	= vpif_resource,
+	.num_resources	= ARRAY_SIZE(vpif_resource),
+};
+
 /*----------------------------------------------------------------------*/
 
+void dm646x_setup_vpif(struct vpif_config *config)
+{
+	unsigned int value;
+	void __iomem *base = IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE);
+
+	value = __raw_readl(base + VSCLKDIS_OFFSET);
+	value &= ~VSCLKDIS_MASK;
+	__raw_writel(value, base + VSCLKDIS_OFFSET);
+
+	value = __raw_readl(base + VDD3P3V_PWDN_OFFSET);
+	value &= ~VDD3P3V_VID_MASK;
+	__raw_writel(value, base + VDD3P3V_PWDN_OFFSET);
+
+	davinci_cfg_reg(DM646X_STSOMUX_DISABLE);
+	davinci_cfg_reg(DM646X_STSIMUX_DISABLE);
+	davinci_cfg_reg(DM646X_PTSOMUX_DISABLE);
+	davinci_cfg_reg(DM646X_PTSIMUX_DISABLE);
+
+	vpif_display_dev.dev.platform_data = config;
+	platform_device_register(&vpif_display_dev);
+}
+
 #if defined(CONFIG_TI_DAVINCI_EMAC) || defined(CONFIG_TI_DAVINCI_EMAC_MODULE)
 
 void dm646x_init_emac(struct emac_platform_data *pdata)
Index: linux-2.6.29/arch/arm/mach-davinci/include/mach/dm355.h
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/include/mach/dm355.h	2009-11-20 10:07:08.134094383 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/include/mach/dm355.h	2009-11-20 10:07:18.481791746 -0600
@@ -12,6 +12,7 @@
 #define __ASM_ARCH_DM355_H
 
 #include <mach/hardware.h>
+#include <media/davinci/vpfe_capture.h>
 
 void __init dm355_init(void);
 
@@ -19,5 +20,6 @@
 
 void dm355_init_spi0(unsigned chipselect_mask,
 		struct spi_board_info *info, unsigned len);
+void setup_vpfe_input_config(struct vpfe_capture_input *input_config);
 
 #endif /* __ASM_ARCH_DM355_H */
Index: linux-2.6.29/arch/arm/mach-davinci/include/mach/dm644x.h
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/include/mach/dm644x.h	2009-11-20 10:07:08.142281460 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/include/mach/dm644x.h	2009-11-20 10:07:18.481791746 -0600
@@ -24,6 +24,7 @@
 
 #include <linux/platform_device.h>
 #include <mach/hardware.h>
+#include <media/davinci/vpfe_capture.h>
 #include <mach/emac.h>
 
 #define DM644X_EMAC_BASE		(0x01C80000)
@@ -34,6 +35,7 @@
 #define DM644X_EMAC_CNTRL_RAM_SIZE	(0x2000)
 
 void __init dm644x_init(void);
+void setup_vpfe_input_config(struct vpfe_capture_input *input_config);
 void dm644x_init_emac(struct emac_platform_data *pdata);
 
 #endif /* __ASM_ARCH_DM644X_H */
Index: linux-2.6.29/arch/arm/mach-davinci/include/mach/dm646x.h
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/include/mach/dm646x.h	2009-11-20 10:07:08.153845503 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/include/mach/dm646x.h	2009-11-20 10:07:18.481791746 -0600
@@ -12,6 +12,7 @@
 #define __ASM_ARCH_DM646X_H
 
 #include <linux/platform_device.h>
+#include <linux/i2c.h>
 #include <mach/hardware.h>
 #include <mach/emac.h>
 
@@ -25,4 +26,28 @@
 void __init dm646x_init(void);
 void dm646x_init_emac(struct emac_platform_data *pdata);
 
+void dm646x_video_init(void);
+
+struct vpif_output {
+	u16 id;
+	const char *name;
+};
+
+struct subdev_info {
+	u8 addr;
+	const char *name;
+};
+
+struct vpif_config {
+	int (*set_clock)(int, int);
+	struct subdev_info *subdevinfo;
+	int subdev_count;
+	struct vpif_output *output;
+	int output_count;
+	const char *card_name;
+};
+
+
+void dm646x_setup_vpif(struct vpif_config *config);
+
 #endif /* __ASM_ARCH_DM646X_H */
Index: linux-2.6.29/arch/arm/mach-davinci/include/mach/mux.h
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/include/mach/mux.h	2009-11-20 10:07:08.126031624 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/include/mach/mux.h	2009-11-20 10:08:11.353848644 -0600
@@ -166,6 +166,15 @@
 	DM355_EVT8_ASP1_TX,
 	DM355_EVT9_ASP1_RX,
 	DM355_EVT26_MMC0_RX,
+
+	/* Video In Pin Mux */
+	DM355_VIN_PCLK,
+	DM355_VIN_CAM_WEN,
+	DM355_VIN_CAM_VD,
+	DM355_VIN_CAM_HD,
+	DM355_VIN_YIN_EN,
+	DM355_VIN_CINL_EN,
+	DM355_VIN_CINH_EN,
 };
 
 #ifdef CONFIG_DAVINCI_MUX
Index: linux-2.6.29/arch/arm/mach-davinci/psc.c
===================================================================
--- linux-2.6.29.orig/arch/arm/mach-davinci/psc.c	2009-11-20 10:07:08.069901846 -0600
+++ linux-2.6.29/arch/arm/mach-davinci/psc.c	2009-11-20 10:07:18.485791697 -0600
@@ -39,6 +39,7 @@
 #define MDSTAT		0x800
 #define MDCTL		0xA00
 
+#define MDSTAT_STATE_MASK 0x1f
 
 /* Return nonzero iff the domain's clock is active */
 int __init davinci_psc_is_clk_active(unsigned int id)
@@ -53,14 +54,13 @@
 /* Enable or disable a PSC domain */
 void davinci_psc_config(unsigned int domain, unsigned int id, char enable)
 {
-	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl, mdstat_mask;
+	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl;
 	void __iomem *psc_base = IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE);
+	u32 next_state = enable ? 0x3 : 0x2; /* 0x3 enables, 0x2 disables */
 
 	mdctl = __raw_readl(psc_base + MDCTL + 4 * id);
-	if (enable)
-		mdctl |= 0x00000003;	/* Enable Module */
-	else
-		mdctl &= 0xFFFFFFE2;	/* Disable Module */
+	mdctl &= ~MDSTAT_STATE_MASK;
+	mdctl |= next_state;
 	__raw_writel(mdctl, psc_base + MDCTL + 4 * id);
 
 	pdstat = __raw_readl(psc_base + PDSTAT);
@@ -93,12 +93,7 @@
 		} while (!(((ptstat >> domain) & 1) == 0));
 	}
 
-	if (enable)
-		mdstat_mask = 0x3;
-	else
-		mdstat_mask = 0x2;
-
 	do {
 		mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
-	} while (!((mdstat & 0x0000001F) == mdstat_mask));
+	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state));
 }
Index: linux-2.6.29/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.29.orig/arch/arm/tools/mach-types	2009-11-20 10:07:08.170316875 -0600
+++ linux-2.6.29/arch/arm/tools/mach-types	2009-11-20 10:07:18.485791697 -0600
@@ -2124,3 +2124,5 @@
 fmzwebmodul		MACH_FMZWEBMODUL	FMZWEBMODUL		2134
 rd78x00_masa		MACH_RD78X00_MASA	RD78X00_MASA		2135
 smallogger		MACH_SMALLOGGER		SMALLOGGER		2136
+dm355_leopard		MACH_DM355_LEOPARD	DM355_LEOPARD		2138
+
Index: linux-2.6.29/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.29.orig/drivers/media/video/Kconfig	2009-11-20 10:07:08.202210323 -0600
+++ linux-2.6.29/drivers/media/video/Kconfig	2009-11-20 10:08:11.373847836 -0600
@@ -361,6 +361,17 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called saa7191.
 
+config VIDEO_MT9V113_DAVINCI
+	tristate "Aptina MT9V113 VGA CMOS IMAGE SENSOR"
+	depends on VIDEO_V4L2 && I2C
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Aptina MT9V113
+	  image sensor. It is currently working with the TI DAVINCI DM355
+	  processor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mt9v113_davinci.
+
 config VIDEO_TVP514X
 	tristate "Texas Instruments TVP514x video decoder"
 	depends on VIDEO_V4L2 && I2C
@@ -473,6 +484,28 @@
 
 endmenu # encoder / decoder chips
 
+config DISPLAY_DAVINCI_DM646X_EVM
+        tristate "DM646x EVM Video Display"
+        depends on VIDEO_DEV && MACH_DAVINCI_DM646X_EVM
+        select VIDEOBUF_DMA_CONTIG
+        select VIDEO_DAVINCI_VPIF
+        select VIDEO_ADV7343
+        select VIDEO_THS7303
+        help
+          Support for DaVinci based display device.
+
+          To compile this driver as a module, choose M here: the
+          module will be called davincihd_display.
+
+config VIDEO_DAVINCI_VPIF
+        tristate "DaVinci VPIF Driver"
+        depends on DISPLAY_DAVINCI_DM646X_EVM
+        help
+          Support for DaVinci VPIF Driver.
+
+          To compile this driver as a module, choose M here: the
+          module will be called vpif.
+
 config VIDEO_VIVI
 	tristate "Virtual Video Driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
@@ -485,25 +518,45 @@
 	  Say Y here if you want to test video apps or debug V4L devices.
 	  In doubt, say N.
 
-config VIDEO_TVP5146
-	tristate "TVP5146 video decoder"
-	depends on I2C && ARCH_DAVINCI
+config VIDEO_VPFE_CAPTURE
+	tristate "VPFE Video Capture Driver"
+	depends on VIDEO_V4L2 && ARCH_DAVINCI
+	select VIDEOBUF_DMA_CONTIG
 	help
-	  Support for I2C bus based TVP5146 configuration.
+	  Support for DMXXXX VPFE based frame grabber. This is the
+	  common V4L2 module for following DMXXX SoCs from Texas
+	  Instruments:- DM6446 & DM355.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called tvp5146.
+	  module will be called vpfe-capture.
 
-config VIDEO_DAVINCI
-	tristate "Davinci Video Capture"
-	depends on VIDEO_DEV && VIDEO_TVP5146 && ARCH_DAVINCI
-	select VIDEOBUF_GEN
-	select VIDEOBUF_DMA_SG
+config VIDEO_DAVINCI_CCDC
+	tristate "DM6446 CCDC HW module"
+	depends on ARCH_DAVINCI_DM644x && VIDEO_VPFE_CAPTURE
+	default y
 	help
-	  Support for Davinci based frame grabber through CCDC.
+	   Enables DaVinci CCD hw module. DaVinci CCDC hw interfaces
+	   with decoder modules such as TVP5146 over BT656 or
+	   sensor module such as MT9T001 over a raw interface. This
+	   module configures the interface and CCDC/ISIF to do
+	   video frame capture from slave decoders.
+
+	   To compile this driver as a module, choose M here: the
+	   module will be called vpfe.
+
+config VIDEO_DM355_CCDC
+	tristate "DM355 CCDC HW module"
+	depends on ARCH_DAVINCI_DM355 && VIDEO_VPFE_CAPTURE
+	default y
+	help
+	   Enables DM355 CCD hw module. DM355 CCDC hw interfaces
+	   with decoder modules such as TVP5146 over BT656 or
+	   sensor module such as MT9T001 over a raw interface. This
+	   module configures the interface and CCDC/ISIF to do
+	   video frame capture from a slave decoders
 
-	  To compile this driver as a module, choose M here: the
-	  module will be called vpfe.
+	   To compile this driver as a module, choose M here: the
+	   module will be called vpfe.
 
 source "drivers/media/video/bt8xx/Kconfig"
 
Index: linux-2.6.29/drivers/media/video/Makefile
===================================================================
--- linux-2.6.29.orig/drivers/media/video/Makefile	2009-11-20 10:07:08.222648401 -0600
+++ linux-2.6.29/drivers/media/video/Makefile	2009-11-20 10:07:18.485791697 -0600
@@ -10,8 +10,6 @@
 
 omap2cam-objs	:=	omap24xxcam.o omap24xxcam-dma.o
 
-davinci-vpfe-objs   :=  ccdc_davinci.o davinci_vpfe.o
-
 videodev-objs	:=	v4l2-dev.o v4l2-ioctl.o
 
 videodev-objs	:=	v4l2-dev.o v4l2-ioctl.o v4l2-device.o v4l2-subdev.o
@@ -29,6 +27,7 @@
 
 obj-$(CONFIG_VIDEO_TUNER) += tuner.o
 
+obj-$(CONFIG_ARCH_DAVINCI)        += davinci/
 obj-$(CONFIG_VIDEO_BT848) += bt8xx/
 obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 obj-$(CONFIG_VIDEO_TVAUDIO) += tvaudio.o
@@ -77,6 +76,7 @@
 obj-$(CONFIG_VIDEO_USBVISION) += usbvision/
 obj-$(CONFIG_VIDEO_TVP5150) += tvp5150.o
 obj-$(CONFIG_VIDEO_TVP514X) += tvp514x.o
+obj-$(CONFIG_VIDEO_MT9V113_DAVINCI) += mt9v113_davinci.o
 obj-$(CONFIG_VIDEO_PVRUSB2) += pvrusb2/
 obj-$(CONFIG_VIDEO_MSP3400) += msp3400.o
 obj-$(CONFIG_VIDEO_CS5345) += cs5345.o
@@ -135,9 +135,6 @@
 obj-$(CONFIG_VIDEO_IVTV) += ivtv/
 obj-$(CONFIG_VIDEO_CX18) += cx18/
 
-obj-$(CONFIG_VIDEO_DAVINCI)     += davinci-vpfe.o
-obj-$(CONFIG_VIDEO_TVP5146)     += tvp5146.o
-
 obj-$(CONFIG_VIDEO_VIVI) += vivi.o
 obj-$(CONFIG_VIDEO_CX23885) += cx23885/
 
@@ -157,6 +154,8 @@
 
 obj-$(CONFIG_USB_VIDEO_CLASS)	+= uvc/
 
+obj-$(CONFIG_ARCH_DAVINCI)	+= davinci/
+
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
 EXTRA_CFLAGS += -Idrivers/media/common/tuners
Index: linux-2.6.29/drivers/media/video/ccdc_davinci.c
===================================================================
--- linux-2.6.29.orig/drivers/media/video/ccdc_davinci.c	2009-11-20 10:07:08.210155190 -0600
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,124 +0,0 @@
-/*
- *
- *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* ccdc_davinci.c */
-
-#include <media/ccdc_davinci.h>
-#define debug_print(x...)	//printk(x)
-void ccdc_reset()
-{
-	int i;
-	/* disable CCDC */
-	ccdc_enable(0);
-	/* set all registers to default value */
-	for (i = 0; i <= 0x94; i += 4) {
-		regw(0, i);
-	}
-	regw(0, PCR);
-	regw(0, SYN_MODE);
-	regw(0, HD_VD_WID);
-	regw(0, PIX_LINES);
-	regw(0, HORZ_INFO);
-	regw(0, VERT_START);
-	regw(0, VERT_LINES);
-	regw(0xffff00ff, CULLING);
-	regw(0, HSIZE_OFF);
-	regw(0, SDOFST);
-	regw(0, SDR_ADDR);
-	regw(0, VDINT);
-	regw(0, REC656IF);
-	regw(0, CCDCFG);
-	regw(0, FMTCFG);
-	regw(0, VP_OUT);
-}
-
-void ccdc_setwin(ccdc_params_ycbcr * params)
-{
-	int horz_start, horz_nr_pixels;
-	int vert_start, vert_nr_lines;
-
-	/* configure horizonal and vertical starts and sizes */
-	horz_start = params->win.left << 1;
-	horz_nr_pixels = (params->win.width <<1) - 1;
-	regw((horz_start << 16) | horz_nr_pixels, HORZ_INFO);
-
-	vert_start = params->win.top;
-
-	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
-		vert_nr_lines = (params->win.height >> 1) - 1;
-		vert_start >>= 1;
-	} else {
-		vert_nr_lines = params->win.height - 1;
-	}
-	regw((vert_start << 16) | vert_start, VERT_START);
-	regw(vert_nr_lines, VERT_LINES);
-}
-
-void ccdc_config_ycbcr(ccdc_params_ycbcr * params)
-{
-	u32 syn_mode;
-
-	/* first reset the CCDC                                          */
-	/* all registers have default values after reset                 */
-	/* This is important since we assume default values to be set in */
-	/* a lot of registers that we didn't touch                       */
-	ccdc_reset();
-
-	/* configure pixel format */
-	syn_mode = (params->pix_fmt & 0x3) << 12;
-
-	/* configure video frame format */
-	syn_mode |= (params->frm_fmt & 0x1) << 7;
-
-	/* setup BT.656 sync mode */
-	if (params->bt656_enable) {
-		regw(3, REC656IF);
-
-		/* configure the FID, VD, HD pin polarity */
-		/* fld,hd pol positive, vd negative, 8-bit pack mode */
-		syn_mode |= 0x00000F04;
-	} else {/* y/c external sync mode */
-		syn_mode |= ((params->fid_pol & 0x1) << 4);
-		syn_mode |= ((params->hd_pol & 0x1) << 3);
-		syn_mode |= ((params->vd_pol & 0x1) << 2);
-	}
-
-	/* configure video window */
-	ccdc_setwin(params);
-
-	/* configure the order of y cb cr in SD-RAM */
-	regw((params->pix_order << 11) | 0x8000, CCDCFG);
-
-	/* configure the horizontal line offset */
-	/* this is done by rounding up width to a multiple of 16 pixels */
-	/* and multiply by two to account for y:cb:cr 4:2:2 data */
-	regw(((params->win.width * 2) + 31) & 0xffffffe0, HSIZE_OFF);
-
-	/* configure the memory line offset */
-	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
-		/* two fields are interleaved in memory */
-		regw(0x00000249, SDOFST);
-	}
-	/* enable output to SDRAM */
-	syn_mode |= (0x1 << 17);
-	/* enable internal timing generator */
-	syn_mode |= (0x1 << 16);
-
-	regw(syn_mode, SYN_MODE);
-}
Index: linux-2.6.29/drivers/media/video/davinci/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/Makefile	2009-11-20 10:08:11.377844994 -0600
@@ -0,0 +1,18 @@
+#
+# Makefile for the davinci video device drivers.
+#
+
+# Capture: DaVinci and DM355
+obj-$(CONFIG_VIDEO_DAVINCI_CCDC) += ccdc_davinci.o
+obj-$(CONFIG_VIDEO_DM355_CCDC) += ccdc_dm355.o
+obj-$(CONFIG_VIDEO_VPFE_CAPTURE) += vpfe_capture.o
+
+#
+# Makefile for the davinci video device drivers.
+#
+
+# VPIF
+obj-$(CONFIG_VIDEO_DAVINCI_VPIF) += vpif.o
+
+#DM646x EVM Display driver
+obj-$(CONFIG_DISPLAY_DAVINCI_DM646X_EVM) += vpif_display.o
Index: linux-2.6.29/drivers/media/video/davinci/ccdc_davinci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/ccdc_davinci.c	2009-11-20 10:07:18.490416588 -0600
@@ -0,0 +1,1007 @@
+/*
+ * Copyright (C) 2006-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <asm/page.h>
+#include <media/davinci/ccdc_hw_device.h>
+#include "ccdc_davinci.h"
+
+static struct device *dev;
+
+/* Object for CCDC raw mode */
+static struct ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	.win = CCDC_WIN_VGA,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = 0,
+	.data_sz = _10BITS,
+	.alaw = {
+		.b_alaw_enable = 0
+	},
+	.blk_clamp = {
+		.b_clamp_enable = 0,
+		.dc_sub = 0
+	},
+	.blk_comp = {0, 0, 0, 0},
+	.fault_pxl = {
+		.fpc_enable = 0
+	},
+};
+
+/* Object for CCDC ycbcr mode */
+static struct ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+	.win = CCDC_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = 1,
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
+};
+
+#define CCDC_MAX_RAW_BAYER_FORMATS	2
+#define CCDC_MAX_RAW_YUV_FORMATS	2
+
+/* Raw Bayer formats */
+enum vpfe_hw_pix_format ccdc_raw_bayer_hw_formats[CCDC_MAX_RAW_BAYER_FORMATS] =
+		{VPFE_BAYER_8BIT_PACK_ALAW, VPFE_BAYER};
+
+/* Raw YUV formats */
+enum vpfe_hw_pix_format ccdc_raw_yuv_hw_formats[CCDC_MAX_RAW_YUV_FORMATS] =
+		{VPFE_UYVY, VPFE_YUYV};
+
+static void *__iomem ccdc_base_addr;
+static int ccdc_addr_size;
+static void *__iomem vpss_base_addr;
+static int vpss_addr_size;
+static struct ccdc_config_params_raw ccdc_hw_params_raw_temp;
+static enum vpfe_hw_if_type ccdc_if_type;
+
+/* register access routines */
+static inline u32 regr(u32 offset)
+{
+	if (offset <= ccdc_addr_size)
+		return __raw_readl(ccdc_base_addr + offset);
+	else {
+		dev_err(dev, "offset exceeds ccdc register address space\n");
+		return -1;
+	}
+}
+
+static inline u32 regw(u32 val, u32 offset)
+{
+	if (offset <= ccdc_addr_size) {
+		__raw_writel(val, ccdc_base_addr + offset);
+		return val;
+	} else {
+		dev_err(dev, "offset exceeds ccdc register address space\n");
+		return -1;
+	}
+}
+
+/* register access routines */
+static inline u32 regr_sb(u32 offset)
+{
+	if (offset <= vpss_addr_size)
+		return __raw_readl(vpss_base_addr + offset);
+	else {
+		dev_err(dev, "offset exceeds vpss register address space\n");
+		return -1;
+	}
+}
+
+static inline u32 regw_sb(u32 val, u32 offset)
+{
+	if (offset <= vpss_addr_size) {
+		__raw_writel(val, vpss_base_addr + offset);
+		return val;
+	} else {
+		dev_err(dev, "offset exceeds vpss register address space\n");
+		return -1;
+	}
+}
+
+static void ccdc_set_ccdc_base(void *addr, int size)
+{
+	ccdc_base_addr = addr;
+	ccdc_addr_size = size;
+}
+
+static void ccdc_set_vpss_base(void *addr, int size)
+{
+	vpss_base_addr = addr;
+	vpss_addr_size = size;
+}
+
+static void *ccdc_get_ccdc_base(void)
+{
+	return (void *)ccdc_base_addr;
+}
+
+static void *ccdc_get_vpss_base(void)
+{
+	return (void *)vpss_base_addr;
+}
+
+static void ccdc_enable(int flag)
+{
+	regw(flag, PCR);
+}
+
+static void ccdc_enable_vport(int flag)
+{
+	if (flag)
+		/* enable video port */
+		regw(ENABLE_VIDEO_PORT, FMTCFG);
+	else
+		regw(DISABLE_VIDEO_PORT, FMTCFG);
+}
+
+/*
+ * ======== ccdc_setwin  ========
+ * This function will configure the window size
+ * to be capture in CCDC reg
+ */
+void ccdc_setwin(struct ccdc_imgwin *image_win,
+		enum ccdc_frmfmt frm_fmt,
+		int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int val = 0, mid_img = 0;
+	dev_dbg(dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	/* Here, (ppc-1) will be different for raw and yuv modes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = (image_win->width << (ppc - 1)) - 1;
+	regw((horz_start << CCDC_HORZ_INFO_SPH_SHIFT) | horz_nr_pixels,
+	     HORZ_INFO);
+
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		/* Since first line doesn't have any data */
+		vert_start += 1;
+		/* configure VDINT0 */
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT);
+		regw(val, VDINT);
+
+	} else {
+		/* Since first line doesn't have any data */
+		vert_start += 1;
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		/* VDINT1 will be at half of image height */
+		mid_img = vert_start + (image_win->height / 2);
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT) |
+		    (mid_img & CCDC_VDINT_VDINT1_MASK);
+		regw(val, VDINT);
+
+	}
+	regw((vert_start << CCDC_VERT_START_SLV0_SHIFT) | vert_start,
+	     VERT_START);
+	regw(vert_nr_lines, VERT_LINES);
+	dev_dbg(dev, "\nEnd of ccdc_setwin...");
+}
+
+static void ccdc_readregs(void)
+{
+	unsigned int val = 0;
+
+	val = regr(ALAW);
+	dev_notice(dev, "\nReading 0x%x to ALAW...\n", val);
+	val = regr(CLAMP);
+	dev_notice(dev, "\nReading 0x%x to CLAMP...\n", val);
+	val = regr(DCSUB);
+	dev_notice(dev, "\nReading 0x%x to DCSUB...\n", val);
+	val = regr(BLKCMP);
+	dev_notice(dev, "\nReading 0x%x to BLKCMP...\n", val);
+	val = regr(FPC_ADDR);
+	dev_notice(dev, "\nReading 0x%x to FPC_ADDR...\n", val);
+	val = regr(FPC);
+	dev_notice(dev, "\nReading 0x%x to FPC...\n", val);
+	val = regr(FMTCFG);
+	dev_notice(dev, "\nReading 0x%x to FMTCFG...\n", val);
+	val = regr(COLPTN);
+	dev_notice(dev, "\nReading 0x%x to COLPTN...\n", val);
+	val = regr(FMT_HORZ);
+	dev_notice(dev, "\nReading 0x%x to FMT_HORZ...\n", val);
+	val = regr(FMT_VERT);
+	dev_notice(dev, "\nReading 0x%x to FMT_VERT...\n", val);
+	val = regr(HSIZE_OFF);
+	dev_notice(dev, "\nReading 0x%x to HSIZE_OFF...\n", val);
+	val = regr(SDOFST);
+	dev_notice(dev, "\nReading 0x%x to SDOFST...\n", val);
+	val = regr(VP_OUT);
+	dev_notice(dev, "\nReading 0x%x to VP_OUT...\n", val);
+	val = regr(SYN_MODE);
+	dev_notice(dev, "\nReading 0x%x to SYN_MODE...\n", val);
+	val = regr(HORZ_INFO);
+	dev_notice(dev, "\nReading 0x%x to HORZ_INFO...\n", val);
+	val = regr(VERT_START);
+	dev_notice(dev, "\nReading 0x%x to VERT_START...\n", val);
+	val = regr(VERT_LINES);
+	dev_notice(dev, "\nReading 0x%x to VERT_LINES...\n", val);
+}
+
+static int validate_ccdc_param(struct ccdc_config_params_raw *ccdcparam)
+{
+	if ((ccdc_hw_params_raw.frm_fmt != CCDC_FRMFMT_INTERLACED)
+	    && (ccdcparam->image_invert_enable == 1)) {
+		dev_err(dev, "\nImage invert not supported");
+		return -1;
+	}
+	if (ccdc_hw_params_raw.alaw.b_alaw_enable) {
+		if ((ccdcparam->alaw.gama_wd > BITS_09_0)
+		    || (ccdcparam->alaw.gama_wd < BITS_15_6)
+		    || (ccdcparam->alaw.gama_wd < ccdcparam->data_sz)) {
+			dev_err(dev, "\nInvalid data line select");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int ccdc_update_ycbcr_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_ycbcr,
+	       (struct ccdc_params_ycbcr *)arg,
+	       sizeof(struct ccdc_params_ycbcr));
+	return 0;
+}
+
+static int ccdc_update_raw_params(void *arg)
+{
+	unsigned int *fpc_virtaddr = NULL;
+	unsigned int *fpc_physaddr = NULL;
+	struct ccdc_params_raw *ccd_params = &ccdc_hw_params_raw;
+	struct ccdc_config_params_raw *raw_params =
+			(struct ccdc_config_params_raw *) arg;
+	ccd_params->image_invert_enable = raw_params->image_invert_enable;
+
+	dev_dbg(dev, "\nimage_invert_enable = %d",
+	       ccd_params->image_invert_enable);
+
+	ccd_params->data_sz = raw_params->data_sz;
+	dev_dbg(dev, "\ndata_sz = %d", ccd_params->data_sz);
+
+	ccd_params->alaw.b_alaw_enable = raw_params->alaw.b_alaw_enable;
+	dev_dbg(dev, "\nALaw Enable = %d", ccd_params->alaw.b_alaw_enable);
+	/* copy A-Law configurations to vpfe_device, from arg
+	 * passed by application */
+	if (ccd_params->alaw.b_alaw_enable) {
+		ccd_params->alaw.gama_wd = raw_params->alaw.gama_wd;
+		dev_dbg(dev, "\nALaw Gama width = %d",
+		       ccd_params->alaw.gama_wd);
+	}
+
+	/* copy Optical Balck Clamping configurations to
+	 * vpfe_device,from arg passed by application */
+	ccd_params->blk_clamp.b_clamp_enable
+	    = raw_params->blk_clamp.b_clamp_enable;
+	dev_dbg(dev, "\nb_clamp_enable = %d",
+	       ccd_params->blk_clamp.b_clamp_enable);
+	if (ccd_params->blk_clamp.b_clamp_enable) {
+		/*gain */
+		ccd_params->blk_clamp.sgain = raw_params->blk_clamp.sgain;
+		dev_dbg(dev, "\nblk_clamp.sgain = %d",
+		       ccd_params->blk_clamp.sgain);
+		/*Start pixel */
+		ccd_params->blk_clamp.start_pixel
+		    = raw_params->blk_clamp.start_pixel;
+		dev_dbg(dev, "\nblk_clamp.start_pixel = %d",
+		       ccd_params->blk_clamp.start_pixel);
+		/*No of line to be avg */
+		ccd_params->blk_clamp.sample_ln
+		    = raw_params->blk_clamp.sample_ln;
+		dev_dbg(dev, "\nblk_clamp.sample_ln = %d",
+		       ccd_params->blk_clamp.sample_ln);
+		/*No of pixel/line to be avg */
+		ccd_params->blk_clamp.sample_pixel
+		    = raw_params->blk_clamp.sample_pixel;
+		dev_dbg(dev, "\nblk_clamp.sample_pixel  = %d",
+		       ccd_params->blk_clamp.sample_pixel);
+	} else {		/* configure DCSub */
+
+		ccd_params->blk_clamp.dc_sub = raw_params->blk_clamp.dc_sub;
+		dev_dbg(dev, "\nblk_clamp.dc_sub  = %d",
+		       ccd_params->blk_clamp.dc_sub);
+	}
+
+	/* copy BalckLevel Compansation configurations to
+	 * vpfe_device,from arg passed by application
+	 */
+	ccd_params->blk_comp.r_comp = raw_params->blk_comp.r_comp;
+	ccd_params->blk_comp.gr_comp = raw_params->blk_comp.gr_comp;
+	ccd_params->blk_comp.b_comp = raw_params->blk_comp.b_comp;
+	ccd_params->blk_comp.gb_comp = raw_params->blk_comp.gb_comp;
+	dev_dbg(dev, "\nblk_comp.r_comp   = %d",
+	       ccd_params->blk_comp.r_comp);
+	dev_dbg(dev, "\nblk_comp.gr_comp  = %d",
+	       ccd_params->blk_comp.gr_comp);
+	dev_dbg(dev, "\nblk_comp.b_comp   = %d",
+	       ccd_params->blk_comp.b_comp);
+	dev_dbg(dev, "\nblk_comp.gb_comp  = %d",
+	       ccd_params->blk_comp.gb_comp);
+
+	/* copy FPC configurations to vpfe_device,from
+	 * arg passed by application
+	 */
+	ccd_params->fault_pxl.fpc_enable = raw_params->fault_pxl.fpc_enable;
+	dev_dbg(dev, "\nfault_pxl.fpc_enable  = %d",
+	       ccd_params->fault_pxl.fpc_enable);
+
+	if (ccd_params->fault_pxl.fpc_enable) {
+		fpc_physaddr =
+		    (unsigned int *)ccd_params->fault_pxl.fpc_table_addr;
+
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)
+				 fpc_physaddr);
+
+		/* Allocate memory for FPC table if current
+		 * FPC table buffer is not big enough to
+		 * accomodate FPC Number requested
+		 */
+		if (raw_params->fault_pxl.fp_num !=
+		    ccd_params->fault_pxl.fp_num) {
+			if (fpc_physaddr != NULL) {
+				free_pages((unsigned long)
+					   fpc_physaddr,
+					   get_order
+					   (ccd_params->
+					    fault_pxl.fp_num * FP_NUM_BYTES));
+
+			}
+
+			/* Allocate memory for FPC table */
+			fpc_virtaddr = (unsigned int *)
+			    __get_free_pages(GFP_KERNEL |
+					     GFP_DMA,
+					     get_order
+					     (raw_params->
+					      fault_pxl.fp_num * FP_NUM_BYTES));
+
+			if (fpc_virtaddr == NULL) {
+				dev_err(dev,
+					"\nUnable to allocate memory for FPC");
+				return -1;
+			}
+			fpc_physaddr =
+			    (unsigned int *)virt_to_phys((void *)fpc_virtaddr);
+		}
+
+		/* Copy number of fault pixels and FPC table */
+		ccd_params->fault_pxl.fp_num = raw_params->fault_pxl.fp_num;
+		if (copy_from_user((void *)fpc_virtaddr,
+			       (void *)raw_params->
+			       fault_pxl.fpc_table_addr,
+			       (unsigned long)ccd_params->
+			       fault_pxl.fp_num * FP_NUM_BYTES)) {
+				dev_err(dev, "\n copy_from_user failed");
+				return -1;
+		}
+
+		ccd_params->fault_pxl.fpc_table_addr =
+		    (unsigned int)fpc_physaddr;
+	}
+	return 0;
+}
+
+static int ccdc_close(struct device *dev)
+{
+	unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
+	fpc_physaddr = (unsigned int *)
+	    ccdc_hw_params_raw.fault_pxl.fpc_table_addr;
+
+	if (fpc_physaddr != NULL) {
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)fpc_physaddr);
+		free_pages((unsigned long)fpc_virtaddr,
+			   get_order(ccdc_hw_params_raw.fault_pxl.
+				     fp_num * FP_NUM_BYTES));
+	}
+	return 0;
+}
+
+/*
+ * ======== ccdc_reset  ========
+ *
+ * This function will reset all CCDc reg
+ */
+static void ccdc_reset(void)
+{
+	int i;
+
+	/* disable CCDC */
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x94; i += 4)
+		regw(0,  i);
+	regw(0, PCR);
+	regw(0, SYN_MODE);
+	regw(0, HD_VD_WID);
+	regw(0, PIX_LINES);
+	regw(0, HORZ_INFO);
+	regw(0, VERT_START);
+	regw(0, VERT_LINES);
+	regw(0xffff00ff, CULLING);
+	regw(0, HSIZE_OFF);
+	regw(0, SDOFST);
+	regw(0, SDR_ADDR);
+	regw(0, VDINT);
+	regw(0, REC656IF);
+	regw(0, CCDCFG);
+	regw(0, FMTCFG);
+	regw(0, VP_OUT);
+}
+
+static int ccdc_open(struct device *device)
+{
+	dev = device;
+	ccdc_reset();
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		ccdc_enable_vport(1);
+	return 0;
+}
+
+static u32 ccdc_sbl_reset(void)
+{
+	u32 sb_reset;
+	sb_reset = regr_sb(SBL_PCR_VPSS);
+	regw_sb((sb_reset & SBL_PCR_CCDC_WBL_O), SBL_PCR_VPSS);
+	return sb_reset;
+}
+
+/* Parameter operations */
+static int ccdc_setparams(void *params)
+{
+	int x;
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		x = copy_from_user(&ccdc_hw_params_raw_temp,
+				   (struct ccdc_config_params_raw *)params,
+				   sizeof(struct ccdc_config_params_raw));
+		if (x) {
+			dev_err(dev, "ccdc_setparams: error in copying"
+				   "ccdc params, %d\n", x);
+			return -1;
+		}
+
+		if (!validate_ccdc_param(&ccdc_hw_params_raw_temp)) {
+			if (!ccdc_update_raw_params(&ccdc_hw_params_raw_temp))
+				return 0;
+		}
+	} else
+		return ccdc_update_ycbcr_params(params);
+	return -1;
+}
+
+/*
+ * ======== ccdc_config_ycbcr  ========
+ * This function will configure CCDC for YCbCr parameters
+ */
+void ccdc_config_ycbcr(void)
+{
+	u32 syn_mode;
+	unsigned int val;
+	struct ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(dev, "\nStarting ccdc_config_ycbcr...");
+	ccdc_reset();
+
+	/* configure pixel format */
+	syn_mode = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	syn_mode |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		syn_mode |= 0x00000F04;
+	} else {
+		/* y/c external sync mode */
+		syn_mode |= ((params->fid_pol & 0x1) << 4);
+		syn_mode |= ((params->hd_pol & 0x1) << 3);
+		syn_mode |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8000, CCDCFG);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((params->win.width * 2) + 31) & 0xffffffe0, HSIZE_OFF);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+	/* enable output to SDRAM */
+	syn_mode |= (0x1 << 17);
+	/* enable internal timing generator */
+	syn_mode |= (0x1 << 16);
+
+	syn_mode |= CCDC_DATA_PACK_ENABLE;
+	regw(syn_mode, SYN_MODE);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(dev, "\nReading 0x%x from SBL...\n", val);
+	dev_dbg(dev, "\nEnd of ccdc_config_ycbcr...\n");
+	ccdc_readregs();
+}
+
+/*
+ * ======== ccdc_config_raw  ========
+ *
+ * This function will configure CCDC for Raw mode parameters
+ */
+void ccdc_config_raw(void)
+{
+	struct ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int syn_mode = 0;
+	unsigned int val;
+	dev_dbg(dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	ccdc_reset();
+	/* Disable latching function registers on VSYNC  */
+	regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG);
+
+	/*      Configure the vertical sync polarity(SYN_MODE.VDPOL) */
+	syn_mode = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (SYN_MODE.HDPOL) */
+	syn_mode |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (SYN_MODE.FLDPOL) */
+	syn_mode |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	syn_mode |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure the data size(SYNMODE.DATSIZ) */
+	syn_mode |= (params->data_sz & CCDC_DATA_SZ_MASK) << CCDC_DATA_SZ_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	syn_mode |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	/* Configure VP2SDR bit of syn_mode = 0 */
+	syn_mode &= CCDC_VP2SDR_DISABLE;
+
+	/* Enable write enable bit */
+	syn_mode |= CCDC_WEN_ENABLE;
+
+	/* Disable output to resizer */
+	syn_mode &= CCDC_SDR2RSZ_DISABLE;
+
+	/* enable internal timing generator */
+	syn_mode |= CCDC_VDHDEN_ENABLE;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val = (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK);
+		/*set enable bit of alaw */
+		val |= CCDC_ALAW_ENABLE;
+		regw(val, ALAW);
+
+		dev_dbg(dev, "\nWriting 0x%x to ALAW...\n", val);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, PPC_RAW);
+
+	if (params->blk_clamp.b_clamp_enable) {
+		/*gain */
+		val = (params->blk_clamp.sgain) & CCDC_BLK_SGAIN_MASK;
+		/*Start pixel */
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK)
+		    << CCDC_BLK_ST_PXL_SHIFT;
+		/*No of line to be avg */
+		val |= (params->blk_clamp.sample_ln & CCDC_BLK_SAMPLE_LINE_MASK)
+		    << CCDC_BLK_SAMPLE_LINE_SHIFT;
+		/*No of pixel/line to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;
+		/*Enable the Black clamping */
+		val |= CCDC_BLK_CLAMP_ENABLE;
+		regw(val, CLAMP);
+
+		dev_dbg(dev, "\nWriting 0x%x to CLAMP...\n", val);
+		/*If Black clamping is enable then make dcsub 0 */
+		regw(DCSUB_DEFAULT_VAL, DCSUB);
+		dev_dbg(dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		regw(val, DCSUB);
+
+		dev_dbg(dev, "\nWriting 0x%x to DCSUB...\n", val);
+		regw(CLAMP_DEFAULT_VAL, CLAMP);
+
+		dev_dbg(dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*      Configure Black level compensation */
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	val |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+
+	regw(val, BLKCMP);
+
+	dev_dbg(dev, "\nWriting 0x%x to BLKCMP...\n", val);
+	dev_dbg(dev, "\nbelow 	regw(val, BLKCMP)...");
+	/* Initially disable FPC */
+	val = CCDC_FPC_DISABLE;
+	regw(val, FPC);
+	/* Configure Fault pixel if needed */
+	if (params->fault_pxl.fpc_enable) {
+		regw(params->fault_pxl.fpc_table_addr, FPC_ADDR);
+
+		dev_dbg(dev, "\nWriting 0x%x to FPC_ADDR...\n",
+		       (params->fault_pxl.fpc_table_addr));
+		/* Write the FPC params with FPC disable */
+		val = params->fault_pxl.fp_num & CCDC_FPC_FPC_NUM_MASK;
+		regw(val, FPC);
+
+		dev_dbg(dev, "\nWriting 0x%x to FPC...\n", val);
+		/* read the FPC register */
+		val = regr(FPC);
+		val |= CCDC_FPC_ENABLE;
+		regw(val, FPC);
+
+		dev_dbg(dev, "\nWriting 0x%x to FPC...\n", val);
+	}
+	/* If data size is 8 bit then pack the data */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable)
+		syn_mode |= CCDC_DATA_PACK_ENABLE;
+#if VIDEO_PORT_ENABLE
+	/* enable video port */
+	val = ENABLE_VIDEO_PORT;
+#else
+	/* disable video port */
+	val = DISABLE_VIDEO_PORT;
+#endif
+
+	if (params->data_sz == _8BITS)
+		val |= (_10BITS & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+	else
+		val |= (params->data_sz & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+
+	/* Write value in FMTCFG */
+	regw(val, FMTCFG);
+
+	dev_dbg(dev, "\nWriting 0x%x to FMTCFG...\n", val);
+
+	/* Configure the color pattern according to mt9t001 sensor */
+	regw(CCDC_COLPTN_VAL, COLPTN);
+
+	dev_dbg(dev, "\nWriting 0xBB11BB11 to COLPTN...\n");
+	/* Configure Data formatter(Video port) pixel selection
+	 * (FMT_HORZ, FMT_VERT)
+	 */
+	val = 0;
+	val |= ((params->win.left) & CCDC_FMT_HORZ_FMTSPH_MASK)
+	    << CCDC_FMT_HORZ_FMTSPH_SHIFT;
+	val |= (((params->win.width)) & CCDC_FMT_HORZ_FMTLNH_MASK);
+	regw(val, FMT_HORZ);
+
+	dev_dbg(dev, "\nWriting 0x%x to FMT_HORZ...\n", val);
+	val = 0;
+	val |= (params->win.top & CCDC_FMT_VERT_FMTSLV_MASK)
+	    << CCDC_FMT_VERT_FMTSLV_SHIFT;
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
+		val |= (params->win.height) & CCDC_FMT_VERT_FMTLNV_MASK;
+	else
+		val |= (params->win.height >> 1) & CCDC_FMT_VERT_FMTLNV_MASK;
+
+	dev_dbg(dev, "\nparams->win.height  0x%x ...\n",
+	       params->win.height);
+	regw(val, FMT_VERT);
+
+	dev_dbg(dev, "\nWriting 0x%x to FMT_VERT...\n", val);
+
+	dev_dbg(dev, "\nbelow regw(val, FMT_VERT)...");
+
+	/* Configure Horizontal offset register */
+	/* If pack 8 is enabled then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable)
+		regw(((params->win.width) + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	else
+		/* else one pixel will take 2 byte */
+		regw(((params->win.width * TWO_BYTES_PER_PIXEL)
+		      + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	/* Set value for SDOFST */
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For intelace inverse mode */
+			regw(INTERLACED_IMAGE_INVERT, SDOFST);
+			dev_dbg(dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For intelace non inverse mode */
+			regw(INTERLACED_NO_IMAGE_INVERT, SDOFST);
+			dev_dbg(dev, "\nWriting 0x0249 to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		regw(PROGRESSIVE_NO_IMAGE_INVERT, SDOFST);
+		dev_dbg(dev, "\nWriting 0x0000 to SDOFST...\n");
+	}
+
+	/* Configure video port pixel selection (VPOUT) */
+	/* Here -1 is to make the height value less than FMT_VERT.FMTLNV */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
+		val = (((params->win.height - 1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+	else
+		val =
+		    ((((params->win.
+			height >> CCDC_INTERLACED_HEIGHT_SHIFT) -
+		       1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+
+	val |= ((((params->win.width))) & CCDC_VP_OUT_HORZ_NUM_MASK)
+	    << CCDC_VP_OUT_HORZ_NUM_SHIFT;
+	val |= (params->win.left) & CCDC_VP_OUT_HORZ_ST_MASK;
+	regw(val, VP_OUT);
+
+	dev_dbg(dev, "\nWriting 0x%x to VP_OUT...\n", val);
+	regw(syn_mode, SYN_MODE);
+	dev_dbg(dev, "\nWriting 0x%x to SYN_MODE...\n", syn_mode);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(dev, "\nReading 0x%x from SBL...\n", val);
+
+	dev_dbg(dev, "\nend of ccdc_config_raw...");
+	ccdc_readregs();
+}
+
+static int ccdc_configure(void)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		dev_info(dev, "calling ccdc_config_raw()\n");
+		ccdc_config_raw();
+	} else {
+		dev_info(dev, "calling ccdc_config_ycbcr()\n");
+		ccdc_config_ycbcr();
+	}
+	return 0;
+}
+
+static int ccdc_set_buftype(enum ccdc_buftype buf_type)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		ccdc_hw_params_raw.buf_type = buf_type;
+	else
+		ccdc_hw_params_ycbcr.buf_type = buf_type;
+	return 0;
+}
+
+static int ccdc_get_buftype(enum ccdc_buftype *buf_type)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		*buf_type = ccdc_hw_params_raw.buf_type;
+	else
+		*buf_type = ccdc_hw_params_ycbcr.buf_type;
+	return 0;
+}
+
+static int ccdc_enum_pix(enum vpfe_hw_pix_format *hw_pix, int i)
+{
+	int ret = -EINVAL;
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		if (i < CCDC_MAX_RAW_BAYER_FORMATS) {
+			*hw_pix = ccdc_raw_bayer_hw_formats[i];
+			ret = 0;
+		}
+	} else {
+		if (i < CCDC_MAX_RAW_YUV_FORMATS) {
+			*hw_pix = ccdc_raw_yuv_hw_formats[i];
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int ccdc_set_pixel_format(enum vpfe_hw_pix_format pixfmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		ccdc_hw_params_raw.pix_fmt = CCDC_PIXFMT_RAW;
+		if (pixfmt == VPFE_BAYER_8BIT_PACK_ALAW)
+			ccdc_hw_params_raw.alaw.b_alaw_enable = 1;
+		else if (pixfmt != VPFE_BAYER)
+			return -1;
+	} else {
+		if (pixfmt == VPFE_YUYV)
+			ccdc_hw_params_ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;
+		else if (pixfmt == VPFE_UYVY)
+			ccdc_hw_params_ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;
+		else
+			return -1;
+	}
+	return 0;
+}
+
+static int ccdc_get_pixel_format(enum vpfe_hw_pix_format *pixfmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		if (ccdc_hw_params_raw.alaw.b_alaw_enable)
+			*pixfmt = VPFE_BAYER_8BIT_PACK_ALAW;
+		else
+			*pixfmt = VPFE_BAYER;
+	else {
+		if (ccdc_hw_params_ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)
+			*pixfmt = VPFE_YUYV;
+		else
+			*pixfmt = VPFE_UYVY;
+	}
+	return 0;
+}
+
+static int ccdc_set_image_window(struct v4l2_rect *win)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		ccdc_hw_params_raw.win.top = win->top;
+		ccdc_hw_params_raw.win.left = win->left;
+		ccdc_hw_params_raw.win.width = win->width;
+		ccdc_hw_params_raw.win.height = win->height;
+	} else {
+		ccdc_hw_params_ycbcr.win.top = win->top;
+		ccdc_hw_params_ycbcr.win.left = win->left;
+		ccdc_hw_params_ycbcr.win.width = win->width;
+		ccdc_hw_params_ycbcr.win.height = win->height;
+	}
+	return 0;
+}
+
+static int ccdc_get_image_window(struct v4l2_rect *win)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		win->top = ccdc_hw_params_raw.win.top;
+		win->left = ccdc_hw_params_raw.win.left;
+		win->width = ccdc_hw_params_raw.win.width;
+		win->height = ccdc_hw_params_raw.win.height;
+	} else {
+		win->top = ccdc_hw_params_ycbcr.win.top;
+		win->left = ccdc_hw_params_ycbcr.win.left;
+		win->width = ccdc_hw_params_ycbcr.win.width;
+		win->height = ccdc_hw_params_ycbcr.win.height;
+	}
+	return 0;
+}
+
+static int ccdc_get_line_length(unsigned int *len)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		if ((ccdc_hw_params_raw.alaw.b_alaw_enable) ||
+		    (ccdc_hw_params_raw.data_sz == _8BITS))
+			*len = ccdc_hw_params_raw.win.width;
+		else
+			*len = ccdc_hw_params_raw.win.width * 2;
+	} else
+		*len = ccdc_hw_params_ycbcr.win.width * 2;
+	return 0;
+}
+
+static int ccdc_set_frame_format(enum ccdc_frmfmt frm_fmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		ccdc_hw_params_raw.frm_fmt = frm_fmt;
+	else
+		ccdc_hw_params_ycbcr.frm_fmt = frm_fmt;
+	return 0;
+}
+
+static int ccdc_get_frame_format(enum ccdc_frmfmt *frm_fmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		*frm_fmt = ccdc_hw_params_raw.frm_fmt;
+	else
+		*frm_fmt = ccdc_hw_params_ycbcr.frm_fmt;
+	return 0;
+}
+
+static int ccdc_getfid(void)
+{
+	int fid = (regr(SYN_MODE) >> 15) & 0x1;
+	return fid;
+}
+
+/* misc operations */
+static inline void ccdc_setfbaddr(unsigned long addr)
+{
+	regw(addr & 0xffffffe0, SDR_ADDR);
+}
+
+static int ccdc_set_hw_if_type(enum vpfe_hw_if_type iface)
+{
+	ccdc_if_type = iface;
+	return 0;
+}
+
+struct ccdc_hw_device ccdc_hw_dev = {
+	.name = "DM6446 CCDC",
+	.set_ccdc_base = ccdc_set_ccdc_base,
+	.set_vpss_base = ccdc_set_vpss_base,
+	.get_ccdc_base = ccdc_get_ccdc_base,
+	.get_vpss_base = ccdc_get_vpss_base,
+	.open = ccdc_open,
+	.reset = ccdc_sbl_reset,
+	.enable = ccdc_enable,
+	.set_hw_if_type = ccdc_set_hw_if_type,
+	.setparams = ccdc_setparams,
+	.configure = ccdc_configure,
+	.set_buftype = ccdc_set_buftype,
+	.get_buftype = ccdc_get_buftype,
+	.enum_pix = ccdc_enum_pix,
+	.set_pixelformat = ccdc_set_pixel_format,
+	.get_pixelformat = ccdc_get_pixel_format,
+	.set_frame_format = ccdc_set_frame_format,
+	.get_frame_format = ccdc_get_frame_format,
+	.set_image_window = ccdc_set_image_window,
+	.get_image_window = ccdc_get_image_window,
+	.get_line_length = ccdc_get_line_length,
+	.setfbaddr = ccdc_setfbaddr,
+	.getfid = ccdc_getfid,
+	.close = ccdc_close
+};
+EXPORT_SYMBOL(ccdc_hw_dev);
+
+static int davinci_ccdc_init(void)
+{
+	return 0;
+}
+
+static void davinci_ccdc_exit(void)
+{
+}
+
+subsys_initcall(davinci_ccdc_init);
+module_exit(davinci_ccdc_exit);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/media/video/davinci/ccdc_davinci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/ccdc_davinci.h	2009-11-20 10:07:18.490416588 -0600
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2006-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CCDC_DAVINCI_H
+#define _CCDC_DAVINCI_H
+#include <media/davinci/ccdc_common.h>
+
+/* enum for No of pixel per line to be avg. in Black Clamping*/
+enum sample_length {
+	_1PIXELS = 0,
+	_2PIXELS,
+	_4PIXELS,
+	_8PIXELS,
+	_16PIXELS
+};
+
+/* Define to enable/disable video port */
+#define VIDEO_PORT_ENABLE	(1)
+#define FP_NUM_BYTES		(4)
+/* Define for extra pixel/line and extra lines/frame */
+#define NUM_EXTRAPIXELS		8
+#define NUM_EXTRALINES		8
+
+/* settings for commonly used video formats */
+#define CCDC_WIN_PAL     {0, 0, 720, 576}
+/* ntsc square pixel */
+#define CCDC_WIN_VGA	{0, 0, (640 + NUM_EXTRAPIXELS), (480 + NUM_EXTRALINES)}
+
+/* enum for No of lines in Black Clamping */
+enum sample_line {
+	_1LINES = 0,
+	_2LINES,
+	_4LINES,
+	_8LINES,
+	_16LINES
+};
+
+/* enum for Alaw gama width */
+enum gama_width {
+	BITS_15_6 = 0,
+	BITS_14_5,
+	BITS_13_4,
+	BITS_12_3,
+	BITS_11_2,
+	BITS_10_1,
+	BITS_09_0
+};
+
+enum data_size {
+	_16BITS = 0,
+	_15BITS,
+	_14BITS,
+	_13BITS,
+	_12BITS,
+	_11BITS,
+	_10BITS,
+	_8BITS
+};
+
+struct ccdc_imgwin {
+	unsigned int top;
+	unsigned int left;
+	unsigned int width;
+	unsigned int height;
+};
+
+/* structure for ALaw */
+struct a_law {
+	/* Enable/disable A-Law */
+	unsigned char b_alaw_enable;
+	/*Gama Width Input */
+	enum gama_width gama_wd;
+};
+
+/* structure for Black Clamping */
+struct black_clamp {
+	unsigned char b_clamp_enable;
+	/* only if bClampEnable is TRUE */
+	enum sample_length sample_pixel;
+	/* only if bClampEnable is TRUE */
+	enum sample_line sample_ln;
+	/* only if bClampEnable is TRUE */
+	unsigned short start_pixel;
+	/* only if bClampEnable is TRUE */
+	unsigned short sgain;
+	/* only if bClampEnable is FALSE */
+	unsigned short dc_sub;
+};
+
+/* structure for Black Level Compensation */
+struct black_compensation {
+	/* Constant value to subtract from Red component */
+	char r_comp;
+	/* Constant value to subtract from Gr component */
+	char gr_comp;
+	/* Constant value to subtract from Blue component */
+	char b_comp;
+	/* Constant value to subtract from Gb component */
+	char gb_comp;
+};
+
+/* structure for fault pixel correction */
+struct fault_pixel {
+	/*Enable or Disable fault pixel correction */
+	unsigned char fpc_enable;
+	/*Number of fault pixel */
+	unsigned short fp_num;
+	/*Address of fault pixel table */
+	unsigned int fpc_table_addr;
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode passed
+ * by application
+ */
+struct ccdc_config_params_raw {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* enable to store the image in inverse order in
+	 * memory(bottom to top)
+	 */
+	unsigned char image_invert_enable;
+	/* data size value from 8 to 16 bits */
+	enum data_size data_sz;
+	/* Structure for Optional A-Law */
+	struct a_law alaw;
+	/* Structure for Optical Black Clamp */
+	struct black_clamp blk_clamp;
+	/* Structure for Black Compensation */
+	struct black_compensation blk_comp;
+	/* Structure for Fault Pixel Module Configuration */
+	struct fault_pixel fault_pxl;
+};
+
+struct ccdc_params_ycbcr {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* enable BT.656 embedded sync mode */
+	int bt656_enable;
+	/* cb:y:cr:y or y:cb:y:cr in memory */
+	enum ccdc_pixorder pix_order;
+	/* interleaved or separated fields  */
+	enum ccdc_buftype buf_type;
+};
+
+#ifdef __KERNEL__
+#include <linux/io.h>
+/* Structure for CCDC configuration parameters for raw capture mode */
+struct ccdc_params_raw {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* interleaved or separated fields */
+	enum ccdc_buftype buf_type;
+	/* enable to store the image in inverse
+	 * order in memory(bottom to top)
+	 */
+	unsigned char image_invert_enable;
+	/* data size value from 8 to 16 bits */
+	enum data_size data_sz;
+	/* Structure for Optional A-Law */
+	struct a_law alaw;
+	/* Structure for Optical Black Clamp */
+	struct black_clamp blk_clamp;
+	/* Structure for Black Compensation */
+	struct black_compensation blk_comp;
+	/* Structure for Fault Pixel Module Configuration */
+	struct fault_pixel fault_pxl;
+};
+
+/**************************************************************************\
+* Register OFFSET Definitions
+\**************************************************************************/
+
+#define PID                             0x0
+#define PCR                             0x4
+#define SYN_MODE                        0x8
+#define HD_VD_WID                       0xc
+#define PIX_LINES                       0x10
+#define HORZ_INFO                       0x14
+#define VERT_START                      0x18
+#define VERT_LINES                      0x1c
+#define CULLING                         0x20
+#define HSIZE_OFF                       0x24
+#define SDOFST                          0x28
+#define SDR_ADDR                        0x2c
+#define CLAMP                           0x30
+#define DCSUB                           0x34
+#define COLPTN                          0x38
+#define BLKCMP                          0x3c
+#define FPC                             0x40
+#define FPC_ADDR                        0x44
+#define VDINT                           0x48
+#define ALAW                            0x4c
+#define REC656IF                        0x50
+#define CCDCFG                          0x54
+#define FMTCFG                          0x58
+#define FMT_HORZ                        0x5c
+#define FMT_VERT                        0x60
+#define FMT_ADDR0                       0x64
+#define FMT_ADDR1                       0x68
+#define FMT_ADDR2                       0x6c
+#define FMT_ADDR3                       0x70
+#define FMT_ADDR4                       0x74
+#define FMT_ADDR5                       0x78
+#define FMT_ADDR6                       0x7c
+#define FMT_ADDR7                       0x80
+#define PRGEVEN_0                       0x84
+#define PRGEVEN_1                       0x88
+#define PRGODD_0                        0x8c
+#define PRGODD_1                        0x90
+#define VP_OUT                          0x94
+
+
+/***************************************************************
+*	Define for various register bit mask and shifts for CCDC
+****************************************************************/
+#define CCDC_FID_POL_MASK			(0x01)
+#define CCDC_FID_POL_SHIFT			(4)
+#define CCDC_HD_POL_MASK			(0x01)
+#define CCDC_HD_POL_SHIFT			(3)
+#define CCDC_VD_POL_MASK			(0x01)
+#define CCDC_VD_POL_SHIFT			(2)
+#define CCDC_HSIZE_OFF_MASK			(0xffffffe0)
+#define CCDC_32BYTE_ALIGN_VAL			(31)
+#define CCDC_FRM_FMT_MASK			(0x01)
+#define CCDC_FRM_FMT_SHIFT			(7)
+#define CCDC_DATA_SZ_MASK			(0x07)
+#define CCDC_DATA_SZ_SHIFT			(8)
+#define CCDC_PIX_FMT_MASK			(0x03)
+#define CCDC_PIX_FMT_SHIFT			(12)
+#define CCDC_VP2SDR_DISABLE			(0xFFFBFFFF)
+#define CCDC_WEN_ENABLE				(0x01 << 17)
+#define CCDC_SDR2RSZ_DISABLE			(0xFFF7FFFF)
+#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
+#define CCDC_LPF_ENABLE				(0x01 << 14)
+#define CCDC_ALAW_ENABLE			(0x01 << 3)
+#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
+#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 31)
+#define CCDC_BLK_SGAIN_MASK			(0x1F)
+#define CCDC_BLK_ST_PXL_MASK			(0x7FFF)
+#define CCDC_BLK_ST_PXL_SHIFT			(10)
+#define CCDC_BLK_SAMPLE_LN_MASK			(0x07)
+#define CCDC_BLK_SAMPLE_LN_SHIFT		(28)
+#define CCDC_BLK_SAMPLE_LINE_MASK		(0x07)
+#define CCDC_BLK_SAMPLE_LINE_SHIFT		(25)
+#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
+#define CCDC_BLK_COMP_MASK			(0x000000FF)
+#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
+#define CCDC_BLK_COMP_GR_COMP_SHIFT		(16)
+#define CCDC_BLK_COMP_R_COMP_SHIFT		(24)
+#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
+#define CCDC_FPC_ENABLE				(0x01 << 15)
+#define CCDC_FPC_DISABLE			(0x0)
+#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
+#define CCDC_DATA_PACK_ENABLE			(0x01<<11)
+#define CCDC_FMTCFG_VPIN_MASK			(0x07)
+#define CCDC_FMTCFG_VPIN_SHIFT			(12)
+#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16)
+#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16)
+#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
+#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
+#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
+#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
+#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
+#define CCDC_HORZ_INFO_SPH_SHIFT		(16)
+#define CCDC_VERT_START_SLV0_SHIFT		(16)
+#define CCDC_VDINT_VDINT0_SHIFT			(16)
+#define CCDC_VDINT_VDINT1_MASK			(0xFFFF)
+
+/* SBL register and mask defination */
+#define SBL_PCR_VPSS				(4)
+#define SBL_PCR_CCDC_WBL_O			(0xFF7FFFFF)
+
+#define PPC_RAW					(1)
+#define DCSUB_DEFAULT_VAL			(0)
+#define CLAMP_DEFAULT_VAL			(0)
+#define ENABLE_VIDEO_PORT			(0x00008000)
+#define DISABLE_VIDEO_PORT			(0)
+#define CCDC_COLPTN_VAL				(0xBB11BB11)
+#define TWO_BYTES_PER_PIXEL			(2)
+#define INTERLACED_IMAGE_INVERT			(0x4B6D)
+#define INTERLACED_NO_IMAGE_INVERT		(0x0249)
+#define PROGRESSIVE_IMAGE_INVERT		(0x4000)
+#define PROGRESSIVE_NO_IMAGE_INVERT		(0)
+#define CCDC_INTERLACED_HEIGHT_SHIFT		(1)
+
+#endif
+#endif				/* CCDC_DAVINCI_H */
Index: linux-2.6.29/drivers/media/video/davinci/ccdc_dm355.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/ccdc_dm355.c	2009-11-20 10:08:11.613848534 -0600
@@ -0,0 +1,1772 @@
+/*
+ * Copyright (C) 2005-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <asm/page.h>
+#include <media/davinci/ccdc_hw_device.h>
+#include "ccdc_dm355.h"
+
+static struct device *dev;
+
+/*Object for CCDC raw mode */
+static struct ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	/*This numbers are for the mt9v113 VGA YCbCr mode. */
+	.win = {0,0,1280,480},
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = 0,
+	.data_sz = _8BITS,
+	.med_filt_thres = 0,
+	.mfilt1 = NO_MEDIAN_FILTER1,
+	.mfilt2 = NO_MEDIAN_FILTER2,
+	.ccdc_offset = 0,
+	.gain = {
+		.r_ye = 256,
+		.gb_g = 256,
+		.gr_cy = 256,
+		.b_mg = 256
+	},
+	.lpf_enable = 0,
+	.datasft = 6, /*for EVM it should be 4 */
+	.alaw = {
+		.b_alaw_enable = 0,
+		.gama_wd = 2
+	},
+	.blk_clamp = {
+		.b_clamp_enable = 0,
+		.sample_pixel = 1,
+		.start_pixel = 0,
+		.dc_sub = 25
+	},
+	.blk_comp = {
+		.b_comp = 0,
+		.gb_comp = 0,
+		.gr_comp = 0,
+		.r_comp = 0
+	},
+	.vertical_dft = {
+		.ver_dft_en = 0
+	},
+	.lens_sh_corr = {
+		.lsc_enable = 0
+	},
+	.data_formatter_r = {
+		.fmt_enable = 0
+	},
+	.color_space_con = {
+		.csc_enable = 0
+	},
+	.col_pat_field0 = {
+		.olop = CCDC_GREEN_BLUE,
+		.olep = CCDC_BLUE,
+		.elop = CCDC_RED,
+		.elep = CCDC_GREEN_RED
+	},
+	.col_pat_field1 = {
+		.olop = CCDC_GREEN_BLUE,
+		.olep = CCDC_BLUE,
+		.elop = CCDC_RED,
+		.elep = CCDC_GREEN_RED
+	}
+};
+
+
+/*Object for CCDC ycbcr mode */
+static struct ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.win = CCDC_WIN_PAL,
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED, 
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = 1, 
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_SEPARATED 
+};
+
+static struct v4l2_queryctrl ccdc_control_info[CCDC_MAX_CONTROLS] = {
+	{
+		.id = CCDC_CID_R_GAIN,
+		.name = "R/Ye WB Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.minimum = 0,
+		.maximum = 2047,
+		.step = 1,
+		.default_value = 256
+	},
+	{
+		.id = CCDC_CID_GR_GAIN,
+		.name = "Gr/Cy WB Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.minimum = 0,
+		.maximum = 2047,
+		.step = 1,
+		.default_value = 256
+	},
+	{
+		.id = CCDC_CID_GB_GAIN,
+		.name = "Gb/G WB Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.minimum = 0,
+		.maximum = 2047,
+		.step = 1,
+		.default_value = 256
+	},
+	{
+		.id = CCDC_CID_B_GAIN,
+		.name = "B/Mg WB Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.minimum = 0,
+		.maximum = 2047,
+		.step = 1,
+		.default_value = 256
+	},
+	{
+		.id = CCDC_CID_OFFSET,
+		.name = "Offset",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.minimum = 0,
+		.maximum = 1023,
+		.step = 1,
+		.default_value = 0
+	}
+};
+
+static struct ccdc_config_params_raw ccdc_hw_params_raw_temp;
+static enum vpfe_hw_if_type ccdc_if_type;
+static void *__iomem ccdc_base_addr;
+static int ccdc_addr_size;
+static void *__iomem vpss_base_addr;
+static int vpss_addr_size;
+
+#define CCDC_MAX_RAW_BAYER_FORMATS	2
+#define CCDC_MAX_RAW_YUV_FORMATS	2
+
+/* Raw Bayer formats */
+enum vpfe_hw_pix_format ccdc_raw_bayer_hw_formats[CCDC_MAX_RAW_BAYER_FORMATS] =
+		{VPFE_BAYER_8BIT_PACK_ALAW, VPFE_BAYER};
+
+/* Raw YUV formats */
+enum vpfe_hw_pix_format ccdc_raw_yuv_hw_formats[CCDC_MAX_RAW_YUV_FORMATS] =
+		{VPFE_UYVY, VPFE_YUYV};
+
+/* register access routines */
+static inline u32 regr(u32 offset)
+{
+	if (offset <= ccdc_addr_size)
+		return __raw_readl(ccdc_base_addr + offset);
+	else {
+		dev_err(dev, "offset exceeds ccdc register address space\n");
+		return -1;
+	}
+}
+
+static inline u32 regw(u32 val, u32 offset)
+{
+	if (offset <= ccdc_addr_size) {
+		__raw_writel(val, ccdc_base_addr + offset);
+		return val;
+	} else {
+		dev_err(dev, "offset exceeds ccdc register address space\n");
+		return -1;
+	}
+}
+
+/* register access routines */
+static inline u32 regr_bl(u32 offset)
+{
+	if (offset <= vpss_addr_size)
+		return __raw_readl(vpss_base_addr + offset);
+	else {
+		dev_err(dev, "offset exceeds vpss register address space\n");
+		return -1;
+	}
+}
+
+static inline u32 regw_bl(u32 val, u32 offset)
+{
+	if (offset <= vpss_addr_size) {
+		__raw_writel(val, vpss_base_addr + offset);
+		return val;
+	} else {
+		dev_err(dev, "offset exceeds vpss register address space\n");
+		return -1;
+	}
+}
+static void ccdc_set_ccdc_base(void *addr, int size)
+{
+	ccdc_base_addr = addr;
+	ccdc_addr_size = size;
+}
+
+static void ccdc_set_vpss_base(void *addr, int size)
+{
+	vpss_base_addr = addr;
+	vpss_addr_size = size;
+}
+
+static void *ccdc_get_ccdc_base(void)
+{
+	return (void *)ccdc_base_addr;
+}
+
+static void *ccdc_get_vpss_base(void)
+{
+	return (void *)vpss_base_addr;
+}
+
+static void ccdc_enable(int en)
+{
+	unsigned int temp;
+	temp = regr(SYNCEN);
+	temp &= (~0x1);
+	temp |= (en & 0x01);
+	regw(temp, SYNCEN);
+}
+
+static void ccdc_enable_output_to_sdram(int en)
+{
+	unsigned int temp;
+	temp = regr(SYNCEN);
+	temp &= (~(0x1 << 1));
+	temp |= (en & 0x01) << 1;
+	regw(temp, SYNCEN);
+}
+
+static void ccdc_config_gain_offset(void)
+{
+	/* configure gain */
+	regw(ccdc_hw_params_raw.gain.r_ye, RYEGAIN);
+	regw(ccdc_hw_params_raw.gain.gr_cy, GRCYGAIN);
+	regw(ccdc_hw_params_raw.gain.gb_g, GBGGAIN);
+	regw(ccdc_hw_params_raw.gain.b_mg, BMGGAIN);
+	/* configure offset */
+	regw(ccdc_hw_params_raw.ccdc_offset, OFFSET);
+}
+
+/* Query control. Only applicable for Bayer capture */
+static int ccdc_queryctrl(struct v4l2_queryctrl *qctrl)
+{
+	int i, id;
+	struct v4l2_queryctrl *control = NULL;
+
+	dev_dbg(dev, "ccdc_queryctrl: start\n");
+	if (NULL == qctrl) {
+		dev_err(dev, "ccdc_queryctrl : invalid user ptr\n");
+		return -EINVAL;
+	}
+
+	if (VPFE_RAW_BAYER != ccdc_if_type) {
+		dev_err(dev,
+		       "ccdc_queryctrl : Not doing Raw Bayer Capture\n");
+		return -EINVAL;
+	}
+
+	id = qctrl->id;
+	memset(qctrl, 0, sizeof(struct v4l2_queryctrl));
+	for (i = 0; i < CCDC_MAX_CONTROLS; i++) {
+		control = &ccdc_control_info[i];
+		if (control->id == id)
+			break;
+	}
+	if (i == CCDC_MAX_CONTROLS) {
+		dev_err(dev, "ccdc_queryctrl : Invalid control ID\n");
+		return -EINVAL;
+	}
+	memcpy(qctrl, control, sizeof(struct v4l2_queryctrl));
+	dev_dbg(dev, "ccdc_queryctrl: end\n");
+	return 0;
+}
+
+static int ccdc_setcontrol(struct v4l2_control *ctrl)
+{
+	int i;
+	struct v4l2_queryctrl *control = NULL;
+	struct ccdc_gain *gain =
+	    &ccdc_hw_params_raw.gain;
+
+	if (NULL == ctrl) {
+		dev_err(dev, "ccdc_setcontrol: invalid user ptr\n");
+		return -EINVAL;
+	}
+
+	if (ccdc_if_type != VPFE_RAW_BAYER) {
+		dev_err(dev,
+		       "ccdc_setcontrol: Not doing Raw Bayer Capture\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < CCDC_MAX_CONTROLS; i++) {
+		control = &ccdc_control_info[i];
+		if (control->id == ctrl->id)
+			break;
+	}
+
+	if (i == CCDC_MAX_CONTROLS) {
+		dev_err(dev, "ccdc_queryctrl : Invalid control ID, 0x%x\n",
+		       control->id);
+		return -EINVAL;
+	}
+
+	if (ctrl->value > control->maximum) {
+		dev_err(dev, "ccdc_queryctrl : Invalid control value\n");
+		return -EINVAL;
+	}
+
+	switch (ctrl->id) {
+	case CCDC_CID_R_GAIN:
+		gain->r_ye = ctrl->value & CCDC_GAIN_MASK;
+		break;
+	case CCDC_CID_GR_GAIN:
+		gain->gr_cy = ctrl->value & CCDC_GAIN_MASK;
+		break;
+	case CCDC_CID_GB_GAIN:
+		gain->gb_g = ctrl->value  & CCDC_GAIN_MASK;
+		break;
+
+	case CCDC_CID_B_GAIN:
+		gain->b_mg = ctrl->value  & CCDC_GAIN_MASK;
+		break;
+	default:
+		ccdc_hw_params_raw.ccdc_offset = ctrl->value & CCDC_OFFSET_MASK;
+	}
+
+	/* set it in hardware */
+	ccdc_config_gain_offset();
+	return 0;
+}
+
+static int ccdc_getcontrol(struct v4l2_control *ctrl)
+{
+	int i;
+	struct v4l2_queryctrl *control = NULL;
+
+	if (NULL == ctrl) {
+		dev_err(dev, "ccdc_setcontrol: invalid user ptr\n");
+		return -EINVAL;
+	}
+
+	if (ccdc_if_type != VPFE_RAW_BAYER) {
+		dev_err(dev,
+		       "ccdc_setcontrol: Not doing Raw Bayer Capture\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < CCDC_MAX_CONTROLS; i++) {
+		control = &ccdc_control_info[i];
+		if (control->id == ctrl->id)
+			break;
+	}
+
+	if (i == CCDC_MAX_CONTROLS) {
+		dev_err(dev, "ccdc_queryctrl : Invalid control ID\n");
+		return -EINVAL;
+	}
+
+	switch (ctrl->id) {
+	case CCDC_CID_R_GAIN:
+		ctrl->value = ccdc_hw_params_raw.gain.r_ye;
+		break;
+	case CCDC_CID_GR_GAIN:
+		ctrl->value = ccdc_hw_params_raw.gain.gr_cy;
+		break;
+	case CCDC_CID_GB_GAIN:
+		ctrl->value = ccdc_hw_params_raw.gain.gb_g;
+		break;
+	case CCDC_CID_B_GAIN:
+		ctrl->value = ccdc_hw_params_raw.gain.b_mg;
+		break;
+	default:
+		/* offset */
+		ctrl->value = ccdc_hw_params_raw.ccdc_offset;
+	}
+	/* set it in hardware */
+	return 0;
+}
+
+static void ccdc_reset(void)
+{
+	int i;
+	/* disable CCDC */
+	dev_dbg(dev, "\nstarting ccdc_reset...");
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x15c; i += 4)
+		regw(0, i);
+	/* no culling support */
+	regw(0xffff, CULH);
+	regw(0xff, CULV);
+	/* Set default Gain and Offset */
+	ccdc_hw_params_raw.gain.r_ye = 256;
+	ccdc_hw_params_raw.gain.gb_g = 256;
+	ccdc_hw_params_raw.gain.gr_cy = 256;
+	ccdc_hw_params_raw.gain.b_mg = 256;
+	ccdc_hw_params_raw.ccdc_offset = 0;
+	ccdc_config_gain_offset();
+	/* up to 14 bit sensor */
+	regw(0x3FFF, OUTCLIP);
+
+	/* CCDC input Mux select directly from sensor */
+	regw_bl(0x00, CCDCMUX);
+	dev_dbg(dev, "\nEnd of ccdc_reset...");
+}
+
+static int ccdc_open(struct device *device)
+{
+	dev = device;
+	ccdc_reset();
+	return 0;
+}
+
+/*
+ * ======== ccdc_setwin  ========
+ *
+ * This function will configure the window size to
+ * be capture in CCDC reg
+ */
+static void ccdc_setwin(struct ccdc_imgwin *image_win,
+			enum ccdc_frmfmt frm_fmt, int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int mid_img = 0;
+	dev_dbg(dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;
+
+	/*Writing the horizontal info into the registers */
+	regw(horz_start & START_PX_HOR_MASK, SPH);
+	regw(horz_nr_pixels & NUM_PX_HOR_MASK, NPH);
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		vert_start += 1; /* Since first line doesn't have any data */
+		/* configure VDINT0 and VDINT1 */
+		regw(vert_start, VDINT0);
+	} else {
+		vert_start += 1; /* Since first line doesn't have any data */
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		mid_img = vert_start + (image_win->height / 2);
+		regw(vert_start, VDINT0);
+		regw(mid_img, VDINT1);
+	}
+	regw(vert_start & START_VER_ONE_MASK, SLV0);
+	regw(vert_start & START_VER_TWO_MASK, SLV1);
+	regw(vert_nr_lines & NUM_LINES_VER, NLV);
+	dev_dbg(dev, "\nEnd of ccdc_setwin...");
+}
+
+static int validate_ccdc_param(struct ccdc_config_params_raw *ccdcparam)
+{
+	if (ccdcparam->pix_fmt != 0) {
+		dev_err(dev,
+		       "Invalid value of pix_fmt, only raw supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->frm_fmt != 0) {
+		dev_err(dev,
+		       "Only Progressive frame format is supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->fid_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->fid_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(dev, "Invalid value of field id polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->vd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->vd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(dev, "Invalid value of VD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->hd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->hd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(dev, "Invalid value of HD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->datasft < NO_SHIFT || ccdcparam->datasft > _6BIT) {
+		dev_err(dev, "Invalid value of data shift\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt1 < NO_MEDIAN_FILTER1
+	    || ccdcparam->mfilt1 > MEDIAN_FILTER1) {
+		dev_err(dev, "Invalid value of median filter1\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt2 < NO_MEDIAN_FILTER2
+	    || ccdcparam->mfilt2 > MEDIAN_FILTER2) {
+		dev_err(dev, "Invalid value of median filter2\n");
+		return -1;
+	}
+
+	if (ccdcparam->ccdc_offset < 0 || ccdcparam->ccdc_offset > 1023) {
+		dev_err(dev, "Invalid value of offset\n");
+		return -1;
+	}
+
+	if ((ccdcparam->med_filt_thres < 0)
+		|| (ccdcparam->med_filt_thres > 0x3FFF)) {
+		dev_err(dev, "Invalid value of median filter thresold\n");
+		return -1;
+	}
+
+	if (ccdcparam->data_sz < _16BITS || ccdcparam->data_sz > _8BITS) {
+		dev_err(dev, "Invalid value of data size\n");
+		return -1;
+	}
+
+	if (ccdcparam->alaw.b_alaw_enable) {
+		if (ccdcparam->alaw.gama_wd < BITS_13_4
+		    || ccdcparam->alaw.gama_wd > BITS_09_0) {
+			dev_err(dev, "Invalid value of ALAW\n");
+			return -1;
+		}
+	}
+
+	if (ccdcparam->blk_clamp.b_clamp_enable) {
+		if (ccdcparam->blk_clamp.sample_pixel < _1PIXELS
+		    || ccdcparam->blk_clamp.sample_pixel > _16PIXELS) {
+			dev_err(dev, "Invalid value of sample pixel\n");
+			return -1;
+		}
+		if (ccdcparam->blk_clamp.sample_ln < _1LINES
+		    || ccdcparam->blk_clamp.sample_ln > _16LINES) {
+			dev_err(dev, "Invalid value of sample lines\n");
+			return -1;
+		}
+
+	}
+
+	if (ccdcparam->lens_sh_corr.lsc_enable) {
+		dev_err(dev, "Lens shadding correction is not supported\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int ccdc_update_raw_params(void *arg)
+{
+	struct ccdc_config_params_raw *raw =
+		(struct ccdc_config_params_raw *)arg;
+
+	ccdc_hw_params_raw.pix_fmt =
+		raw->pix_fmt;
+	ccdc_hw_params_raw.frm_fmt =
+		raw->frm_fmt;
+	ccdc_hw_params_raw.win =
+		raw->win;
+	ccdc_hw_params_raw.fid_pol =
+		raw->fid_pol;
+	ccdc_hw_params_raw.vd_pol =
+		raw->vd_pol;
+	ccdc_hw_params_raw.hd_pol =
+		raw->hd_pol;
+	ccdc_hw_params_raw.buf_type =
+		raw->buf_type;
+	ccdc_hw_params_raw.datasft =
+		raw->datasft;
+	ccdc_hw_params_raw.mfilt1 =
+		raw->mfilt1;
+	ccdc_hw_params_raw.mfilt2 =
+		raw->mfilt2;
+	ccdc_hw_params_raw.lpf_enable =
+		raw->lpf_enable;
+	ccdc_hw_params_raw.horz_flip_enable =
+		raw->horz_flip_enable;
+	ccdc_hw_params_raw.ccdc_offset =
+		raw->ccdc_offset;
+	ccdc_hw_params_raw.med_filt_thres =
+		raw->med_filt_thres;
+	ccdc_hw_params_raw.image_invert_enable =
+		raw->image_invert_enable;
+	ccdc_hw_params_raw.data_sz =
+		raw->data_sz;
+	ccdc_hw_params_raw.alaw =
+		raw->alaw;
+	ccdc_hw_params_raw.data_offset_s =
+		raw->data_offset_s;
+	ccdc_hw_params_raw.blk_clamp =
+		raw->blk_clamp;
+	ccdc_hw_params_raw.vertical_dft =
+		raw->vertical_dft;
+	ccdc_hw_params_raw.lens_sh_corr =
+		raw->lens_sh_corr;
+	ccdc_hw_params_raw.data_formatter_r =
+		raw->data_formatter_r;
+	ccdc_hw_params_raw.color_space_con =
+		raw->color_space_con;
+	ccdc_hw_params_raw.col_pat_field0 =
+		raw->col_pat_field0;
+	ccdc_hw_params_raw.col_pat_field1 =
+		raw->col_pat_field1;
+
+	return 0;
+}
+
+static int ccdc_update_ycbcr_params(void *arg)
+{
+	if (copy_from_user(&ccdc_hw_params_ycbcr,
+			   (struct ccdc_params_ycbcr *)arg,
+			   sizeof(struct ccdc_params_ycbcr))) {
+		dev_err(dev, "ccdc_update_ycbcr_params: error"
+			   "in copying ccdc params\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+/* Parameter operations */
+static int ccdc_setparams(void *params)
+{
+	int x;
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		x = copy_from_user(&ccdc_hw_params_raw_temp,
+				   (struct ccdc_config_params_raw *)params,
+				   sizeof(struct ccdc_config_params_raw));
+		if (x) {
+			dev_err(dev, "ccdc_setparams: error in copying ccdc"
+				"params, %d\n", x);
+			return -EFAULT;
+		}
+
+		if (!validate_ccdc_param(&ccdc_hw_params_raw_temp)) {
+			if (!ccdc_update_raw_params(&ccdc_hw_params_raw_temp))
+				return 0;
+		}
+	} else{
+		return ccdc_update_ycbcr_params(params);
+	}
+	return -EINVAL;
+}
+
+
+/*This function will configure CCDC for YCbCr parameters*/
+static void ccdc_config_ycbcr(void)
+{
+	u32 modeset;
+	struct ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(dev, "\nStarting ccdc_config_ycbcr...");
+	ccdc_reset();
+
+	/* configure pixel format */
+	modeset = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	modeset |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		modeset |= 0x04;
+	} else {		/* y/c external sync mode */
+		modeset |= ((params->fid_pol & 0x1) << 4);
+		modeset |= ((params->hd_pol & 0x1) << 3);
+		modeset |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* pack the data to 8-bit */
+	modeset |= 0x1 << 11;
+
+	regw(modeset, MODESET);
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8040, CCDCFG);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((((params->win.width * 2) + 31) & 0xffffffe0) >> 5), HSIZE);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+	}
+
+	dev_dbg(dev, "\nEnd of ccdc_config_ycbcr...\n");
+}
+
+
+/*
+ * ======== ccdc_config_raw  ========
+ *
+ * This function will configure CCDC for Raw mode parameters
+ */
+static void ccdc_config_raw(void)
+{
+	struct ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int mode_set = 0;
+	unsigned int val = 0, val1 = 0;
+	int temp1 = 0, temp2 = 0, i = 0, fmtreg_v = 0, shift_v = 0, flag = 0;
+	int temp_gf = 0, temp_lcs = 0;
+	dev_dbg(dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	ccdc_reset();
+
+	/*
+	 *      C O N F I G U R I N G  T H E  C C D C F G  R E G I S T E R
+	 */
+
+	/*Set CCD Not to swap input since input is RAW data */
+	val |= CCDC_YCINSWP_RAW;
+
+	/*set FID detection function to Latch at V-Sync */
+	val |= CCDC_CCDCFG_FIDMD_LATCH_VSYNC << CCDC_CCDCFG_FIDMD_SHIFT;
+
+	/*set WENLOG - ccdc valid area */
+	val |= CCDC_CCDCFG_WENLOG_AND << CCDC_CCDCFG_WENLOG_SHIFT;
+
+	/*set TRGSEL */
+	val |= CCDC_CCDCFG_TRGSEL_WEN << CCDC_CCDCFG_TRGSEL_SHIFT;
+
+	/*set EXTRG */
+	val |= CCDC_CCDCFG_EXTRG_DISABLE << CCDC_CCDCFG_EXTRG_SHIFT;
+
+	/* Disable latching function registers on VSYNC-busy writable
+	   registers  */
+
+	/* Enable latching function registers on VSYNC-shadowed registers */
+	val |= CCDC_LATCH_ON_VSYNC_DISABLE;
+	regw(val, CCDCFG);
+	/*
+	 *      C O N F I G U R I N G  T H E  M O D E S E T  R E G I S T E R
+	 */
+
+	/*Set VDHD direction to input */
+	mode_set |=
+	    (CCDC_VDHDOUT_INPUT & CCDC_VDHDOUT_MASK) << CCDC_VDHDOUT_SHIFT;
+
+	/*Set input type to raw input */
+	mode_set |=
+	    (CCDC_RAW_IP_MODE & CCDC_RAW_INPUT_MASK) << CCDC_RAW_INPUT_SHIFT;
+
+	/*      Configure the vertical sync polarity(MODESET.VDPOL) */
+	mode_set = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (MODESET.HDPOL) */
+	mode_set |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (MODESET.FLDPOL) */
+	mode_set |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/*      Configure data polarity */
+	mode_set |=
+	    (CCDC_DATAPOL_NORMAL & CCDC_DATAPOL_MASK) << CCDC_DATAPOL_SHIFT;
+
+	/*      Configure External WEN Selection */
+	mode_set |= (CCDC_EXWEN_DISABLE & CCDC_EXWEN_MASK) << CCDC_EXWEN_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	mode_set |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	mode_set |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable){
+		mode_set |= CCDC_DATA_PACK_ENABLE;
+	}
+	
+	/* Configure for LPF */
+	if (params->lpf_enable)
+		mode_set |= (params->lpf_enable & CCDC_LPF_MASK) <<
+				CCDC_LPF_SHIFT;
+	/* Configure the data shift */
+	mode_set |= (params->datasft & CCDC_DATASFT_MASK) << CCDC_DATASFT_SHIFT;
+	regw(mode_set, MODESET);
+	dev_dbg(dev, "\nWriting 0x%x to MODESET...\n", mode_set);
+
+	/* Configure the Median Filter threshold */
+	regw((params->med_filt_thres) & 0x3fff, MEDFILT);
+
+	/*
+	 *      C O N F I G U R E   T H E   G A M M A W D   R E G I S T E R
+	 */
+
+	val = 8;
+	val |=
+	    (CCDC_CFA_MOSAIC & CCDC_GAMMAWD_CFA_MASK) << CCDC_GAMMAWD_CFA_SHIFT;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val |= (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK) << 2;
+		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
+	}
+
+	/* Configure Median filter1 for IPIPE capture */
+	val |= params->mfilt1 << CCDC_MFILT1_SHIFT;
+
+	/* Configure Median filter2 for SDRAM capture */
+	val |= params->mfilt2 << CCDC_MFILT2_SHIFT;
+
+	regw(val, GAMMAWD);
+	dev_dbg(dev, "\nWriting 0x%x to GAMMAWD...\n", val);
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 1);
+
+	/*
+	 *      O P T I C A L   B L A C K   A V E R A G I N G
+	 */
+	val = 0;
+	if (params->blk_clamp.b_clamp_enable) {
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK);
+
+		/* No of line to be avg */
+		val1 |= (params->blk_clamp.sample_ln & CCDC_NUM_LINE_CALC_MASK)
+		    << CCDC_NUM_LINE_CALC_SHIFT;
+		/* No of pixel/line to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;
+		/* Enable the Black clamping */
+		val |= CCDC_BLK_CLAMP_ENABLE;
+		regw(val, CLAMP);
+
+		dev_dbg(dev, "\nWriting 0x%x to CLAMP...\n", val);
+		/* If Black clamping is enable then make dcsub 0 */
+		regw(val1, DCSUB);
+		dev_dbg(dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		regw(val, DCSUB);
+
+		dev_dbg(dev, "\nWriting 0x%x to DCSUB...\n", val);
+		regw(0x0000, CLAMP);
+
+		dev_dbg(dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*
+	 *  C O N F I G U R E   B L A C K   L E V E L   C O M P E N S A T I O N
+	 */
+	val = 0;
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	regw(val, BLKCMP1);
+
+	val1 = 0;
+	val1 |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val1 |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+	regw(val1, BLKCMP0);
+
+	dev_dbg(dev, "\nWriting 0x%x to BLKCMP1...\n", val);
+	dev_dbg(dev, "\nWriting 0x%x to BLKCMP0...\n", val1);
+
+	/* Configure Vertical Defect Correction if needed */
+	if (params->vertical_dft.ver_dft_en) {
+
+		shift_v = 0;
+		shift_v = 0 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		shift_v |=
+		    params->vertical_dft.gen_dft_en & CCDC_DFCCTL_GDFCEN_MASK;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcsl & CCDC_DFCCTL_VDFCSL_MASK) <<
+		    CCDC_DFCCTL_VDFCSL_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcuda & CCDC_DFCCTL_VDFCUDA_MASK) <<
+		    CCDC_DFCCTL_VDFCUDA_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdflsft & CCDC_DFCCTL_VDFLSFT_MASK) <<
+		    CCDC_DFCCTL_VDFLSFT_SHIFT;
+		regw(shift_v, DFCCTL);
+		regw(params->vertical_dft.dft_corr_vert[0], DFCMEM0);
+		regw(params->vertical_dft.dft_corr_horz[0], DFCMEM1);
+		regw(params->vertical_dft.dft_corr_sub1[0], DFCMEM2);
+		regw(params->vertical_dft.dft_corr_sub2[0], DFCMEM3);
+		regw(params->vertical_dft.dft_corr_sub3[0], DFCMEM4);
+
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 1 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		shift_v |= 1;
+		regw(shift_v, DFCMEMCTL);
+
+		while (1) {
+			flag = regr(DFCMEMCTL);
+			if ((flag & 0x01) == 0x00)
+				break;
+		}
+		flag = 0;
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 0 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		regw(shift_v, DFCMEMCTL);
+
+		for (i = 1; i < 16; i++) {
+			regw(params->vertical_dft.dft_corr_vert[i], DFCMEM0);
+			regw(params->vertical_dft.dft_corr_horz[i], DFCMEM1);
+			regw(params->vertical_dft.dft_corr_sub1[i], DFCMEM2);
+			regw(params->vertical_dft.dft_corr_sub2[i], DFCMEM3);
+			regw(params->vertical_dft.dft_corr_sub3[i], DFCMEM4);
+
+			shift_v = 0;
+			shift_v = regr(DFCMEMCTL);
+			shift_v |= 1;
+			regw(shift_v, DFCMEMCTL);
+
+			while (1) {
+				flag = regr(DFCMEMCTL);
+				if ((flag & 0x01) == 0x00)
+					break;
+			}
+			flag = 0;
+		}
+		regw(params->vertical_dft.
+		     saturation_ctl & CCDC_VDC_DFCVSAT_MASK, DFCVSAT);
+
+		shift_v = 0;
+		shift_v = regr(DFCCTL);
+		shift_v |= 1 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		regw(shift_v, DFCCTL);
+	}
+
+	/* Configure Lens Shading Correction if needed */
+	if (params->lens_sh_corr.lsc_enable) {
+		dev_dbg(dev, "\nlens shading Correction entered....\n");
+
+		/* first disable the LSC */
+		regw(CCDC_LSC_DISABLE, LSCCFG1);
+
+		/* UPDATE PROCEDURE FOR GAIN FACTOR TABLE 1 */
+
+		/* select table 1 */
+		regw(CCDC_LSC_TABLE1_SLC, LSCMEMCTL);
+
+		/* Reset memory address */
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		regw(temp_lcs, LSCMEMCTL);
+
+		/* Update gainfactor for table 1 - u8q8 */
+		temp_gf =
+		    ((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		    & CCDC_LSC_FRAC_MASK_T1;
+		temp_gf |=
+		    (((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		     & CCDC_LSC_FRAC_MASK_T1) << 8;
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/* set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 2; i < 255; i += 2) {
+			temp_gf = 0;
+			temp_gf = ((int)
+				   (params->lens_sh_corr.gf_table1[0].frac_no *
+				    256))
+			    & CCDC_LSC_FRAC_MASK_T1;
+			temp_gf |= (((int)
+				     (params->lens_sh_corr.gf_table1[0].
+				      frac_no * 256))
+				    & CCDC_LSC_FRAC_MASK_T1) << 8;
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/* UPDATE PROCEDURE FOR GAIN FACTOR TABLE 2 */
+
+		/* select table 2 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE2_SLC;
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table2[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table2[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 3 */
+
+		/*select table 3 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE3_SLC;
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table3[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table3[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+		/*Configuring the optical centre of the lens */
+		regw(params->lens_sh_corr.
+		     lens_center_horz & CCDC_LSC_CENTRE_MASK, LSCH0);
+		regw(params->lens_sh_corr.
+		     lens_center_vert & CCDC_LSC_CENTRE_MASK, LSCV0);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.horz_left_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.horz_left_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.horz_right_coef.frac_no * 128))
+		     & 0x7f) << 8;
+		val |=
+		    (params->lens_sh_corr.horz_right_coef.int_no & 0x01) << 15;
+		regw(val, LSCKH);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.ver_up_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.ver_up_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.ver_low_coef.frac_no * 128)) &
+		     0x7f) << 8;
+		val |= (params->lens_sh_corr.ver_low_coef.int_no & 0x01) << 15;
+		regw(val, LSCKV);
+
+		/*configuring the lsc configuration register 2 */
+		temp_lcs = 0;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_scaling_fact & CCDC_LSCCFG_GFTSF_MASK) <<
+		    CCDC_LSCCFG_GFTSF_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_interval & CCDC_LSCCFG_GFTINV_MASK) <<
+		    CCDC_LSCCFG_GFTINV_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPOL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPOL_SHIFT;
+		regw(temp_lcs, LSCCFG2);
+
+		/*configuring the LSC configuration register 1 */
+		temp_lcs = 0;
+		temp_lcs |= CCDC_LSC_ENABLE;
+		temp_lcs |= (params->lens_sh_corr.lsc_config.mode &
+			     CCDC_LSC_GFMODE_MASK) << CCDC_LSC_GFMODE_SHIFT;
+		regw(temp_lcs, LSCCFG1);
+	}
+
+	/* Configure data formatter if needed */
+	if (params->data_formatter_r.fmt_enable
+	    && (!params->color_space_con.csc_enable)) {
+		dev_dbg(dev,
+		       "\ndata formatter will be configured now....\n");
+
+		/*Configuring the FMTPLEN */
+		fmtreg_v = 0;
+		fmtreg_v |=
+		    (params->data_formatter_r.plen.
+		     plen0 & CCDC_FMTPLEN_P0_MASK);
+		fmtreg_v |=
+		    ((params->data_formatter_r.plen.
+		      plen1 & CCDC_FMTPLEN_P1_MASK)
+		     << CCDC_FMTPLEN_P1_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.plen.
+		      plen2 & CCDC_FMTPLEN_P2_MASK)
+		     << CCDC_FMTPLEN_P2_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.plen.
+		      plen3 & CCDC_FMTPLEN_P3_MASK)
+		     << CCDC_FMTPLEN_P3_SHIFT);
+		regw(fmtreg_v, FMTPLEN);
+
+		/*Configurring the FMTSPH */
+		regw((params->data_formatter_r.fmtsph & CCDC_FMTSPH_MASK),
+		     FMTSPH);
+
+		/*Configurring the FMTLNH */
+		regw((params->data_formatter_r.fmtlnh & CCDC_FMTLNH_MASK),
+		     FMTLNH);
+
+		/*Configurring the FMTSLV */
+		regw((params->data_formatter_r.fmtslv & CCDC_FMTSLV_MASK),
+		     FMTSLV);
+
+		/*Configurring the FMTLNV */
+		regw((params->data_formatter_r.fmtlnv & CCDC_FMTLNV_MASK),
+		     FMTLNV);
+
+		/*Configurring the FMTRLEN */
+		regw((params->data_formatter_r.fmtrlen & CCDC_FMTRLEN_MASK),
+		     FMTRLEN);
+
+		/*Configurring the FMTHCNT */
+		regw((params->data_formatter_r.fmthcnt & CCDC_FMTHCNT_MASK),
+		     FMTHCNT);
+
+		/*Configuring the FMTADDR_PTR */
+		for (i = 0; i < 8; i++) {
+			fmtreg_v = 0;
+
+			if (params->data_formatter_r.addr_ptr[i].init >
+			    (params->data_formatter_r.fmtrlen - 1)) {
+				dev_dbg(dev, "\nInvalid init parameter for"
+					   "FMTADDR_PTR....\n");
+				return;
+			}
+
+			fmtreg_v =
+			    (params->data_formatter_r.addr_ptr[i].
+			     init & CCDC_ADP_INIT_MASK);
+			fmtreg_v |=
+			    ((params->data_formatter_r.addr_ptr[i].
+			      line & CCDC_ADP_LINE_MASK) <<
+			     CCDC_ADP_LINE_SHIFT);
+			regw(fmtreg_v, FMT_ADDR_PTR(i));
+		}
+
+		/* Configuring the FMTPGM_VF0 */
+		fmtreg_v = 0;
+		for (i = 0; i < 16; i++)
+			fmtreg_v |= params->data_formatter_r.pgm_en[i] << i;
+		regw(fmtreg_v, FMTPGM_VF0);
+
+		/* Configuring the FMTPGM_VF1 */
+		fmtreg_v = 0;
+		for (i = 16; i < 32; i++) {
+			fmtreg_v |=
+			    params->data_formatter_r.pgm_en[i] << (i - 16);
+		}
+		regw(fmtreg_v, FMTPGM_VF1);
+
+		/* Configuring the FMTPGM_AP0 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 0; i < 4; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP0);
+
+		/* Configuring the FMTPGM_AP1 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 4; i < 8; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP1);
+
+		/* Configuring the FMTPGM_AP2 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 8; i < 12; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP2);
+
+		/* Configuring the FMTPGM_AP3 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 12; i < 16; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP3);
+
+		/* Configuring the FMTPGM_AP4 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 16; i < 20; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP4);
+
+		/* Configuring the FMTPGM_AP5 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 20; i < 24; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP5);
+
+		/* Configuring the FMTPGM_AP6 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 24; i < 28; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP6);
+
+		/* Configuring the FMTPGM_AP7 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 28; i < 32; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.pgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.pgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		regw(fmtreg_v, FMTPGM_AP7);
+
+		/* Configuring the FMTCFG register */
+		fmtreg_v = 0;
+		fmtreg_v = CCDC_DF_ENABLE;
+		fmtreg_v |=
+		    ((params->data_formatter_r.cfg.
+		      mode & CCDC_FMTCFG_FMTMODE_MASK)
+		     << CCDC_FMTCFG_FMTMODE_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.cfg.
+		      lnum & CCDC_FMTCFG_LNUM_MASK)
+		     << CCDC_FMTCFG_LNUM_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.cfg.
+		      addrinc & CCDC_FMTCFG_ADDRINC_MASK)
+		     << CCDC_FMTCFG_ADDRINC_SHIFT);
+		regw(fmtreg_v, FMTCFG);
+
+	} else if (params->data_formatter_r.fmt_enable) {
+		dev_dbg(dev,
+		       "\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/*
+	 *      C O N F I G U R E   C O L O R   S P A C E   C O N V E R T E R
+	 */
+
+	if ((params->color_space_con.csc_enable)
+	    && (!params->data_formatter_r.fmt_enable)) {
+		dev_dbg(dev, "\nconfiguring the CSC Now....\n");
+
+		/* Enable the CSC sub-module */
+		regw(CCDC_CSC_ENABLE, CSCCTL);
+
+		/* Converting the co-eff as per the format of the register */
+		for (i = 0; i < 16; i++) {
+			temp1 = params->color_space_con.csc_dec_coeff[i];
+			/* Masking the data for 3 bits */
+			temp1 &= CCDC_CSC_COEFF_DEC_MASK;
+			/* Recovering the fractional part and converting to
+			 * binary of 5 bits
+			 */
+			temp2 =
+			    (int)(params->color_space_con.csc_frac_coeff[i] *
+				  (32 / 10));
+			temp2 &= CCDC_CSC_COEFF_FRAC_MASK;
+			/* shifting the decimal to the MSB */
+			temp1 = temp1 << CCDC_CSC_DEC_SHIFT;
+			temp1 |= temp2;
+			params->color_space_con.csc_dec_coeff[i] = temp1;
+		}
+		regw(params->color_space_con.csc_dec_coeff[0], CSCM0);
+		regw(params->color_space_con.
+		     csc_dec_coeff[1] << CCDC_CSC_COEFF_SHIFT, CSCM0);
+		regw(params->color_space_con.csc_dec_coeff[2], CSCM1);
+		regw(params->color_space_con.
+		     csc_dec_coeff[3] << CCDC_CSC_COEFF_SHIFT, CSCM1);
+		regw(params->color_space_con.csc_dec_coeff[4], CSCM2);
+		regw(params->color_space_con.
+		     csc_dec_coeff[5] << CCDC_CSC_COEFF_SHIFT, CSCM2);
+		regw(params->color_space_con.csc_dec_coeff[6], CSCM3);
+		regw(params->color_space_con.
+		     csc_dec_coeff[7] << CCDC_CSC_COEFF_SHIFT, CSCM3);
+		regw(params->color_space_con.csc_dec_coeff[8], CSCM4);
+		regw(params->color_space_con.
+		     csc_dec_coeff[9] << CCDC_CSC_COEFF_SHIFT, CSCM4);
+		regw(params->color_space_con.csc_dec_coeff[10], CSCM5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[11] << CCDC_CSC_COEFF_SHIFT, CSCM5);
+		regw(params->color_space_con.csc_dec_coeff[12], CSCM6);
+		regw(params->color_space_con.
+		     csc_dec_coeff[13] << CCDC_CSC_COEFF_SHIFT, CSCM6);
+		regw(params->color_space_con.csc_dec_coeff[14], CSCM7);
+		regw(params->color_space_con.
+		     csc_dec_coeff[15] << CCDC_CSC_COEFF_SHIFT, CSCM7);
+
+	} else if (params->color_space_con.csc_enable) {
+		dev_dbg(dev,
+		       "\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/* Configure the Gain  & offset control */
+	ccdc_config_gain_offset();
+
+	/*
+	 *      C O N F I G U R E  C O L O R  P A T T E R N  A S
+	 *      P E R  N N 1 2 8 6 A  S E N S O R
+	 */
+
+	val = (params->col_pat_field0.olop);
+	val |= (params->col_pat_field0.olep << 2);
+	val |= (params->col_pat_field0.elop << 4);
+	val |= (params->col_pat_field0.elep << 6);
+	val |= (params->col_pat_field1.olop << 8);
+	val |= (params->col_pat_field1.olep << 10);
+	val |= (params->col_pat_field1.elop << 12);
+	val |= (params->col_pat_field1.elep << 14);
+	regw(val, COLPTN);
+
+	dev_dbg(dev, "\nWriting %x to COLPTN...\n", val);
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->data_offset_s.
+	     horz_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_H_SHIFT;
+	val |=
+	    (params->data_offset_s.
+	     vert_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_V_SHIFT;
+	regw(val, DATAOFST);
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->
+	     horz_flip_enable & CCDC_HSIZE_FLIP_MASK) << CCDC_HSIZE_FLIP_SHIFT;
+
+	/* If pack 8 is enable then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		val |= (((params->win.width) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(dev, "\nWriting 0x%x to HSIZE...\n",
+		       (((params->win.width) + 31) >> 5) & 0x0fff);
+	} else {
+		/* else one pixel will take 2 byte */
+		val |= (((params->win.width * 2) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(dev, "\nWriting 0x%x to HSIZE...\n",
+		       (((params->win.width * 2) + 31) >> 5) & 0x0fff);
+	}
+	regw(val, HSIZE);
+
+	/*
+	 *      C O N F I G U R E   S D O F S T  R E G I S T E R
+	 */
+
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For interlace inverse mode */
+			regw(0x4B6D, SDOFST);
+			dev_dbg(dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For interlace non inverse mode */
+			regw(0x0B6D, SDOFST);
+			dev_dbg(dev, "\nWriting 0x0B6D to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		if (params->image_invert_enable) {
+			/* For progessive inverse mode */
+			regw(0x4000, SDOFST);
+			dev_dbg(dev, "\nWriting 0x4000 to SDOFST...\n");
+		}
+
+		else {
+			/* For progessive non inverse mode */
+			regw(0x0000, SDOFST);
+			dev_dbg(dev, "\nWriting 0x0000 to SDOFST...\n");
+		}
+
+	}
+
+	/*
+	 *      C O N F I G U R E   I N T E R R U P T   R E G I S T E R S
+	 */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		val = params->win.height / 2;
+		regw(136, VDINT0);
+		regw(149, VDINT0);
+		regw(0, VDINT1);
+	} else {
+		regw(0, VDINT0);
+		regw(0, VDINT1);
+	}
+
+	dev_dbg(dev, "\nend of ccdc_config_raw...");
+}
+
+static int ccdc_configure(void)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		dev_info(dev, "calling ccdc_config_raw()\n");
+		ccdc_config_raw();
+	} else {
+		dev_info(dev, "calling ccdc_config_ycbcr()\n");
+		ccdc_config_ycbcr();
+	}
+	return 0;
+}
+
+static int ccdc_set_buftype(enum ccdc_buftype buf_type)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		ccdc_hw_params_raw.buf_type = buf_type;
+	else
+		ccdc_hw_params_ycbcr.buf_type = buf_type;
+	return 0;
+}
+static int ccdc_get_buftype(enum ccdc_buftype *buf_type)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		*buf_type = ccdc_hw_params_raw.buf_type;
+	else
+		*buf_type = ccdc_hw_params_ycbcr.buf_type;
+	return 0;
+}
+
+static int ccdc_enum_pix(enum vpfe_hw_pix_format *hw_pix, int i)
+{
+	int ret = -EINVAL;
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		if (i < CCDC_MAX_RAW_BAYER_FORMATS) {
+			*hw_pix = ccdc_raw_bayer_hw_formats[i];
+			ret = 0;
+		}
+	} else {
+		if (i < CCDC_MAX_RAW_YUV_FORMATS) {
+			*hw_pix = ccdc_raw_yuv_hw_formats[i];
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int ccdc_set_pixel_format(enum vpfe_hw_pix_format pixfmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		ccdc_hw_params_raw.pix_fmt = CCDC_PIXFMT_RAW;
+		if (pixfmt == VPFE_BAYER_8BIT_PACK_ALAW)
+			ccdc_hw_params_raw.alaw.b_alaw_enable = 1;
+		else if (pixfmt != VPFE_BAYER)
+			return -1;
+	} else {
+		if (pixfmt == VPFE_YUYV)
+			ccdc_hw_params_ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;
+		else if (pixfmt == VPFE_UYVY)
+			ccdc_hw_params_ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;
+		else
+			return -1;
+	}
+	return 0;
+}
+static int ccdc_get_pixel_format(enum vpfe_hw_pix_format *pixfmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		if (ccdc_hw_params_raw.alaw.b_alaw_enable)
+			*pixfmt = VPFE_BAYER_8BIT_PACK_ALAW;
+		else
+			*pixfmt = VPFE_BAYER;
+	else {
+		if (ccdc_hw_params_ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)
+			*pixfmt = VPFE_YUYV;
+		else
+			*pixfmt = VPFE_UYVY;
+	}
+	return 0;
+}
+static int ccdc_set_image_window(struct v4l2_rect *win)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		ccdc_hw_params_raw.win.top = win->top;
+		ccdc_hw_params_raw.win.left = win->left;
+		ccdc_hw_params_raw.win.width = win->width;
+		ccdc_hw_params_raw.win.height = win->height;
+	} else {
+		ccdc_hw_params_ycbcr.win.top = win->top;
+		ccdc_hw_params_ycbcr.win.left = win->left;
+		ccdc_hw_params_ycbcr.win.width = win->width;
+		ccdc_hw_params_ycbcr.win.height = win->height;
+	}
+	return 0;
+}
+static int ccdc_get_image_window(struct v4l2_rect *win)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		win->top = ccdc_hw_params_raw.win.top;
+		win->left = ccdc_hw_params_raw.win.left;
+		win->width = ccdc_hw_params_raw.win.width;
+		win->height = ccdc_hw_params_raw.win.height;
+	} else {
+		win->top = ccdc_hw_params_ycbcr.win.top;
+		win->left = ccdc_hw_params_ycbcr.win.left;
+		win->width = ccdc_hw_params_ycbcr.win.width;
+		win->height = ccdc_hw_params_ycbcr.win.height;
+	}
+	return 0;
+}
+static int ccdc_get_line_length(unsigned int *len)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER) {
+		if ((ccdc_hw_params_raw.alaw.b_alaw_enable) ||
+		    (ccdc_hw_params_raw.data_sz == _8BITS)) {
+			*len = ccdc_hw_params_raw.win.width;
+		} else {
+			*len = ccdc_hw_params_raw.win.width * 2;
+		}
+	} else {
+		*len = ccdc_hw_params_ycbcr.win.width * 2;
+	}
+	*len = ((*len + 31) & ~0x1f);
+	return 0;
+}
+
+static int ccdc_set_frame_format(enum ccdc_frmfmt frm_fmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		ccdc_hw_params_raw.frm_fmt = frm_fmt;
+	else
+		ccdc_hw_params_ycbcr.frm_fmt = frm_fmt;
+	return 0;
+}
+static int ccdc_get_frame_format(enum ccdc_frmfmt *frm_fmt)
+{
+	if (ccdc_if_type == VPFE_RAW_BAYER)
+		*frm_fmt = ccdc_hw_params_raw.frm_fmt;
+	else
+		*frm_fmt = ccdc_hw_params_ycbcr.frm_fmt;
+	return 0;
+}
+
+static int ccdc_getfid(void)
+{
+	int fid = (regr(MODESET) >> 15) & 0x1;
+	return fid;
+}
+
+/* misc operations */
+static inline void ccdc_setfbaddr(unsigned long addr)
+{
+	regw((addr >> 21) & 0x007f, STADRH);
+	regw((addr >> 5) & 0x0ffff, STADRL);
+}
+
+static int ccdc_set_hw_if_type(enum vpfe_hw_if_type iface)
+{
+	ccdc_if_type = VPFE_RAW_BAYER;
+	// TODO: NOW it is for testing only
+	/* ccdc_if_type = iface; */
+	return 0;
+}
+
+struct ccdc_hw_device ccdc_hw_dev = {
+	.name = "DM355 CCDC",
+	.set_ccdc_base = ccdc_set_ccdc_base,
+	.set_vpss_base = ccdc_set_vpss_base,
+	.get_ccdc_base = ccdc_get_ccdc_base,
+	.get_vpss_base = ccdc_get_vpss_base,
+	.open = ccdc_open,
+	.enable = ccdc_enable,
+	.enable_out_to_sdram = ccdc_enable_output_to_sdram,
+	.set_hw_if_type = ccdc_set_hw_if_type,
+	.setparams = ccdc_setparams,
+	.configure = ccdc_configure,
+	.set_buftype = ccdc_set_buftype,
+	.get_buftype = ccdc_get_buftype,
+	.enum_pix = ccdc_enum_pix,
+	.set_pixelformat = ccdc_set_pixel_format,
+	.get_pixelformat = ccdc_get_pixel_format,
+	.set_frame_format = ccdc_set_frame_format,
+	.get_frame_format = ccdc_get_frame_format,
+	.set_image_window = ccdc_set_image_window,
+	.get_image_window = ccdc_get_image_window,
+	.get_line_length = ccdc_get_line_length,
+	.queryctrl = ccdc_queryctrl,
+	.setcontrol = ccdc_setcontrol,
+	.getcontrol = ccdc_getcontrol,
+	.setfbaddr = ccdc_setfbaddr,
+	.getfid = ccdc_getfid,
+};
+EXPORT_SYMBOL(ccdc_hw_dev);
+
+static int dm355_ccdc_init(void)
+{
+	return 0;
+}
+
+static void dm355_ccdc_exit(void)
+{
+}
+
+subsys_initcall(dm355_ccdc_init);
+module_exit(dm355_ccdc_exit);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/media/video/davinci/ccdc_dm355.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/ccdc_dm355.h	2009-11-20 10:07:18.494466825 -0600
@@ -0,0 +1,758 @@
+/*
+ * Copyright (C) 2005-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CCDC_DM355_H
+#define _CCDC_DM355_H
+#include <media/davinci/ccdc_common.h>
+
+/* Define to enable/disable video port */
+
+#define CCDC_WIN_PAL	{0, 0, 720, 576}
+#define CCDC_WIN_VGA	{0, 0, 640*2, 480}
+
+/* enum for No of pixel per line to be avg. in Black Clamping*/
+enum sample_length {
+	_1PIXELS,
+	_2PIXELS,
+	_4PIXELS,
+	_8PIXELS,
+	_16PIXELS
+};
+
+/* enum for No of lines in Black Clamping */
+enum sample_line {
+	_1LINES,
+	_2LINES,
+	_4LINES,
+	_8LINES,
+	_16LINES
+};
+
+/* enum for Alaw gama width */
+enum gama_width {
+	BITS_13_4,
+	BITS_12_3,
+	BITS_11_2,
+	BITS_10_1,
+	BITS_09_0
+};
+
+enum ccdc_colpats {
+	CCDC_RED,
+	CCDC_GREEN_RED,
+	CCDC_GREEN_BLUE,
+	CCDC_BLUE
+};
+
+struct ccdc_col_pat {
+	enum ccdc_colpats olop;
+	enum ccdc_colpats olep;
+	enum ccdc_colpats elop;
+	enum ccdc_colpats elep;
+};
+
+enum ccdc_datasft {
+	NO_SHIFT,
+	_1BIT,
+	_2BIT,
+	_3BIT,
+	_4BIT,
+	_5BIT,
+	_6BIT
+};
+
+enum data_size {
+	_16BITS,
+	_15BITS,
+	_14BITS,
+	_13BITS,
+	_12BITS,
+	_11BITS,
+	_10BITS,
+	_8BITS
+};
+enum ccdc_mfilt1 {
+	NO_MEDIAN_FILTER1,
+	AVERAGE_FILTER1,
+	MEDIAN_FILTER1
+};
+
+enum ccdc_mfilt2 {
+	NO_MEDIAN_FILTER2 = 0,
+	AVERAGE_FILTER2,
+	MEDIAN_FILTER2
+};
+
+struct ccdc_imgwin {
+	unsigned int top;
+	unsigned int left;
+	unsigned int width;
+	unsigned int height;
+};
+
+/* structure for ALaw */
+struct ccdc_a_law {
+	/* Enable/disable A-Law */
+	unsigned char b_alaw_enable;
+	/*Gama Width Input */
+	enum gama_width gama_wd;
+};
+
+/* structure for Black Clamping */
+struct ccdc_black_clamp {
+	/* only if bClampEnable is TRUE */
+	unsigned char b_clamp_enable;
+	/* only if bClampEnable is TRUE */
+	enum sample_length sample_pixel;
+	/* only if bClampEnable is TRUE */
+	enum sample_line sample_ln;
+	/* only if bClampEnable is TRUE */
+	unsigned short start_pixel;
+	/* only if bClampEnable is FALSE */
+	unsigned short sgain;
+	unsigned short dc_sub;
+};
+
+/* structure for Black Level Compensation */
+struct black_compensation {
+	/* Constant value to subtract from Red component */
+	unsigned char r_comp;
+	/* Constant value to subtract from Gr component */
+	unsigned char gr_comp;
+	/* Constant value to subtract from Blue component */
+	unsigned char b_comp;
+	/* Constant value to subtract from Gb component */
+	unsigned char gb_comp;
+};
+
+/*structures for lens shading correction*/
+
+/*gain factor modes*/
+enum gfmode {
+	u8q8_interpol,
+	u16q14_interpol,
+	reserved,
+	u16q14
+};
+
+enum gf_table_sel {
+	table1 = 0,
+	table2,
+	table3
+};
+
+/*LSC configuration structure*/
+struct lsccfg {
+	enum gfmode mode;
+	int gf_table_scaling_fact;
+	int gf_table_interval;
+	enum gf_table_sel epel;
+	enum gf_table_sel opel;
+	enum gf_table_sel epol;
+	enum gf_table_sel opol;
+};
+
+struct float_ccdc {
+	unsigned int int_no;
+	unsigned int frac_no;
+};
+
+/*Main structure for lens shading correction*/
+struct lens_shading_corr {
+	unsigned char lsc_enable;
+	struct lsccfg lsc_config;
+	unsigned int lens_center_horz;
+	unsigned int lens_center_vert;
+	struct float_ccdc horz_left_coef;
+	struct float_ccdc horz_right_coef;
+	struct float_ccdc ver_low_coef;
+	struct float_ccdc ver_up_coef;
+	struct float_ccdc gf_table1[256];
+	/*int_no will be always 0 since it is u8q8 */
+	struct float_ccdc gf_table2[128];
+	struct float_ccdc gf_table3[128];
+};
+
+/*structure for color space converter*/
+struct color_space_converter {
+	unsigned char csc_enable;
+	int csc_dec_coeff[16];
+	int csc_frac_coeff[16];
+};
+
+/*supporting structures for data formatter*/
+enum fmtmode {
+	split,
+	combine,
+	line_alt_mode
+};
+
+enum line_num {
+	_1line,
+	_2lines,
+	_3lines,
+	_4lines
+};
+
+enum line_pos {
+	_1stline,
+	_2ndline,
+	_3rdline,
+	_4thline
+};
+
+struct fmtplen {
+	unsigned int plen0;
+	unsigned int plen1;
+	unsigned int plen2;
+	unsigned int plen3;
+};
+
+struct fmtcfg {
+	enum fmtmode mode;
+	enum line_num lnum;
+	unsigned int addrinc;
+};
+
+struct fmtaddr_ptr {
+	unsigned int init;
+	enum line_pos line;
+};
+
+struct fmtpgm_ap {
+	unsigned int pgm_aptr;
+	unsigned char pgmupdt;
+};
+
+/* Main Structure for data formatter*/
+struct data_formatter {
+	unsigned char fmt_enable;
+	struct fmtcfg cfg;
+	struct fmtplen plen;
+	unsigned int fmtsph;
+	unsigned int fmtlnh;
+	unsigned int fmtslv;
+	unsigned int fmtlnv;
+	unsigned int fmtrlen;
+	unsigned int fmthcnt;
+	struct fmtaddr_ptr addr_ptr[8];
+	unsigned char pgm_en[32];
+	struct fmtpgm_ap pgm_ap[32];
+};
+
+/* Structures for Vertical Defect Correction*/
+enum vdf_csl {
+	normal = 0,
+	horz_interpol_sat,
+	horz_interpol
+};
+
+enum vdf_cuda {
+	whole_line_correct,
+	upper_disable
+};
+
+enum dfc_mwr {
+	write_complete,
+	write_reg
+};
+
+enum dfc_mrd {
+	read_complete,
+	read_reg
+};
+
+enum dfc_ma_rst {
+	incr_addr,
+	clr_addr
+};
+
+enum dfc_mclr {
+	clear_complete,
+	clear
+};
+
+struct dft_corr_ctl_s {
+	enum vdf_csl vdfcsl;
+	enum vdf_cuda vdfcuda;
+	unsigned int vdflsft;
+};
+
+struct dft_corr_mem_ctl_s {
+	enum dfc_mwr dfcmwr;
+	enum dfc_mrd dfcmrd;
+	enum dfc_ma_rst dfcmarst;
+	enum dfc_mclr dfcmclr;
+};
+
+/* Main Structure for vertical defect correction. Vertical defect
+ * correction can correct upto 16 defects if defects less than 16
+ * then pad the rest with 0
+ */
+struct vertical_dft_s {
+	unsigned char ver_dft_en;
+	unsigned char gen_dft_en;
+	unsigned int saturation_ctl;
+	struct dft_corr_ctl_s dft_corr_ctl;
+	struct dft_corr_mem_ctl_s dft_corr_mem_ctl;
+	unsigned int dft_corr_horz[16];
+	unsigned int dft_corr_vert[16];
+	unsigned int dft_corr_sub1[16];
+	unsigned int dft_corr_sub2[16];
+	unsigned int dft_corr_sub3[16];
+};
+
+struct data_offset {
+	unsigned char horz_offset;
+	unsigned char vert_offset;
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode passed
+ * by application
+ */
+struct ccdc_config_params_raw {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* interleaved or separated fields */
+	enum ccdc_buftype buf_type;
+	/*data shift to be applied before storing */
+	enum ccdc_datasft datasft;
+	/*median filter for sdram */
+	enum ccdc_mfilt1 mfilt1;
+	enum ccdc_mfilt2 mfilt2;
+	/*median filter for ipipe */
+	/*low pass filter enable/disable */
+	unsigned char lpf_enable;
+	unsigned char horz_flip_enable;
+	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	unsigned int ccdc_offset;
+	/*Threshold of median filter */
+	int med_filt_thres;
+	/* enable to store the image in inverse */
+	unsigned char image_invert_enable;
+	/* data size value from 8 to 16 bits */
+	enum data_size data_sz;
+	/*horz and vertical data offset */
+	struct data_offset data_offset_s;
+	/* Structure for Optional A-Law */
+	struct ccdc_a_law alaw;
+	/* Structure for Optical Black Clamp */
+	struct ccdc_black_clamp blk_clamp;
+	/* Structure for Black Compensation */
+	struct black_compensation blk_comp;
+	/*struture for vertical Defect Correction Module Configuration */
+	struct vertical_dft_s vertical_dft;
+	/*structure for lens shading Correction Module Configuration */
+	struct lens_shading_corr lens_sh_corr;
+	/*structure for data formatter Module Configuration */
+	struct data_formatter data_formatter_r;
+	/*structure for color space converter Module Configuration */
+	struct color_space_converter color_space_con;
+	struct ccdc_col_pat col_pat_field0;
+	struct ccdc_col_pat col_pat_field1;
+};
+
+#ifdef __KERNEL__
+#include <linux/io.h>
+/* SOC specific controls for Bayer capture. The CIDs
+ * listed here should match with that in davinci_vpfe.h
+ */
+/* White balance on Bayer RGB. U11Q8 */
+#define CCDC_CID_R_GAIN		(V4L2_CID_PRIVATE_BASE + 0)
+#define CCDC_CID_GR_GAIN	(V4L2_CID_PRIVATE_BASE + 1)
+#define CCDC_CID_GB_GAIN 	(V4L2_CID_PRIVATE_BASE + 2)
+#define CCDC_CID_B_GAIN 	(V4L2_CID_PRIVATE_BASE + 3)
+/* Offsets */
+#define CCDC_CID_OFFSET 	(V4L2_CID_PRIVATE_BASE + 4)
+#define CCDC_CID_MAX		(V4L2_CID_PRIVATE_BASE + 5)
+#define CCDC_MAX_CONTROLS 5
+
+/* Gain applied to Raw Bayer data */
+struct ccdc_gain {
+	unsigned short r_ye;
+	unsigned short gr_cy;
+	unsigned short gb_g;
+	unsigned short b_mg;
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode */
+struct ccdc_params_raw {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* interleaved or separated fields */
+	enum ccdc_buftype buf_type;
+	/*data shift to be applied before storing */
+	enum ccdc_datasft datasft;
+	/*median filter for sdram */
+	enum ccdc_mfilt1 mfilt1;
+	/*median filter for ipipe */
+	enum ccdc_mfilt2 mfilt2;
+	/*low pass filter enable/disable */
+	unsigned char lpf_enable;
+	unsigned char horz_flip_enable;
+	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	unsigned int ccdc_offset;
+	/* Gain values */
+	struct ccdc_gain gain;
+	/*Threshold of median filter */
+	int med_filt_thres;
+	/* enable to store the image in inverse order in memory
+	 * (bottom to top)
+	 */
+	unsigned char image_invert_enable;
+	/* data size value from 8 to 16 bits */
+	enum data_size data_sz;
+	/* Structure for Optional A-Law */
+	struct ccdc_a_law alaw;
+	/*horz and vertical data offset */
+	struct data_offset data_offset_s;
+	/* Structure for Optical Black Clamp */
+	struct ccdc_black_clamp blk_clamp;
+	/* Structure for Black Compensation */
+	struct black_compensation blk_comp;
+	/*struture for vertical Defect Correction Module Configuration */
+	struct vertical_dft_s vertical_dft;
+	/*structure for lens shading Correction Module Configuration */
+	struct lens_shading_corr lens_sh_corr;
+	/*structure for data formatter Module Configuration */
+	struct data_formatter data_formatter_r;
+	/*structure for color space converter Module Configuration */
+	struct color_space_converter color_space_con;
+	struct ccdc_col_pat col_pat_field0;
+	struct ccdc_col_pat col_pat_field1;
+};
+
+struct ccdc_params_ycbcr {
+	/* pixel format */
+	enum ccdc_pixfmt pix_fmt;
+	/* progressive or interlaced frame */
+	enum ccdc_frmfmt frm_fmt;
+	/* video window */
+	struct ccdc_imgwin win;
+	/* field id polarity */
+	enum ccdc_pinpol fid_pol;
+	/* vertical sync polarity */
+	enum ccdc_pinpol vd_pol;
+	/* horizontal sync polarity */
+	enum ccdc_pinpol hd_pol;
+	/* enable BT.656 embedded sync mode */
+	int bt656_enable;
+	/* cb:y:cr:y or y:cb:y:cr in memory */
+	enum ccdc_pixorder pix_order;
+	/* interleaved or separated fields  */
+	enum ccdc_buftype buf_type;
+};
+
+struct ccdc_supported_pix_fmt {
+	int index;
+	unsigned int pix_fmt;
+};
+
+/**************************************************************************\
+* Register OFFSET Definitions
+\**************************************************************************/
+#define SYNCEN				0x00
+#define MODESET				0x04
+#define HDWIDTH				0x08
+#define VDWIDTH				0x0c
+#define PPLN				0x10
+#define LPFR				0x14
+#define SPH				0x18
+#define NPH				0x1c
+#define SLV0				0x20
+#define SLV1				0x24
+#define NLV				0x28
+#define CULH				0x2c
+#define CULV				0x30
+#define HSIZE				0x34
+#define SDOFST				0x38
+#define STADRH				0x3c
+#define STADRL				0x40
+#define CLAMP				0x44
+#define DCSUB				0x48
+#define COLPTN				0x4c
+#define BLKCMP0				0x50
+#define BLKCMP1				0x54
+#define MEDFILT				0x58
+#define RYEGAIN				0x5c
+#define GRCYGAIN			0x60
+#define GBGGAIN				0x64
+#define BMGGAIN				0x68
+#define OFFSET				0x6c
+#define OUTCLIP				0x70
+#define VDINT0				0x74
+#define VDINT1				0x78
+#define RSV0				0x7c
+#define GAMMAWD				0x80
+#define REC656IF			0x84
+#define CCDCFG				0x88
+#define FMTCFG				0x8c
+#define FMTPLEN				0x90
+#define FMTSPH				0x94
+#define FMTLNH				0x98
+#define FMTSLV				0x9c
+#define FMTLNV				0xa0
+#define FMTRLEN				0xa4
+#define FMTHCNT				0xa8
+#define FMT_ADDR_PTR_B			0xac
+#define FMT_ADDR_PTR(i)			(FMT_ADDR_PTR_B + (i*4))
+#define FMTPGM_VF0			0xcc
+#define FMTPGM_VF1			0xd0
+#define FMTPGM_AP0			0xd4
+#define FMTPGM_AP1			0xd8
+#define FMTPGM_AP2			0xdc
+#define FMTPGM_AP3                      0xe0
+#define FMTPGM_AP4                      0xe4
+#define FMTPGM_AP5                      0xe8
+#define FMTPGM_AP6                      0xec
+#define FMTPGM_AP7                      0xf0
+#define LSCCFG1                         0xf4
+#define LSCCFG2                         0xf8
+#define LSCH0                           0xfc
+#define LSCV0                           0x100
+#define LSCKH                           0x104
+#define LSCKV                           0x108
+#define LSCMEMCTL                       0x10c
+#define LSCMEMD                         0x110
+#define LSCMEMQ                         0x114
+#define DFCCTL                          0x118
+#define DFCVSAT                         0x11c
+#define DFCMEMCTL                       0x120
+#define DFCMEM0                         0x124
+#define DFCMEM1                         0x128
+#define DFCMEM2                         0x12c
+#define DFCMEM3                         0x130
+#define DFCMEM4                         0x134
+#define CSCCTL                          0x138
+#define CSCM0                           0x13c
+#define CSCM1                           0x140
+#define CSCM2                           0x144
+#define CSCM3                           0x148
+#define CSCM4                           0x14c
+#define CSCM5                           0x150
+#define CSCM6                           0x154
+#define CSCM7                           0x158
+#define DATAOFST			0x15c
+
+#define CLKCTRL				(0x04)
+
+/* offset relative to 0x1c70800 */
+#define INTSTAT				(0xC)
+#define INTSEL				(0x10)
+#define	EVTSEL				(0x14)
+#define MEMCTRL				(0x18)
+#define CCDCMUX				(0x1C)
+
+/**************************************************************
+*	Define for various register bit mask and shifts for CCDC
+*
+**************************************************************/
+#define CCDC_RAW_IP_MODE			(0x00)
+#define CCDC_VDHDOUT_INPUT			(0x00)
+#define CCDC_YCINSWP_RAW			(0x00 << 4)
+#define CCDC_EXWEN_DISABLE 			(0x00)
+#define CCDC_DATAPOL_NORMAL			(0x00)
+#define CCDC_CCDCFG_FIDMD_LATCH_VSYNC		(0x00)
+#define CCDC_CCDCFG_WENLOG_AND			(0x00)
+#define CCDC_CCDCFG_TRGSEL_WEN			(0x00)
+#define CCDC_CCDCFG_EXTRG_DISABLE		(0x00)
+#define CCDC_CFA_MOSAIC				(0x00)
+
+#define CCDC_VDC_DFCVSAT_MASK			(0x3fff)
+#define CCDC_DATAOFST_MASK			(0x0ff)
+#define CCDC_DATAOFST_H_SHIFT			(0)
+#define CCDC_DATAOFST_V_SHIFT			(8)
+#define CCDC_GAMMAWD_CFA_MASK			(0x01)
+#define CCDC_GAMMAWD_CFA_SHIFT			(5)
+#define CCDC_FID_POL_MASK			(0x01)
+#define CCDC_FID_POL_SHIFT			(4)
+#define CCDC_HD_POL_MASK			(0x01)
+#define CCDC_HD_POL_SHIFT			(3)
+#define CCDC_VD_POL_MASK			(0x01)
+#define CCDC_VD_POL_SHIFT			(2)
+#define CCDC_FRM_FMT_MASK			(0x01)
+#define CCDC_FRM_FMT_SHIFT			(7)
+#define CCDC_DATA_SZ_MASK			(0x07)
+#define CCDC_DATA_SZ_SHIFT			(8)
+#define CCDC_VDHDOUT_MASK			(0x01)
+#define CCDC_VDHDOUT_SHIFT			(0)
+#define CCDC_EXWEN_MASK				(0x01)
+#define CCDC_EXWEN_SHIFT			(5)
+#define CCDC_RAW_INPUT_MASK			(0x03)
+#define CCDC_RAW_INPUT_SHIFT			(12)
+#define CCDC_PIX_FMT_MASK			(0x03)
+#define CCDC_PIX_FMT_SHIFT			(12)
+#define CCDC_DATAPOL_MASK			(0x01)
+#define CCDC_DATAPOL_SHIFT			(6)
+#define CCDC_WEN_ENABLE				(0x01 << 1)
+#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
+#define CCDC_LPF_ENABLE				(0x01 << 14)
+#define CCDC_ALAW_ENABLE			(0x01)
+#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
+
+#define CCDC_FMTCFG_FMTMODE_MASK 		(0x03)
+#define CCDC_FMTCFG_FMTMODE_SHIFT		(1)
+#define CCDC_FMTCFG_LNUM_MASK			(0x03)
+#define CCDC_FMTCFG_LNUM_SHIFT			(4)
+#define CCDC_FMTCFG_ADDRINC_MASK		(0x07)
+#define CCDC_FMTCFG_ADDRINC_SHIFT		(8)
+
+#define CCDC_CCDCFG_FIDMD_SHIFT			(6)
+#define	CCDC_CCDCFG_WENLOG_SHIFT		(8)
+#define CCDC_CCDCFG_TRGSEL_SHIFT		(9)
+#define CCDC_CCDCFG_EXTRG_SHIFT			(10)
+#define CCDC_CCDCFG_MSBINVI_SHIFT		(13)
+
+#define CCDC_HSIZE_FLIP_SHIFT			(12)
+#define CCDC_HSIZE_FLIP_MASK			(0x01)
+
+#define START_PX_HOR_MASK			(0x7FFF)
+#define NUM_PX_HOR_MASK				(0x7FFF)
+#define START_VER_ONE_MASK			(0x7FFF)
+#define START_VER_TWO_MASK			(0x7FFF)
+#define NUM_LINES_VER				(0x7FFF)
+
+#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 15)
+#define CCDC_BLK_SGAIN_MASK			(0x1F)
+#define CCDC_BLK_ST_PXL_MASK			(0x1FFF)
+#define CCDC_BLK_SAMPLE_LN_MASK			(0x03)
+#define CCDC_BLK_SAMPLE_LN_SHIFT		(13)
+
+#define CCDC_NUM_LINE_CALC_MASK			(0x03)
+#define CCDC_NUM_LINE_CALC_SHIFT		(14)
+
+#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
+#define CCDC_BLK_COMP_MASK			(0x000000FF)
+#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
+#define CCDC_BLK_COMP_GR_COMP_SHIFT		(0)
+#define CCDC_BLK_COMP_R_COMP_SHIFT		(8)
+#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
+#define CCDC_LATCH_ON_VSYNC_ENABLE		(0x00 << 15)
+#define CCDC_FPC_ENABLE				(0x01 << 15)
+#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
+#define CCDC_DATA_PACK_ENABLE			(0x01 << 11)
+#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16)
+#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16)
+#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
+#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
+#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
+#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
+#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
+
+#define CCDC_CSC_COEFF_SHIFT			(8)
+#define CCDC_CSC_COEFF_DEC_MASK			(0x0007)
+#define CCDC_CSC_COEFF_FRAC_MASK		(0x001F)
+#define CCDC_CSC_DEC_SHIFT			(5)
+#define CCDC_CSC_ENABLE				(0x01)
+#define CCDC_MFILT1_SHIFT			(10)
+#define CCDC_MFILT2_SHIFT			(8)
+#define CCDC_LPF_MASK				(0x01)
+#define CCDC_LPF_SHIFT				(14)
+#define CCDC_OFFSET_MASK			(0x3FF)
+#define CCDC_DATASFT_MASK			(0x07)
+#define CCDC_DATASFT_SHIFT			(8)
+#define CCDC_DF_ENABLE				(0x01)
+
+#define CCDC_FMTPLEN_P0_MASK			(0x000F)
+#define CCDC_FMTPLEN_P1_MASK			(0x000F)
+#define CCDC_FMTPLEN_P2_MASK			(0x0007)
+#define CCDC_FMTPLEN_P3_MASK			(0x0007)
+#define CCDC_FMTPLEN_P0_SHIFT			(0)
+#define CCDC_FMTPLEN_P1_SHIFT			(4)
+#define CCDC_FMTPLEN_P2_SHIFT			(8)
+#define CCDC_FMTPLEN_P3_SHIFT			(12)
+
+#define CCDC_FMTSPH_MASK			(0x01FFF)
+#define CCDC_FMTLNH_MASK			(0x01FFF)
+#define CCDC_FMTSLV_MASK			(0x01FFF)
+#define CCDC_FMTLNV_MASK			(0x07FFF)
+#define CCDC_FMTRLEN_MASK			(0x01FFF)
+#define CCDC_FMTHCNT_MASK			(0x01FFF)
+
+#define CCDC_ADP_INIT_MASK			(0x01FFF)
+#define CCDC_ADP_LINE_SHIFT			(13)
+#define CCDC_ADP_LINE_MASK			(0x0003)
+#define CCDC_FMTPGN_APTR_MASK			(0x0007)
+
+#define CCDC_DFCCTL_GDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_SHIFT		(4)
+#define CCDC_DFCCTL_VDFCSL_MASK			(0x03)
+#define CCDC_DFCCTL_VDFCSL_SHIFT		(5)
+#define CCDC_DFCCTL_VDFCUDA_MASK		(0x01)
+#define CCDC_DFCCTL_VDFCUDA_SHIFT		(7)
+#define CCDC_DFCCTL_VDFLSFT_MASK		(0x03)
+#define CCDC_DFCCTL_VDFLSFT_SHIFT		(8)
+#define CCDC_DFCMEMCTL_DFCMARST_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMARST_SHIFT		(2)
+#define CCDC_DFCMEMCTL_DFCMWR_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMWR_SHIFT		(0)
+
+#define CCDC_LSCCFG_GFTSF_MASK			(0x07)
+#define CCDC_LSCCFG_GFTSF_SHIFT			(1)
+#define CCDC_LSCCFG_GFTINV_MASK			(0x0f)
+#define CCDC_LSCCFG_GFTINV_SHIFT		(4)
+#define CCDC_LSC_GFTABLE_SEL_MASK		(0x03)
+#define CCDC_LSC_GFTABLE_EPEL_SHIFT		(8)
+#define CCDC_LSC_GFTABLE_OPEL_SHIFT		(10)
+#define CCDC_LSC_GFTABLE_EPOL_SHIFT		(12)
+#define CCDC_LSC_GFTABLE_OPOL_SHIFT		(14)
+#define CCDC_LSC_GFMODE_MASK			(0x03)
+#define CCDC_LSC_GFMODE_SHIFT			(4)
+#define CCDC_LSC_DISABLE			(0)
+#define CCDC_LSC_ENABLE				(1)
+#define CCDC_LSC_TABLE1_SLC			(0)
+#define CCDC_LSC_TABLE2_SLC			(1)
+#define CCDC_LSC_TABLE3_SLC			(2)
+#define CCDC_LSC_MEMADDR_RESET			(1 << 2)
+#define CCDC_LSC_MEMADDR_INCR			(0 << 2)
+#define CCDC_LSC_FRAC_MASK_T1			(0xFF)
+#define CCDC_LSC_INT_MASK			(0x03)
+#define CCDC_LSC_FRAC_MASK			(0x3FFF)
+#define CCDC_LSC_CENTRE_MASK			(0x3FFF)
+#define CCDC_LSC_COEF_MASK			(0x0ff)
+#define CCDC_LSC_COEFL_SHIFT			(0)
+#define CCDC_LSC_COEFU_SHIFT			(8)
+#define CCDC_GAIN_MASK				(0x7FF)
+#endif
+#endif				/* CCDC_DM355_H */
Index: linux-2.6.29/drivers/media/video/davinci/vpfe_capture.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/vpfe_capture.c	2009-11-20 10:08:11.622226975 -0600
@@ -0,0 +1,2251 @@
+/*
+ * Copyright (C) 2008-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <media/v4l2-common.h>
+#include <linux/io.h>
+#include <mach/cpu.h>
+#include <media/davinci/vpfe_capture.h>
+#include <media/tvp514x.h>
+static int debug;
+
+//static char *ch0_decoder = "TVP514X";
+static char *ch0_decoder = "mt9v113";
+
+static u32 ch0_numbuffers = 3;
+static u32 ch0_bufsize = (720 * 576 * 2);
+module_param(ch0_decoder, charp, S_IRUGO);
+module_param(ch0_numbuffers, uint, S_IRUGO);
+module_param(ch0_bufsize, uint, S_IRUGO);
+module_param(debug, int, 0);
+
+static struct vpfe_config_params config_params = {
+	.min_numbuffers = 3,
+	.numbuffers[0] = 3,
+	.min_bufsize[0] = 720 * 480 * 2,
+	.channel_bufsize[0] = 720 * 576 * 2,
+};
+
+static int vpfe_nr[] = { 0 };
+
+static struct vpfe_device vpfe_obj = { {NULL} };
+static struct device *vpfe_dev;
+
+static struct v4l2_capability vpfe_videocap = {
+	.driver = CAPTURE_DRV_NAME,
+	.card = "DaVinci EVM",
+	.bus_info = "Platform",
+	.version = VPFE_CAPTURE_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING
+};
+
+#define VPFE_PIXELASPECT_NTSC       {11, 10}
+#define VPFE_PIXELASPECT_PAL        {54, 59}
+
+/* standard information */
+struct vpfe_standard {
+	v4l2_std_id std_id;
+	unsigned int width;
+	unsigned int height;
+	struct v4l2_fract pixelaspect;
+	/* 0 - progressive, 1 - interlaced */
+	char frame_format;
+};
+
+struct vpfe_standard vpfe_standards[] = {
+	{V4L2_STD_NTSC,	720, 480, VPFE_PIXELASPECT_NTSC, 1},
+	{V4L2_STD_PAL,	720, 576, VPFE_PIXELASPECT_PAL, 1},
+};
+
+static int vpfe_max_standards = ARRAY_SIZE(vpfe_standards);
+
+/* Used when raw Bayer image from ccdc is directly captured to SDRAM */
+static struct vpfe_pixel_format
+ vpfe_pix_fmts[VPFE_MAX_PIX_FORMATS] = {
+	{
+		.pix_fmt = V4L2_PIX_FMT_SBGGR8,
+		.desc = "Raw Bayer GrRBGb 8bit A-Law compressed",
+		.hw_fmt = VPFE_BAYER_8BIT_PACK_ALAW,
+	},
+	{
+		.pix_fmt = V4L2_PIX_FMT_SBGGR16,
+		.desc = "Raw Bayer GrRBGb - 16bit",
+		.hw_fmt = VPFE_BAYER,
+	},
+	{
+		.pix_fmt = V4L2_PIX_FMT_SGRBG10DPCM8,
+		.desc = "Raw Bayer GrRBGb 8 bit DPCM compressed",
+		.hw_fmt = VPFE_BAYER_8BIT_PACK_DPCM,
+	},
+	{
+		.pix_fmt = V4L2_PIX_FMT_UYVY,
+		.desc = "YCbCr 4:2:2 Interleaved UYVY",
+		.hw_fmt = VPFE_UYVY,
+	},
+	{
+		.pix_fmt = V4L2_PIX_FMT_YUYV,
+		.desc = "YCbCr 4:2:2 Interleaved YUYV",
+		.hw_fmt = VPFE_YUYV,
+	},
+	{
+		.pix_fmt = V4L2_PIX_FMT_NV12,
+		.desc = "Y/CbCr 4:2:0 - Semi planar",
+		.hw_fmt = VPFE_YUV420,
+	},
+};
+
+
+static int vpfe_lookup_hw_format(u32 pix_format)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < VPFE_MAX_PIX_FORMATS; i++) {
+		if (pix_format == vpfe_pix_fmts[i].pix_fmt) {
+			ret = i;
+			break;
+		}
+	}
+	return ret;
+}
+
+static int vpfe_lookup_v4l2_pix_format(enum vpfe_hw_pix_format hw_pix)
+{
+	int i, ret = -EINVAL;
+
+	for (i = 0; i < VPFE_MAX_PIX_FORMATS; i++) {
+		if (hw_pix == vpfe_pix_fmts[i].hw_fmt) {
+			ret = i;
+			break;
+		}
+	}
+	return ret;
+}
+
+
+/*	Used when raw YUV image from ccdc is directly captured to SDRAM */
+static void vpfe_slave_device_unregister(struct v4l2_int_device *s)
+{
+	int index;
+	struct channel_obj *channel = s->u.slave->master->priv;
+
+	for (index = 0; index < VPFE_CAPTURE_NUM_DECODERS; index++) {
+		if ((channel->decoder[index] == s)
+			&& (index == channel->current_decoder)) {
+			if (channel->common->started) {
+				/* Streaming is ON. So return busy */
+				v4l2_err(vpfe_dev->driver,
+					"Steaming ON. Cannot unregister"
+					"decoder %s\n", s->name);
+				return;
+			} else {
+				channel->decoder[index] = NULL;
+				channel->numdecoders--;
+				break;
+			}
+		}
+	}
+	if (index == VPFE_CAPTURE_NUM_DECODERS)
+		v4l2_err(vpfe_dev->driver,
+			"No matching decoder registered"
+			"decoder %s\n", s->name);
+}
+
+static int vpfe_get_stdinfo(struct channel_obj *ch, v4l2_std_id *std_id)
+{
+	int i;
+	struct video_obj *vid_ch = NULL;
+
+	vid_ch = &(ch->video);
+
+	for (i = 0; i < vpfe_max_standards; i++) {
+		if (vpfe_standards[i].std_id == *std_id) {
+			vid_ch->std_info.activepixels =
+					vpfe_standards[i].width;
+			vid_ch->std_info.activelines =
+					vpfe_standards[i].height;
+			vid_ch->std_info.frame_format =
+					vpfe_standards[i].frame_format;
+			vid_ch->index = i;
+			break;
+		}
+	}
+	if (i == vpfe_max_standards) {
+		v4l2_err(vpfe_dev->driver, "standard not supported\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+/*	vpfe_device_register: Used for registering a slave decoder
+ *	device with master
+ */
+static int vpfe_slave_device_register(struct v4l2_int_device *s)
+{
+	struct channel_obj *channel = s->u.slave->master->priv;
+	struct common_obj *common = &channel->common[VPFE_VIDEO_INDEX];
+	int err = 0, index;
+	dev_notice(vpfe_dev, "register slave %s \n", s->name);
+	if (ISNULL(channel))
+		return -EINVAL;
+
+	if (!channel->numdecoders) {
+		if (!vidioc_int_dev_init(s)) {
+			channel->current_decoder = 0;
+			channel->decoder[channel->current_decoder] = s;
+			v4l2_info(vpfe_dev->driver, "Current decoder is set to"
+				 " %s\n", (s->name));
+		}
+	} else {
+		/* search through the array for an empty entry */
+		for (index = 0; index < VPFE_CAPTURE_NUM_DECODERS; index++) {
+			if (ISNULL(channel->decoder[index])) {
+				channel->decoder[index] = s;
+				break;
+			}
+		}
+		if (index == VPFE_CAPTURE_NUM_DECODERS) {
+			v4l2_err(vpfe_dev->driver,
+				"decoder count reached"
+				" maximum allowed\n");
+			return -ENOMEM;
+		}
+		if (!strncmp(ch0_decoder, s->name, strlen(ch0_decoder))) {
+			if (!common->started) {
+				if (!vidioc_int_dev_init(s)) {
+					channel->current_decoder = index;
+					v4l2_info(vpfe_dev->driver,
+						"Current decoder is"
+						" set to %s\n", (s->name));
+				}
+			}
+		}
+	}
+	channel->numdecoders++;
+	return err;
+}
+
+/*	vpfe capture master. All slave decoders registers
+ *	with master using vpfe_device_register and deregisters
+ *	using vpfe_slave_device_unregister
+ */
+static struct v4l2_int_master vpfe_master = {
+	.attach = vpfe_slave_device_register,
+	.detach = vpfe_slave_device_unregister,
+};
+
+static struct v4l2_int_device vpfe_capture = {
+	.module	= THIS_MODULE,
+	.name	= CAPTURE_DRV_NAME,
+	.type	= v4l2_int_type_master,
+	.u	= {
+		.master = &vpfe_master
+	},
+};
+
+/* Call this after storing ifparams in channel block */
+static int vpfe_set_hw_if_type(struct channel_obj *channel)
+{
+	struct vpfe_capture_input *input = channel->video.input;
+
+	switch (input->inputs[input->current_input].route.output) {
+	case OUTPUT_10BIT_422_EMBEDDED_SYNC:
+		channel->vpfe_if = VPFE_BT656;
+		break;
+	case OUTPUT_20BIT_422_SEPERATE_SYNC:
+		channel->vpfe_if = VPFE_YCBCR_SYNC_16;
+		break;
+	case OUTPUT_10BIT_422_SEPERATE_SYNC:
+		channel->vpfe_if = VPFE_YCBCR_SYNC_8;
+	default:
+		v4l2_err(vpfe_dev->driver, "decoder output"
+			" not supported, %d\n",
+			input->inputs[input->current_input].route.output);
+		return -EFAULT;
+	}
+	return ccdc_hw_dev.set_hw_if_type(channel->vpfe_if);
+}
+
+static int vpfe_get_image_format(struct v4l2_format *f)
+{
+	struct v4l2_rect image_win;
+	enum ccdc_buftype buf_type;
+	enum ccdc_frmfmt frm_fmt;
+	enum vpfe_hw_pix_format hw_pix;
+	int ret = 0;
+
+	memset(f, 0, sizeof(struct v4l2_format));
+	f->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	ccdc_hw_dev.get_image_window(&image_win);
+	f->fmt.pix.width = image_win.width;
+	f->fmt.pix.height = image_win.height;
+	ccdc_hw_dev.get_line_length(&f->fmt.pix.bytesperline);
+	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline *
+				f->fmt.pix.height;
+	ccdc_hw_dev.get_buftype(&buf_type);
+	ccdc_hw_dev.get_pixelformat(&hw_pix);
+
+	if (hw_pix == VPFE_BAYER)
+		f->fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR16;
+	else if (hw_pix == VPFE_BAYER_8BIT_PACK_ALAW)
+		f->fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	else if (hw_pix == VPFE_UYVY)
+		f->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+	else if (hw_pix == VPFE_YUYV)
+		f->fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
+	else {
+		v4l2_err(vpfe_dev->driver, "Invalid HW pix format detected");
+		ret =  -EINVAL;
+		goto out;
+	}
+	ccdc_hw_dev.get_frame_format(&frm_fmt);
+	if (frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
+		f->fmt.pix.field = V4L2_FIELD_NONE;
+	else if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED)
+			f->fmt.pix.field = V4L2_FIELD_INTERLACED;
+		else if (buf_type == CCDC_BUFTYPE_FLD_SEPARATED)
+			f->fmt.pix.field = V4L2_FIELD_SEQ_TB;
+		else
+			ret = -EINVAL;
+	} else
+		ret =  -EINVAL;
+out:
+	return ret;
+}
+
+/*	vpfe_config_default_format: Update format information */
+static int vpfe_config_default_format(struct channel_obj *ch)
+{
+	struct common_obj *common = &(ch->common[VPFE_VIDEO_INDEX]);
+	struct v4l2_int_device *dec = ch->decoder[ch->current_decoder];
+	struct v4l2_rect win;
+	int err = 0;
+	struct video_obj *vid_ch = NULL;
+
+	vid_ch = &(ch->video);
+	common->crop.top = 0;
+	common->crop.left = 0;
+	/* first get format information from the decoder.
+	 * if not available, get it from CCDC
+	 */
+	if ((vidioc_int_g_fmt_cap(dec, &common->fmt)) < 0)
+		vpfe_get_image_format(&common->fmt);
+	else {
+		/* set up all parameters in CCDC */
+		win.top = common->crop.top;
+		win.left = common->crop.left;
+		win.width = common->fmt.fmt.pix.width;
+		win.height = common->fmt.fmt.pix.height;
+		ccdc_hw_dev.set_image_window(&win);
+		if (common->fmt.fmt.pix.field ==
+		    V4L2_FIELD_INTERLACED) {
+			err |=
+			ccdc_hw_dev.set_buftype(CCDC_BUFTYPE_FLD_INTERLEAVED);
+			err |=
+			ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_INTERLACED);
+		} else if (common->fmt.fmt.pix.field ==
+			   V4L2_FIELD_SEQ_TB) {
+			err |=
+			ccdc_hw_dev.set_buftype(CCDC_BUFTYPE_FLD_SEPARATED);
+			err |=
+			ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_INTERLACED);
+		} else if (common->fmt.fmt.pix.field ==
+			   V4L2_FIELD_NONE) {
+			err |=
+			ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_PROGRESSIVE);
+		} else {
+			v4l2_dbg(1, debug, vpfe_dev->driver,
+				"\n Decoder field not supported!");
+			err = -EINVAL;
+			goto out;
+		}
+	}
+	/* set the crop limits */
+	vid_ch->std_info.activepixels = common->fmt.fmt.pix.width;
+	vid_ch->std_info.activelines = common->fmt.fmt.pix.height;
+	if (config_params.numbuffers[ch->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+out:
+	return err;
+}
+
+static int vpfe_initialize_channel(struct channel_obj *channel,
+	struct v4l2_int_device *dec)
+{
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	int err = 0;
+
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	vid_ch = &(channel->video);
+	channel->out_from = VPFE_CCDC_OUT;
+	vid_ch->input->current_input = 0;
+
+	err = vidioc_int_g_ifparm(dec, &channel->ifparams);
+	if (err) {
+		v4l2_err(vpfe_dev->driver,
+			"vidioc_int_g_ifparm failed with %d\n", err);
+		return err;
+	}
+
+	err = vpfe_set_hw_if_type(channel);
+	if (err)
+		return err;
+
+	/* Initialize decoder by calling initialize function */
+	err = vidioc_int_s_power(dec, 1);
+	if (err) {
+		v4l2_err(vpfe_dev->driver,
+			"unable to power on the decoder, %s, error %d\n",
+			dec->name,
+			err);
+		return err;
+	}
+
+	err = vidioc_int_init(dec);
+	if (err) {
+		v4l2_err(vpfe_dev->driver,
+			"cannot initialize decoder - error %d\n",
+			err);
+		return err;
+	}
+
+	/* Configure the default format information */
+	err = vpfe_config_default_format(channel);
+
+	/* now open the ccdc device to initialize it */
+	ccdc_hw_dev.open(vpfe_dev);
+	channel->initialized = 1;
+	return err;
+}
+
+/*	vpfe_open : It creates object of file handle structure and
+ *	stores it in private_data  member of filepointer
+ */
+static int vpfe_open(struct file *filep)
+{
+	int minor = iminor(filep->f_path.dentry->d_inode);
+	struct channel_obj *channel = NULL;
+	struct v4l2_int_device *dec = NULL;
+	struct common_obj *common = NULL;
+	struct vpfe_fh *fh = NULL;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "vpfe_open\n");
+
+	/* Check for valid minor number */
+	channel = vpfe_obj.dev[0];
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	if (minor != channel->video_dev->minor) {
+		v4l2_err(vpfe_dev->driver, "device not found\n");
+		return -ENODEV;
+	}
+
+	if (!channel->numdecoders) {
+		v4l2_err(vpfe_dev->driver, "No decoder registered\n");
+		return -ENODEV;
+	}
+
+	dec = channel->decoder[channel->current_decoder];
+
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpfe_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		v4l2_err(vpfe_dev->driver,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = channel;
+	fh->initialized = 0;
+	/* If decoder is not initialized. initialize it */
+	if (!channel->initialized) {
+		if (vpfe_initialize_channel(channel, dec))
+			return -ENODEV;
+		fh->initialized = 1;
+	}
+	/* Increment channel usrs counter */
+	channel->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed[VPFE_VIDEO_INDEX] = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&channel->prio, &fh->prio);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_open>\n");
+	return 0;
+}
+
+/*ISR for VINT0*/
+static irqreturn_t vpfe_isr(int irq, void *dev_id)
+{
+	struct timeval timevalue;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	struct vpfe_device *dev = dev_id;
+	unsigned long addr;
+	int fid;
+	enum v4l2_field field;
+	channel = dev->dev[VPFE_CHANNEL0_VIDEO];
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	vid_ch = &(channel->video);
+	field = common->fmt.fmt.pix.field;
+	do_gettimeofday(&timevalue);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "\nStarting vpfe_isr...");
+
+	/* only for 6446 this will be applicable */
+	if (!(ISNULL(ccdc_hw_dev.reset)))
+		ccdc_hw_dev.reset();
+
+	if (field == V4L2_FIELD_INTERLACED ||
+	    (field == V4L2_FIELD_SEQ_TB)) {
+		/* Interlaced */
+		/* check which field we are in hardware */
+		fid = ccdc_hw_dev.getfid();
+		/* switch the software maintained field id */
+		channel->field_id ^= 1;
+		v4l2_dbg(1, debug, vpfe_dev->driver, "field id = %x:%x.\n", fid,
+			channel->field_id);
+		if (fid == channel->field_id) {
+			/* we are in-sync here,continue */
+			if (fid == 0) {
+				/* One frame is just being captured. If the
+				 * next frame is available, release the current
+				 * frame and move on
+				 */
+				if (common->curFrm != common->nextFrm) {
+					/* Copy frame capture time value in
+					 * curFrm->ts
+					 */
+					common->curFrm->ts = timevalue;
+					common->curFrm->state = VIDEOBUF_DONE;
+					wake_up_interruptible(&common->curFrm->
+							      done);
+					common->curFrm = common->nextFrm;
+				}
+				/* based on whether the two fields are stored
+				 * interleavely or separately in memory,
+				 * reconfigure the CCDC memory address
+				 */
+				if (channel->out_from == VPFE_CCDC_OUT &&
+				    field == V4L2_FIELD_SEQ_TB) {
+					addr =
+					videobuf_to_dma_contig(common->curFrm);
+					addr += common->field_off;
+					ccdc_hw_dev.setfbaddr(addr);
+				}
+			} else if (fid == 1) {
+				/* if one field is just being captured
+				 * configure the next frame
+				 * get the next frame from the empty queue
+				 * if no frame is available
+				 * hold on to the current buffer
+				 */
+				if (channel->out_from == VPFE_CCDC_OUT &&
+				    !list_empty(&common->dma_queue) &&
+				    common->curFrm == common->nextFrm) {
+					common->nextFrm =
+						list_entry(common->
+							   dma_queue.next,
+							   struct
+							   videobuf_buffer,
+							   queue);
+					list_del(&common->nextFrm->queue);
+					common->nextFrm->state =
+						VIDEOBUF_ACTIVE;
+					addr = videobuf_to_dma_contig(common->
+								      nextFrm);
+					ccdc_hw_dev.setfbaddr(addr);
+				}
+			}
+		} else if (fid == 0) {
+			/* recover from any hardware out-of-sync due to
+			 * possible switch of video source
+			 * for fid == 0, sync up the two fids
+			 * for fid == 1, no action, one bad frame will
+			 * go out, but it is not a big deal
+			 */
+			channel->field_id = fid;
+		}
+	} else if (field == V4L2_FIELD_NONE) {
+
+		v4l2_dbg(1, debug, vpfe_dev->driver,
+			"\nframe format is progressive...");
+		if (common->curFrm != common->nextFrm) {
+			/* Copy frame capture time value in curFrm->ts */
+			common->curFrm->ts = timevalue;
+			common->curFrm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&common->curFrm->done);
+			common->curFrm = common->nextFrm;
+		}
+
+	}
+	v4l2_dbg(1, debug, vpfe_dev->driver, "interrupt returned.\n");
+	return IRQ_RETVAL(1);
+}
+
+static irqreturn_t vdint1_isr(int irq, void *dev_id)
+{
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct vpfe_device *dev = dev_id;
+	unsigned long addr;
+	channel = dev->dev[VPFE_CHANNEL0_VIDEO];
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "\nInside vdint1_isr...");
+
+	if ((common->fmt.fmt.pix.field == V4L2_FIELD_NONE) &&
+	    !list_empty(&common->dma_queue) &&
+	    common->curFrm == common->nextFrm) {
+		common->nextFrm =
+		    list_entry(common->dma_queue.next,
+			       struct videobuf_buffer, queue);
+		list_del(&common->nextFrm->queue);
+		common->nextFrm->state = VIDEOBUF_ACTIVE;
+		addr = videobuf_to_dma_contig(common->nextFrm);
+		ccdc_hw_dev.setfbaddr(addr);
+	}
+	return IRQ_RETVAL(1);
+}
+
+static int vpfe_detach_irq(struct channel_obj *channel)
+{
+	enum ccdc_frmfmt frame_format;
+	int err = 0;
+
+	/* First clear irq if already in use */
+	switch (channel->irq_type) {
+	case VPFE_USE_CCDC_IRQ:
+		ccdc_hw_dev.get_frame_format(&frame_format);
+		if (frame_format == CCDC_FRMFMT_PROGRESSIVE)
+			free_irq(IRQ_VDINT1, &vpfe_obj);
+		channel->irq_type = VPFE_NO_IRQ;
+		break;
+	case VPFE_NO_IRQ:
+		break;
+	default:
+		return -1;
+	}
+	return err;
+}
+
+static int vpfe_attach_irq(struct channel_obj *channel)
+{
+	enum ccdc_frmfmt frame_format;
+	int err = 0;
+
+	channel->irq_type = VPFE_USE_CCDC_IRQ;
+
+	switch (channel->irq_type) {
+	case VPFE_USE_CCDC_IRQ:
+		{
+			ccdc_hw_dev.get_frame_format(&frame_format);
+			if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+				err =
+					request_irq(channel->ccdc_irq1,
+						    vdint1_isr,
+						     IRQF_DISABLED,
+						     "vpfe_capture1",
+						     (void *)&vpfe_obj);
+				if (err < 0)
+					return -1;
+			}
+		}
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/* vpfe_release : This function deletes buffer queue, frees the
+ * buffers and the vpfe file  handle
+ */
+static int vpfe_release(struct file *filep)
+{
+	int ret;
+	struct common_obj *common = NULL;
+	/* Get the channel object and file handle object */
+	struct vpfe_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct v4l2_int_device *dec =
+			channel->decoder[channel->current_decoder];
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_release>\n");
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	/* If this is doing IO and other channels are not closed */
+	if ((channel->usrs != 1) && fh->io_allowed[VPFE_VIDEO_INDEX]) {
+		v4l2_err(vpfe_dev->driver, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on channel object */
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		return ret;
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPFE_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		if (common->started) {
+			ccdc_hw_dev.enable(0);
+			if (ccdc_hw_dev.enable_out_to_sdram)
+				ccdc_hw_dev.enable_out_to_sdram(0);
+			if (vpfe_detach_irq(channel) < 0) {
+				v4l2_err(vpfe_dev->driver,
+					"Error in detaching IRQ\n");
+				mutex_unlock(&common->lock);
+				return -EFAULT;
+			}
+		}
+
+		common->io_usrs = 0;
+		/* Disable channel/vbi as per its device type and channel id */
+		common->started = 0;
+		/* Free buffers allocated */
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+	}
+
+	/* Decrement channel usrs counter */
+	channel->usrs--;
+	/* unlock semaphore on channel object */
+	mutex_unlock(&common->lock);
+	/* Close the priority */
+	v4l2_prio_close(&channel->prio, &fh->prio);
+	/* If this file handle has initialize decoder device, reset it */
+	if (fh->initialized) {
+		vidioc_int_s_power(dec, 0);
+		channel->initialized = 0;
+		if (ccdc_hw_dev.close)
+			ccdc_hw_dev.close(vpfe_dev);
+	}
+	filep->private_data = NULL;
+	/* Free memory allocated to file handle object */
+	kfree(fh);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_release>\n");
+	return 0;
+}
+
+/*  vpfe_mmap : It is used to map kernel space buffers
+ *  into user spaces
+ */
+static int vpfe_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the channel object and file handle object */
+	struct vpfe_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	int err = 0;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "Start of vpfe mmap\n");
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+	v4l2_dbg(1, debug, vpfe_dev->driver, "End of vpfe mmap\n");
+	return err;
+}
+
+/* vpfe_poll: It is used for select/poll system call
+ */
+static unsigned int vpfe_poll(struct file *filep, poll_table *wait)
+{
+	int err = 0;
+	struct vpfe_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_poll>");
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_poll>");
+	return err;
+}
+
+/* vpfe capture driver file operations */
+static struct v4l2_file_operations vpfe_fops = {
+	.owner = THIS_MODULE,
+	.open = vpfe_open,
+	.release = vpfe_release,
+	.ioctl = video_ioctl2,
+	.mmap = vpfe_mmap,
+	.poll = vpfe_poll
+};
+
+static  struct vpfe_pixel_format *
+	vpfe_check_format(struct channel_obj *channel,
+			  struct v4l2_pix_format *pixfmt,
+			  int check)
+{
+	struct common_obj *common = &(channel->common[VPFE_VIDEO_INDEX]);
+	struct video_obj *vid_ch = &(channel->video);
+	struct vpfe_pixel_format *pix_fmt;
+	enum vpfe_hw_pix_format hw_pix;
+	int temp, found, hpitch, vpitch, bpp, min_height = 1,
+		min_width = 32, max_width, max_height;
+
+
+	temp = vpfe_lookup_hw_format(pixfmt->pixelformat);
+	if (temp < 0) {
+		if (check) {
+			v4l2_err(vpfe_dev->driver, "invalid pixel format\n");
+			return NULL;
+		}
+		/* if invalid and this is a try format, then use hw default */
+		pixfmt->pixelformat = common->fmt.fmt.pix.pixelformat;
+		/* Since this is hw default, we will find this pix format */
+		temp = vpfe_lookup_hw_format(pixfmt->pixelformat);
+
+	} else {
+		/* check if hw supports it */
+		pix_fmt = &vpfe_pix_fmts[temp];
+		temp = 0;
+		found = 0;
+		while (ccdc_hw_dev.enum_pix(&hw_pix, temp) >= 0) {
+			if (pix_fmt->hw_fmt == hw_pix) {
+				found = 1;
+				break;
+			}
+			temp++;
+		}
+		if (!found) {
+			if (check) {
+				v4l2_err(vpfe_dev->driver, "hw doesn't"
+					 "support the pixel format\n");
+				return NULL;
+			}
+			/* Since this is hw default, we will find this
+			 * pix format
+			 */
+			pixfmt->pixelformat = common->fmt.fmt.pix.pixelformat;
+			temp = vpfe_lookup_hw_format(pixfmt->pixelformat);
+		}
+	}
+	pix_fmt = &vpfe_pix_fmts[temp];
+	if (pixfmt->field == V4L2_FIELD_ANY) {
+		/* if ANY set the field to match with decoder */
+		pixfmt->field = common->fmt.fmt.pix.field;
+	}
+
+	/* Try matching the field with the decoder scan field */
+	if (common->fmt.fmt.pix.field != pixfmt->field) {
+		if (!(VPFE_VALID_FIELD(pixfmt->field)) && check) {
+			v4l2_err(vpfe_dev->driver, "invalid field format\n");
+			return NULL;
+		}
+		if (common->fmt.fmt.pix.field == V4L2_FIELD_INTERLACED) {
+			if (pixfmt->field != V4L2_FIELD_SEQ_TB) {
+				if (check) {
+					v4l2_err(vpfe_dev->driver,
+						"invalid field format\n");
+					return NULL;
+				}
+				pixfmt->field = common->fmt.fmt.pix.field;
+			}
+		} else if (common->fmt.fmt.pix.field == V4L2_FIELD_NONE) {
+			if (check) {
+				v4l2_err(vpfe_dev->driver,
+					"invalid field format\n");
+				return NULL;
+			}
+			pixfmt->field = common->fmt.fmt.pix.field;
+		} else
+			pixfmt->field = common->fmt.fmt.pix.field;
+	}
+
+	if (pixfmt->field == V4L2_FIELD_INTERLACED)
+		min_height = 2;
+
+	max_width = vid_ch->std_info.activepixels;
+	max_height = vid_ch->std_info.activelines;
+	if ((pixfmt->pixelformat == V4L2_PIX_FMT_SBGGR8) ||
+	   (pixfmt->pixelformat == V4L2_PIX_FMT_NV12) ||
+	   (pixfmt->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8))
+		bpp = 1;
+	else
+		bpp = 2;
+	min_width /= bpp;
+	hpitch = pixfmt->width;
+	vpitch = pixfmt->height;
+	v4l2_info(vpfe_dev->driver, "hpitch = %d, vpitch = %d, bpp = %d\n",
+		  hpitch, vpitch, bpp);
+	if (hpitch < min_width)
+		hpitch = min_width;
+	if (vpitch < min_width)
+		vpitch = min_height;
+
+	/* Check for upper limits of pitch */
+	if (hpitch > max_width)
+		hpitch = max_width;
+	if (vpitch > max_height)
+		vpitch = max_height;
+
+	/* recalculate bytesperline and sizeimage since width
+	 * and height might have changed
+	 */
+	pixfmt->bytesperline = (((hpitch * bpp) + 31) & ~31);
+	if (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)
+		pixfmt->sizeimage = pixfmt->bytesperline * vpitch +
+				    ((pixfmt->bytesperline * vpitch) >> 1);
+	else
+		pixfmt->sizeimage = pixfmt->bytesperline * vpitch;
+	pixfmt->width = hpitch;
+	pixfmt->height = vpitch;
+	v4l2_info(vpfe_dev->driver, "adjusted hpitch = %d, vpitch ="
+		  " %d, bpp = %d\n", hpitch, vpitch, bpp);
+	return pix_fmt;
+}
+
+static int vpfe_querycap(struct file *file, void  *priv,
+			       struct v4l2_capability *cap)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_QUERYCAP\n");
+	memset(cap, 0, sizeof(*cap));
+	if ((VPFE_CHANNEL0_VIDEO == channel->channel_id))
+		*cap = vpfe_videocap;
+	else
+		return -EINVAL;
+	return 0;
+}
+
+static int vpfe_g_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_G_FMT\n");
+	/* Fill in the information about
+	 * format
+	 */
+	ret = mutex_lock_interruptible(&(common->lock));
+	if (ret)
+		goto lock_out;
+	*fmt = common->fmt;
+lock_out:
+	mutex_unlock(&(common->lock));
+	return ret;
+}
+
+static int vpfe_enum_fmt_vid_cap(struct file *file, void  *priv,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int ret;
+	enum vpfe_hw_pix_format hw_pix;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_ENUM_FMT\n");
+	/* Fill in the information about format */
+	fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	ret = ccdc_hw_dev.enum_pix(&hw_pix, fmt->index);
+	if (!ret) {
+		ret = vpfe_lookup_v4l2_pix_format(hw_pix);
+		if (ret >= 0) {
+			strcpy(fmt->description, vpfe_pix_fmts[ret].desc);
+			fmt->pixelformat = vpfe_pix_fmts[ret].pix_fmt;
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+static int vpfe_s_fmt_vid_cap(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	struct v4l2_rect win;
+	struct vpfe_pixel_format *pix_fmts;
+	int ret = 0;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_S_FMT\n");
+	/* If streaming is started, return error */
+	if (common->started) {
+		v4l2_err(vpfe_dev->driver, "Streaming is started\n");
+		ret = -EBUSY;
+		goto out;
+	}
+	/* Check for valid frame format */
+	pix_fmts = vpfe_check_format(channel, &fmt->fmt.pix, 1);
+
+	if (ISNULL(pix_fmts)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* store the pixel format in the channel
+	 * object */
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+
+	/* First detach any IRQ if currently attached */
+	if (vpfe_detach_irq(channel) < 0) {
+		v4l2_err(vpfe_dev->driver, "Error in detaching IRQ\n");
+		ret = -EFAULT;
+		goto lock_out;
+	}
+
+	common->fmt = *fmt;
+
+	/* we are using same variable for setting crop window
+	 * at ccdc. For ccdc, this is same as
+	 * image window
+	 */
+	ccdc_hw_dev.get_image_window(&win);
+	win.width = common->fmt.fmt.pix.width;
+	win.height = common->fmt.fmt.pix.height;
+	ccdc_hw_dev.set_image_window(&win);
+
+	/* In this case, image window and crop window are
+	 * the same
+	 */
+	if (common->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR16)
+		ccdc_hw_dev.set_pixelformat(VPFE_BAYER);
+	else if (common->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_SBGGR8)
+		ccdc_hw_dev.set_pixelformat(VPFE_BAYER_8BIT_PACK_ALAW);
+	else if (common->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_UYVY)
+		ccdc_hw_dev.set_pixelformat(VPFE_UYVY);
+	else if (common->fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
+		ccdc_hw_dev.set_pixelformat(VPFE_YUYV);
+	else {
+		/* invalid pix format */
+		ret = -EINVAL;
+		goto lock_out;
+	}
+	if (common->fmt.fmt.pix.field ==
+	    V4L2_FIELD_INTERLACED) {
+		ccdc_hw_dev.set_buftype(CCDC_BUFTYPE_FLD_INTERLEAVED);
+		ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_INTERLACED);
+	} else if (common->fmt.fmt.pix.field ==
+		   V4L2_FIELD_SEQ_TB) {
+		ccdc_hw_dev.set_buftype(CCDC_BUFTYPE_FLD_SEPARATED);
+		ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_INTERLACED);
+	} else if (common->fmt.fmt.pix.field == V4L2_FIELD_NONE)
+		ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_PROGRESSIVE);
+	else {
+		v4l2_err(vpfe_dev->driver, "\n field error!");
+		ret = -EINVAL;
+	}
+lock_out:
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+static int vpfe_try_fmt_vid_cap(struct file *file, void *priv,
+				  struct v4l2_format *f)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct vpfe_pixel_format *pix_fmts;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_TRY_FMT\n");
+
+	pix_fmts = vpfe_check_format(channel, &f->fmt.pix, 0);
+	if (ISNULL(pix_fmts))
+		return -EINVAL;
+	return 0;
+}
+
+static void vpfe_config_format(struct channel_obj *ch)
+{
+	struct common_obj *common = &(ch->common[VPFE_VIDEO_INDEX]);
+	struct v4l2_rect win;
+	struct video_obj *vid_ch = NULL;
+
+	vid_ch = &(ch->video);
+	common->crop.top = 0;
+	common->crop.top = 0;
+	common->crop.width = common->fmt.fmt.pix.width =
+			vid_ch->std_info.activepixels;
+	common->crop.height = common->fmt.fmt.pix.height =
+			vid_ch->std_info.activelines;
+	win.top = common->crop.top;
+	win.left = common->crop.left;
+	win.width = common->fmt.fmt.pix.width;
+	win.height = common->fmt.fmt.pix.height;
+	ccdc_hw_dev.set_image_window(&win);
+	if (vid_ch->std_info.frame_format) {
+		common->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
+		ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_INTERLACED);
+		ccdc_hw_dev.set_buftype(CCDC_BUFTYPE_FLD_INTERLEAVED);
+	} else {
+		common->fmt.fmt.pix.field = V4L2_FIELD_NONE;
+		ccdc_hw_dev.set_frame_format(CCDC_FRMFMT_PROGRESSIVE);
+	}
+	ccdc_hw_dev.get_line_length(&common->fmt.fmt.pix.bytesperline);
+	common->fmt.fmt.pix.sizeimage = common->fmt.fmt.pix.bytesperline *
+				    common->fmt.fmt.pix.height;
+}
+
+static int vpfe_enum_input(struct file *file, void *priv,
+				 struct v4l2_input *inp)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct vpfe_capture_input *vpfe_inputs = channel->video.input;
+	int ret = -EINVAL;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_ENUMINPUT\n");
+
+	if (inp->index > vpfe_inputs->num_inputs)
+		return ret;
+
+	if (vpfe_inputs->inputs[inp->index].input.name[0]) {
+		memcpy(inp, &vpfe_inputs->inputs[inp->index].input,
+			sizeof(struct v4l2_input));
+		return 0;
+	}
+	return ret;
+}
+
+static int vpfe_g_input(struct file *file, void *priv, unsigned int *index)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common =
+			    &(channel->common[VPFE_VIDEO_INDEX]);
+	struct vpfe_capture_input *vpfe_inputs = channel->video.input;
+	int ret = 0;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_G_INPUT\n");
+	ret = mutex_lock_interruptible(&common->lock);
+	if (!ret)
+		*index = vpfe_inputs->current_input;
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+
+static int vpfe_s_input(struct file *file, void *priv, unsigned int index)
+{
+	int i, ret = -EINVAL;
+	v4l2_std_id std_id;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct v4l2_int_device *new_dec, *curr_dec =
+		channel->decoder[channel->current_decoder];
+	struct common_obj *common =
+			    &(channel->common[VPFE_VIDEO_INDEX]);
+	struct vpfe_capture_input *vpfe_inputs = channel->video.input;
+	char *new_dec_name;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_S_INPUT\n");
+	if (index > vpfe_inputs->num_inputs) {
+		v4l2_err(vpfe_dev->driver, "input index exceeds limit\n");
+		return ret;
+	}
+
+	if (!vpfe_inputs->inputs[index].input.name[0]) {
+		v4l2_err(vpfe_dev->driver, "input index exceeds limit\n");
+		return ret;
+	}
+
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	/* If streaming is started return device busy
+	 * error
+	 */
+	if (common->started) {
+		v4l2_err(vpfe_dev->driver, "Streaming is on\n");
+		ret = -EBUSY;
+		goto lock_out;
+	}
+	new_dec_name = vpfe_inputs->inputs[index].dec_name;
+	/* switch in new decoder to be active */
+	if (strcmp(new_dec_name, curr_dec->name)) {
+		for (i = 0; i < VPFE_CAPTURE_NUM_DECODERS; i++) {
+			if (channel->decoder[i] &&
+				!strcmp(new_dec_name,
+					channel->decoder[i]->name)) {
+				new_dec = channel->decoder[i];
+				channel->current_decoder = i;
+				/* Deinitialize the previous decoder
+				 * and power down
+				 */
+				vidioc_int_s_power(curr_dec, 0);
+
+				ret = vidioc_int_s_power(new_dec, 1);
+				if (ret)
+					goto lock_out;
+				ret = vidioc_int_init(new_dec);
+				if (ret)
+					goto lock_out;
+				curr_dec = new_dec;
+			}
+		}
+
+		if (i == VPFE_CAPTURE_NUM_DECODERS)
+			/* couldn't find the decoder */
+			goto lock_out;
+	}
+	ret = 0;
+	/* Set the input in the decoder */
+	if (vpfe_inputs->inputs[index].routing_supported)
+		ret = vidioc_int_s_video_routing(curr_dec,
+				&vpfe_inputs->inputs[index].route);
+
+	if (ret) {
+		v4l2_err(vpfe_dev->driver,
+			"vpfe_doioctl:error in setting input in decoder \n");
+		ret = -EINVAL;
+		goto lock_out;
+	}
+
+	vpfe_inputs->current_input = index;
+	ret = vpfe_set_hw_if_type(channel);
+	if (ret)
+		goto lock_out;
+
+	ret = vpfe_config_default_format(channel);
+	if (ret)
+		goto lock_out;
+
+	/* Detect default standard */
+	ret = vidioc_int_querystd(curr_dec, &std_id);
+	if (!ret)
+		ret = vpfe_get_stdinfo(channel, &std_id);
+
+	if (ret)
+		goto lock_out;
+
+	vpfe_config_format(channel);
+lock_out:
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+static int vpfe_querystd(struct file *file, void *priv, v4l2_std_id *std_id)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common =
+			    &(channel->common[VPFE_VIDEO_INDEX]);
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto lock_out;
+	/* Call querystd function of decoder device */
+	ret = vidioc_int_querystd(dec, std_id);
+	/* Set format based on the standard selected */
+	if (!ret)
+		ret = vpfe_get_stdinfo(channel, std_id);
+	vpfe_config_format(channel);
+lock_out:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpfe_s_std(struct file *file, void *priv, v4l2_std_id *std_id)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common =
+	    &(channel->common[VPFE_VIDEO_INDEX]);
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_S_STD\n");
+
+	/* If streaming is started, return device
+	   busy error */
+	if (common->started) {
+		v4l2_err(vpfe_dev->driver, "streaming is started\n");
+		ret = -EBUSY;
+		goto out;
+	}
+	/* Call decoder driver function to set the
+	   standard */
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	ret = vidioc_int_s_std(dec, std_id);
+
+	/* If it returns error, return error */
+	if (!ret)
+		ret = vpfe_get_stdinfo(channel, std_id);
+
+	if (!ret)
+		vpfe_config_format(channel);
+out:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpfe_g_std(struct file *file, void *priv, v4l2_std_id *std_id)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	int ret;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_G_STD\n");
+	ret = vidioc_int_querystd(dec, std_id);
+	if (ret)
+		goto out;
+
+	ret = vpfe_get_stdinfo(channel, std_id);
+	if (!ret)
+		vpfe_config_format(channel);
+out:
+	return ret;
+}
+/*
+ *  Videobuf operations
+ */
+static int vpfe_videobuf_setup(struct videobuf_queue *vq,
+				unsigned int *count,
+				unsigned int *size)
+{
+	/* Get the file handle object and channel object */
+	struct vpfe_fh *fh = vq->priv_data;
+	struct channel_obj *channel = fh->channel;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_buffer_setup>\n");
+	*size = config_params.channel_bufsize[channel->channel_id];
+
+	if (*count < config_params.min_numbuffers)
+		*count = config_params.min_numbuffers;
+	v4l2_dbg(1, debug, vpfe_dev->driver,
+		"count=%d, size=%d\n", *count, *size);
+	return 0;
+}
+
+static int vpfe_videobuf_prepare(struct videobuf_queue *vq,
+				struct videobuf_buffer *vb,
+				enum v4l2_field field)
+{
+	int ret = 0;
+	/* Get the file handle object and channel object */
+	struct vpfe_fh *fh = vq->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	unsigned long addr;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_buffer_prepare>\n");
+
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		/* we don't support user ptr IO */
+		v4l2_dbg(1, debug, vpfe_dev->driver,
+			"<vpfe_buffer_prepare: USERPTR IO"
+			" not supported>\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* If buffer is not initialized, initialize it */
+	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+		vb->width = common->width;
+		vb->height = common->height;
+		vb->size = vb->width * vb->height * 2;
+		vb->field = field;
+	}
+	addr = videobuf_to_dma_contig(vb);
+	if (vq->streaming) {
+		if (!ISALIGNED(addr)) {
+			v4l2_err(vpfe_dev->driver, "buffer_prepare:offset is"
+				"not aligned to 32 bytes\n");
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+	vb->state = VIDEOBUF_PREPARED;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_buffer_prepare>\n");
+out:
+	return ret;
+}
+
+static void vpfe_videobuf_queue(struct videobuf_queue *vq,
+				struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpfe_fh *fh = vq->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_buffer_queue>\n");
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	/* Change state of the buffer */
+	vb->state = VIDEOBUF_QUEUED;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_buffer_queue>\n");
+}
+
+static void vpfe_videobuf_release(struct videobuf_queue *vq,
+				struct videobuf_buffer *vb)
+{
+	v4l2_dbg(1, debug, vpfe_dev->driver, "vpfe_videobuf_release\n");
+	videobuf_dma_contig_free(vq, vb);
+	vb->state = VIDEOBUF_NEEDS_INIT;
+}
+
+static struct videobuf_queue_ops vpfe_videobuf_qops = {
+	.buf_setup      = vpfe_videobuf_setup,
+	.buf_prepare    = vpfe_videobuf_prepare,
+	.buf_queue      = vpfe_videobuf_queue,
+	.buf_release    = vpfe_videobuf_release,
+};
+
+static int vpfe_reqbufs(struct file *file, void *priv,
+			      struct v4l2_requestbuffers *p)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	enum v4l2_field field;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_buffer_queue>\n");
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "\nEnd of VIDIOC_REQBUFS ioctl");
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (common->io_usrs != 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+
+	if (common->fmt.fmt.pix.field != V4L2_FIELD_ANY)
+		field = common->fmt.fmt.pix.field;
+	else if (channel->vpfe_if == VPFE_RAW_BAYER)
+		field = V4L2_FIELD_NONE;
+	else
+		field = V4L2_FIELD_INTERLACED;
+
+	videobuf_queue_dma_contig_init(&common->buffer_queue,
+				&vpfe_videobuf_qops,
+				NULL,
+				&common->irqlock,
+				p->type,
+				field,
+				sizeof(struct videobuf_buffer),
+				fh);
+
+	fh->io_allowed[VPFE_VIDEO_INDEX] = 1;
+	common->io_usrs = 1;
+	INIT_LIST_HEAD(&common->dma_queue);
+	ret = videobuf_reqbufs(&common->buffer_queue, p);
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+static int vpfe_querybuf(struct file *file, void *priv,
+			       struct v4l2_buffer *p)
+{
+
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int ret = 0;
+	u8 buf_type_index = 0;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_QUERYBUF\n");
+	buf_type_index = VPFE_VIDEO_INDEX;
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type) {
+		v4l2_err(vpfe_dev->driver,
+			"VIDIOC_QUERYBUF:Invalid buf type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	common = &(channel->common[buf_type_index]);
+	if (p->memory != V4L2_MEMORY_MMAP) {
+		v4l2_err(vpfe_dev->driver,
+			"VIDIOC_QUERYBUF:Invalid memory\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	/* Call videobuf_querybuf to get information */
+	return videobuf_querybuf(&common->buffer_queue, p);
+out:
+	return ret;
+}
+
+static int vpfe_qbuf(struct file *file, void *priv,
+			   struct v4l2_buffer *p)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int buf_type_index, ret = 0;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_QBUF\n");
+	buf_type_index = VPFE_VIDEO_INDEX;
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type) {
+		v4l2_err(vpfe_dev->driver, "VIDIOC_QBUF:Invalid buf type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	common = &(channel->common[buf_type_index]);
+
+	/* If this file handle is not allowed to do IO,
+	 * return error
+	 */
+	if (!fh->io_allowed[buf_type_index]) {
+		v4l2_err(vpfe_dev->driver, "fh->io_allowed\n");
+		ret = -EACCES;
+		goto out;
+	}
+	return videobuf_qbuf(&common->buffer_queue, p);
+out:
+	return ret;
+}
+static int vpfe_dqbuf(struct file *file, void *priv,
+			    struct v4l2_buffer *p)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int buf_type_index = 0, ret = 0;
+	buf_type_index = VPFE_VIDEO_INDEX;
+	common = &(channel->common[buf_type_index]);
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type) {
+		v4l2_err(vpfe_dev->driver, "VIDIOC_DQBUF:Invalid buf type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	if (file->f_flags & O_NONBLOCK)
+		ret = videobuf_dqbuf(&common->buffer_queue, p, 1);
+	else
+		ret = videobuf_dqbuf(&common->buffer_queue, p, 0);
+out:
+	return ret;
+}
+
+/*  vpfe_calculate_offsets : This function calculates buffers offset
+ *  for top and bottom field
+ */
+static void vpfe_calculate_offsets(struct channel_obj *channel)
+{
+	struct common_obj *common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	struct v4l2_rect image_win;
+
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_calculate_offsets>\n");
+
+	common->field_off = 0;
+	ccdc_hw_dev.get_image_window(&image_win);
+	common->field_off = (image_win.height - 2) * image_win.width;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_calculate_offsets>\n");
+}
+
+static int vpfe_streamon(struct file *file, void *priv,
+			       enum v4l2_buf_type i)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int buf_type_index = VPFE_VIDEO_INDEX;
+	unsigned long addr;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_STREAMON\n");
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != i) {
+		v4l2_err(vpfe_dev->driver,
+			"VIDIOC_STREAMON:Invalid buf type\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	common = &(channel->common[buf_type_index]);
+	/* If file handle is not allowed IO,
+	 * return error
+	 */
+	if (!fh->io_allowed[buf_type_index]) {
+		v4l2_err(vpfe_dev->driver, "fh->io_allowed\n");
+		ret = -EACCES;
+		goto out;
+	}
+	/* If Streaming is already started,
+	 * return error
+	 */
+	if (common->started) {
+		v4l2_err(vpfe_dev->driver, "channel->started\n");
+		ret = -EBUSY;
+		goto out;
+	}
+	/* Call videobuf_streamon to start streaming
+	 * in videobuf
+	 */
+	ret = videobuf_streamon(&common->buffer_queue);
+	if (ret)
+		goto out;
+
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	/* If buffer queue is empty, return error */
+	if (list_empty(&common->dma_queue)) {
+		v4l2_err(vpfe_dev->driver, "buffer queue is empty\n");
+		ret = -EIO;
+		goto lock_out;
+	}
+	/* Get the next frame from the buffer queue */
+	common->nextFrm = common->curFrm =
+	    list_entry(common->dma_queue.next,
+		       struct videobuf_buffer, queue);
+	/* Remove buffer from the buffer queue */
+	list_del(&common->curFrm->queue);
+	/* Mark state of the current frame to active */
+	common->curFrm->state = VIDEOBUF_ACTIVE;
+	/* Initialize field_id and started member */
+	channel->field_id = 0;
+	common->started = 1;
+
+	addr = videobuf_to_dma_contig(common->curFrm);
+
+	/* Calculate field offset */
+	vpfe_calculate_offsets(channel);
+
+	if (vpfe_attach_irq(channel) < 0) {
+		v4l2_err(vpfe_dev->driver,
+			"Error in attaching interrupt handle\n");
+		ret = -EFAULT;
+		goto lock_out;
+	}
+
+	ccdc_hw_dev.configure();
+	ccdc_hw_dev.setfbaddr((unsigned long)(addr));
+	ccdc_hw_dev.enable(1);
+	if (ccdc_hw_dev.enable_out_to_sdram)
+		ccdc_hw_dev.enable_out_to_sdram(1);
+lock_out:
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+static int vpfe_streamoff(struct file *file, void *priv,
+				enum v4l2_buf_type i)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int buf_type_index = VPFE_VIDEO_INDEX, ret = 0;
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != i) {
+		v4l2_err(vpfe_dev->driver,
+			"VIDIOC_STREAMOFF:Invalid buf type\n");
+		return -EINVAL;
+	}
+	common = &(channel->common[buf_type_index]);
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_STREAMOFF\n");
+	/* If io is allowed for this file handle,
+	 * return error
+	 */
+	if (!fh->io_allowed[buf_type_index]) {
+		v4l2_err(vpfe_dev->driver, "fh->io_allowed\n");
+		ret = -EACCES;
+		goto out;
+	}
+	/* If streaming is not started, return error */
+	if (!common->started) {
+		v4l2_err(vpfe_dev->driver, "channel->started\n");
+		ret = -EINVAL;
+		goto out;
+	}
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	common->started = 0;
+	ccdc_hw_dev.enable(0);
+	if (ccdc_hw_dev.enable_out_to_sdram)
+		ccdc_hw_dev.enable_out_to_sdram(0);
+	if (vpfe_detach_irq(channel) < 0) {
+		v4l2_err(vpfe_dev->driver,
+			"Error in detaching interrupt handler\n");
+		mutex_unlock(&common->lock);
+		ret = -EFAULT;
+		goto lock_out;
+	}
+	ret = videobuf_streamoff(&common->buffer_queue);
+lock_out:
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+static int vpfe_queryctrl(struct file *file, void *priv,
+				struct v4l2_queryctrl *qc)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_QUERYCTRL\n");
+	/* Call queryctrl function of decoder device */
+	return vidioc_int_queryctrl(dec, qc);
+}
+
+static int vpfe_g_ctrl(struct file *file, void *priv,
+			     struct v4l2_control *ctrl)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	struct common_obj *common =
+	    &(channel->common[VPFE_VIDEO_INDEX]);
+	int ret = 0;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_G_CTRL\n");
+	/* Call getcontrol function of decoder device */
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		return ret;
+	ret = vidioc_int_g_ctrl(dec, ctrl);
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpfe_s_ctrl(struct file *file, void *priv,
+			     struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common =
+	    &(channel->common[VPFE_VIDEO_INDEX]);
+	struct v4l2_int_device *dec =
+		channel->decoder[channel->current_decoder];
+	v4l2_dbg(1, debug, vpfe_dev->driver, "VIDIOC_S_CTRL\n");
+	/* Call setcontrol function of decoder device */
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		return ret;
+	ret = vidioc_int_s_ctrl(dec, ctrl);
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpfe_cropcap(struct file *file, void *priv,
+			      struct v4l2_cropcap *crop)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct video_obj *vid_ch = NULL;
+	vid_ch = &(channel->video);
+
+	if (vid_ch->index > vpfe_max_standards)
+		return -EINVAL;
+	memset(crop, 0, sizeof(struct v4l2_cropcap));
+	crop->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	crop->bounds.width = crop->defrect.width =
+		vpfe_standards[vid_ch->index].width;
+	crop->bounds.height = crop->defrect.height =
+		vpfe_standards[vid_ch->index].height;
+	crop->pixelaspect = vpfe_standards[vid_ch->index].pixelaspect;
+	return 0;
+}
+
+static int vpfe_g_crop(struct file *file, void *priv,
+			     struct v4l2_crop *crop)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	v4l2_dbg(1, debug, vpfe_dev->driver, "\nStarting VIDIOC_G_CROP ioctl");
+	crop->c = common->crop;
+	return 0;
+}
+
+static int vpfe_s_crop(struct file *file, void *priv,
+			     struct v4l2_crop *crop)
+{
+	int ret = 0;
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	vid_ch = &(channel->video);
+	v4l2_dbg(1, debug, vpfe_dev->driver, "\nStarting VIDIOC_S_CROP ioctl");
+	if (common->started) {
+		/* make sure streaming is not started */
+		v4l2_err(vpfe_dev->driver,
+			"Cannot change crop when streaming is ON\n");
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	/* make sure parameters are valid */
+	if ((crop->c.left + crop->c.width <= vid_ch->std_info.activepixels) &&
+	    (crop->c.top + crop->c.height <= vid_ch->std_info.activelines)) {
+		/* adjust the width to 16 pixel boundry */
+		crop->c.width = ((crop->c.width + 15) & ~0xf);
+		ccdc_hw_dev.set_image_window(&crop->c);
+		common->fmt.fmt.pix.width = crop->c.width;
+		common->fmt.fmt.pix.height = crop->c.height;
+		ccdc_hw_dev.get_line_length(&common->fmt.fmt.pix.bytesperline);
+		common->fmt.fmt.pix.sizeimage =
+				    common->fmt.fmt.pix.
+				    bytesperline *
+				    common->fmt.fmt.pix.height;
+		common->crop = crop->c;
+	} else {
+		v4l2_err(vpfe_dev->driver, "Error in S_CROP params\n");
+		ret = -EINVAL;
+	}
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+
+static long vpfe_param_handler(struct file *file, void *priv,
+		int cmd, void *param)
+{
+	struct vpfe_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int ret = 0;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+
+	if (common->started) {
+		/* only allowed if streaming is not started */
+		v4l2_err(vpfe_dev->driver, "channel already started\n");
+		ret = -EBUSY;
+		goto out;
+	}
+	ret = mutex_lock_interruptible(&common->lock);
+	if (ret)
+		goto out;
+	switch (cmd) {
+	case VPFE_CMD_S_SOC_PARAMS:
+	{
+		ret = ccdc_hw_dev.setparams(param);
+		if (ret) {
+			v4l2_err(vpfe_dev->driver,
+				"Error in setting parameters"
+				" in CCDC \n");
+			goto lock_out;
+		}
+		if (vpfe_get_image_format(&common->fmt) < 0) {
+			v4l2_err(vpfe_dev->driver,
+				"Invalid image format at CCDC \n");
+			goto lock_out;
+		}
+		break;
+	}
+	default:
+		ret = -EINVAL;
+	}
+lock_out:
+	mutex_unlock(&common->lock);
+out:
+	return ret;
+}
+
+
+/* vpfe capture ioctl operations */
+static const struct v4l2_ioctl_ops vpfe_ioctl_ops = {
+	.vidioc_querycap	 = vpfe_querycap,
+	.vidioc_g_fmt_vid_cap    = vpfe_g_fmt_vid_cap,
+	.vidioc_enum_fmt_vid_cap = vpfe_enum_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap    = vpfe_s_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap  = vpfe_try_fmt_vid_cap,
+	.vidioc_enum_input	 = vpfe_enum_input,
+	.vidioc_g_input		 = vpfe_g_input,
+	.vidioc_s_input		 = vpfe_s_input,
+	.vidioc_querystd	 = vpfe_querystd,
+	.vidioc_s_std		 = vpfe_s_std,
+	.vidioc_g_std		 = vpfe_g_std,
+	.vidioc_reqbufs		 = vpfe_reqbufs,
+	.vidioc_querybuf	 = vpfe_querybuf,
+	.vidioc_qbuf		 = vpfe_qbuf,
+	.vidioc_dqbuf		 = vpfe_dqbuf,
+	.vidioc_streamon	 = vpfe_streamon,
+	.vidioc_streamoff	 = vpfe_streamoff,
+	.vidioc_queryctrl	 = vpfe_queryctrl,
+	.vidioc_g_ctrl		 = vpfe_g_ctrl,
+	.vidioc_s_ctrl		 = vpfe_s_ctrl,
+	.vidioc_cropcap		 = vpfe_cropcap,
+	.vidioc_g_crop		 = vpfe_g_crop,
+	.vidioc_s_crop		 = vpfe_s_crop,
+	.vidioc_default		 = vpfe_param_handler,
+};
+
+/*	vpfe_probe : This function creates device entries by register
+ *	itself to the V4L2 driver and initializes fields of each
+ *	channel objects
+ */
+static __init int vpfe_probe(struct platform_device *device)
+{
+	struct common_obj *common = NULL;
+	int err = -ENOMEM, index = 0;
+	struct video_device *vfd = NULL;
+	struct channel_obj *channel = NULL;
+	struct video_obj *vid_ch = NULL;
+	struct resource *res1, *res2;
+	void *__iomem mem1;
+	void *__iomem mem2;
+
+	vpfe_dev = &device->dev;
+
+	/* Get the pointer to the channel object */
+	channel = vpfe_obj.dev[0];
+	/* Allocate memory for video device */
+	vfd = video_device_alloc();
+	if (ISNULL(vfd)) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to alloc video device\n");
+		return err;
+	}
+
+	/* Initialize field of video device */
+	vfd->release = video_device_release;
+	vfd->current_norm	= V4L2_STD_UNKNOWN;
+	vfd->fops		= &vpfe_fops;
+	vfd->ioctl_ops		= &vpfe_ioctl_ops;
+	vfd->minor		= -1;
+	vfd->tvnorms		= V4L2_STD_UNKNOWN,
+	vfd->dev		= device->dev;
+	snprintf(vfd->name, sizeof(vfd->name),
+		 "%s_V%d.%d.%d",
+		 CAPTURE_DRV_NAME,
+		 (VPFE_CAPTURE_VERSION_CODE >> 16) & 0xff,
+		 (VPFE_CAPTURE_VERSION_CODE >> 8) & 0xff,
+		 (VPFE_CAPTURE_VERSION_CODE) & 0xff);
+	/* Set video_dev to the video device */
+	channel->video_dev = vfd;
+
+	channel->usrs = 0;
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	common->io_usrs = 0;
+	common->started = 0;
+	spin_lock_init(&common->irqlock);
+	common->numbuffers = 0;
+	common->field_off = 0;
+	common->curFrm = common->nextFrm = NULL;
+	memset(&common->fmt, 0, sizeof(struct v4l2_format));
+	channel->initialized = 0;
+	channel->channel_id = 0;
+	vid_ch = &(channel->video);
+	vid_ch->input = device->dev.platform_data;
+	if (!vid_ch->input) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to get inputs to vpfe\n");
+		err = -ENOENT;
+		goto probe_out_release;
+	}
+	vid_ch->index = 0;
+	channel->irq_type = VPFE_NO_IRQ;
+	/* Get VINT0 irq resource */
+	res1 = platform_get_resource(device, IORESOURCE_IRQ, 0);
+	if (!res1) {
+		err = -ENOENT;
+		v4l2_err(vpfe_dev->driver, "Unable to get interrupt for VINT0");
+		goto probe_out_release;
+	}
+	channel->ccdc_irq0 = res1->start;
+
+	/* Get VINT1 irq resource */
+	res1 = platform_get_resource(device,
+				IORESOURCE_IRQ, 1);
+	if (!res1) {
+		err = -ENOENT;
+		v4l2_err(vpfe_dev->driver,
+			"Unable to get interrupt for VINT1");
+		goto probe_out_release;
+	}
+	channel->ccdc_irq1 = res1->start;
+	channel->res1 = platform_get_resource(device, IORESOURCE_MEM, 0);
+	channel->res2 = platform_get_resource(device, IORESOURCE_MEM, 1);
+	if (!channel->res1 || !channel->res2) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to get register address map\n");
+		err = -ENOENT;
+		goto probe_out_release;
+	}
+	res1 = (struct resource *)channel->res1;
+	res2 = (struct resource *)channel->res2;
+	if (!request_mem_region(res1->start, res1->end - res1->start + 1,
+				vpfe_dev->driver->name)) {
+		err = -ENXIO;
+		v4l2_err(vpfe_dev->driver,
+			"Failed request_mem_region for ccdc base\n");
+		goto probe_out_release;
+	}
+
+	mem1 = ioremap_nocache(res1->start, res1->end - res1->start + 1);
+	if (!mem1) {
+		v4l2_err(vpfe_dev->driver, "Unable to ioremap ccdc address\n");
+		goto probe_out_release_mem1;
+	}
+
+	ccdc_hw_dev.set_ccdc_base(mem1, res1->end - res1->start + 1);
+
+	if (!request_mem_region(res2->start, res2->end - res2->start + 1,
+				vpfe_dev->driver->name)) {
+		err = -ENXIO;
+		v4l2_err(vpfe_dev->driver,
+			"Failed request_mem_region for"
+				  " vpss base\n");
+		goto probe_out_unmap1;
+	}
+
+	mem2 = ioremap_nocache(res2->start, res2->end - res2->start + 1);
+	if (!mem2) {
+		v4l2_err(vpfe_dev->driver, "Unable to ioremap vpss address\n");
+		goto probe_out_release_mem2;
+	}
+
+	ccdc_hw_dev.set_vpss_base(mem2, res2->end - res2->start + 1);
+
+	err = request_irq(channel->ccdc_irq0, vpfe_isr, IRQF_DISABLED,
+			  "vpfe_capture0", (void *)&vpfe_obj);
+
+	if (0 != err) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to request interrupt\n");
+		goto probe_out_unmap2;
+	}
+
+	/* Initialize field of the channel objects */
+	channel->usrs = common->io_usrs = 0;
+	common->started = channel->initialized = 0;
+	channel->channel_id = 0;
+	common->numbuffers = config_params.numbuffers[channel->channel_id];
+	channel->numdecoders = 0;
+	channel->current_decoder = 0;
+	for (index = 0; index < VPFE_CAPTURE_NUM_DECODERS; index++)
+		channel->decoder[index] = NULL;
+
+	/* Initialize prio member of channel object */
+	v4l2_prio_init(&channel->prio);
+
+	/* register video device */
+	v4l2_dbg(1, debug, vpfe_dev->driver,
+		"trying to register vpfe device.\n");
+	v4l2_dbg(1, debug, vpfe_dev->driver,
+		"channel=%x,channel->video_dev=%x\n",
+		(int)channel, (int)&channel->video_dev);
+	channel->common[VPFE_VIDEO_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	err = video_register_device(channel->video_dev,
+				    VFL_TYPE_GRABBER, vpfe_nr[0]);
+
+	dev_notice(vpfe_dev, "video device registered\n");
+	if (err) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to register video device.\n");
+		goto probe_out_release_irq;
+	}
+
+	vpfe_capture.priv = channel;
+	err = v4l2_int_device_register(&vpfe_capture);
+	if (err) {
+		v4l2_err(vpfe_dev->driver,
+			"Unable to register int master device.\n");
+		goto probe_out;
+	}
+	dev_notice(vpfe_dev, "v4l2 int master registered\n");
+	mutex_init(&common->lock);
+	return 0;
+
+probe_out:
+	/* Get the pointer to the channel object */
+	channel = vpfe_obj.dev[0];
+	/* Unregister video device */
+	video_unregister_device(channel->video_dev);
+	v4l2_int_device_unregister(&vpfe_capture);
+
+probe_out_release_irq:
+	free_irq(channel->ccdc_irq0, (void *)&vpfe_obj);
+probe_out_unmap2:
+	iounmap(mem2);
+probe_out_unmap1:
+	iounmap(mem1);
+probe_out_release_mem1:
+	release_mem_region(res1->start, res1->end -
+				res1->start + 1);
+probe_out_release_mem2:
+	release_mem_region(res2->start,
+				res2->end -
+				res2->start + 1);
+probe_out_release:
+	video_device_release(channel->video_dev);
+	channel->video_dev = NULL;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_probe>\n");
+	return err;
+}
+
+/*  vpfe_remove : It un-register channels from V4L2 driver
+ */
+static int vpfe_remove(struct platform_device *device)
+{
+	struct channel_obj *channel;
+	struct common_obj *common = NULL;
+	struct resource *res;
+	v4l2_dbg(1, debug, vpfe_dev->driver, "<vpfe_remove>\n");
+
+	/* un-register device */
+	channel = vpfe_obj.dev[0];
+	common = &(channel->common[VPFE_VIDEO_INDEX]);
+	free_irq(channel->ccdc_irq0, (void *)&vpfe_obj);
+	/* Unregister video device */
+	video_unregister_device(channel->video_dev);
+	video_device_release(channel->video_dev);
+	v4l2_int_device_unregister(&vpfe_capture);
+	channel->video_dev = NULL;
+	res = (struct resource *)channel->res1;
+	release_mem_region(res->start, res->end - res->start + 1);
+	res = (struct resource *)channel->res2;
+	release_mem_region(res->start, res->end - res->start + 1);
+	iounmap(ccdc_hw_dev.get_ccdc_base());
+	iounmap(ccdc_hw_dev.get_vpss_base());
+	v4l2_dbg(1, debug, vpfe_dev->driver, "</vpfe_remove>\n");
+	return 0;
+}
+
+static int
+vpfe_suspend(struct platform_device *dev, pm_message_t state)
+{
+	/* add suspend code here later */
+	return 0;
+}
+
+static int
+vpfe_resume(struct platform_device *dev)
+{
+	/* add resume code here later */
+	return 0;
+}
+
+static struct platform_driver vpfe_driver = {
+	.driver = {
+		.name = CAPTURE_DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = vpfe_probe,
+	.remove = __devexit_p(vpfe_remove),
+	.suspend = vpfe_suspend,
+	.resume  = vpfe_resume,
+};
+
+static __init int vpfe_init(void)
+{
+	int err = 0;
+
+	/* Default number of buffers should be 3 */
+	if ((ch0_numbuffers > 0) &&
+	    (ch0_numbuffers < config_params.min_numbuffers))
+		ch0_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given
+	 */
+	if (ch0_bufsize < config_params.min_bufsize[VPFE_CHANNEL0_VIDEO])
+		ch0_bufsize =
+		    config_params.min_bufsize[VPFE_CHANNEL0_VIDEO];
+
+	config_params.numbuffers[VPFE_CHANNEL0_VIDEO] = ch0_numbuffers;
+
+	if (ch0_numbuffers)
+		config_params.channel_bufsize[VPFE_CHANNEL0_VIDEO]
+		    = ch0_bufsize;
+
+	if (ISNULL(ccdc_hw_dev.enable) ||
+	    ISNULL(ccdc_hw_dev.open) ||
+	    ISNULL(ccdc_hw_dev.set_hw_if_type) ||
+	    ISNULL(ccdc_hw_dev.configure) ||
+	    ISNULL(ccdc_hw_dev.set_buftype) ||
+	    ISNULL(ccdc_hw_dev.get_buftype) ||
+	    ISNULL(ccdc_hw_dev.enum_pix) ||
+	    ISNULL(ccdc_hw_dev.set_frame_format) ||
+	    ISNULL(ccdc_hw_dev.get_frame_format) ||
+	    ISNULL(ccdc_hw_dev.get_pixelformat) ||
+	    ISNULL(ccdc_hw_dev.set_pixelformat) ||
+	    ISNULL(ccdc_hw_dev.setparams) ||
+	    ISNULL(ccdc_hw_dev.set_image_window) ||
+	    ISNULL(ccdc_hw_dev.get_image_window) ||
+	    ISNULL(ccdc_hw_dev.get_line_length) ||
+	    ISNULL(ccdc_hw_dev.setfbaddr) ||
+	    ISNULL(ccdc_hw_dev.getfid)) {
+		printk(KERN_ERR "vpfe_init:CCDC module interface"
+				"has missing mandatory functions\n");
+		return -ENODEV;
+	}
+
+	/* Allocate memory for channel objects */
+	vpfe_obj.dev[0] = kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+	/* If memory allocation fails, return error */
+	if (!vpfe_obj.dev[0]) {
+		err = -ENOMEM;
+		printk(KERN_ERR "vpfe_init:Memory allocation failed\n");
+		goto vpfe_init_free_channel_object;
+	}
+
+	/* Register driver to the kernel */
+	err = platform_driver_register(&vpfe_driver);
+	if (0 != err)
+		goto vpfe_init_free_channel_object;
+
+	printk(KERN_NOTICE "vpfe_capture: init successful\n");
+	return err;
+
+vpfe_init_free_channel_object:
+	kfree(vpfe_obj.dev[0]);
+	vpfe_obj.dev[0] = NULL;
+	return err;
+}
+
+/* vpfe_cleanup : This function un-registers device and driver
+ * to the kernel, frees requested irq handler and de-allocates memory
+ * allocated for channel objects.
+ */
+static void vpfe_cleanup(void)
+{
+	platform_driver_unregister(&vpfe_driver);
+	kfree(vpfe_obj.dev[0]);
+	vpfe_obj.dev[0] = NULL;
+}
+module_init(vpfe_init);
+module_exit(vpfe_cleanup);
+MODULE_AUTHOR("Texas Instruments.");
+MODULE_DESCRIPTION("VPFE Video for Linux Capture Driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/media/video/davinci/vpif.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/vpif.c	2009-11-20 10:07:18.498470966 -0600
@@ -0,0 +1,252 @@
+/*
+ * vpif - DM646x Video Port Interface driver
+ * VPIF is a receiver and transmitter for video data. It has two channels(0, 1)
+ * that receiveing video byte stream and two channels(2, 3) for video output.
+ * The hardware supports SDTV, HDTV formats, raw data capture.
+ * Currently, the driver supports NTSC and PAL standards.
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include "vpif.h"
+
+MODULE_DESCRIPTION("TI DaVinci Video Port Interface driver");
+MODULE_LICENSE("GPL");
+
+#define VPIF_CH0_MAX_MODES	(22)
+#define VPIF_CH1_MAX_MODES	(02)
+#define VPIF_CH2_MAX_MODES	(15)
+#define VPIF_CH3_MAX_MODES	(02)
+
+/* This structure is used to keep track of VPIF size register's offsets */
+struct vpif_registers {
+	u32 h_cfg, v_cfg_00, v_cfg_01, v_cfg_02, v_cfg, ch_ctrl;
+	u32 line_offset, vanc0_strt, vanc0_size, vanc1_strt;
+	u32 vanc1_size, width_mask, len_mask;
+	u8 max_modes;
+};
+
+static struct vpif_registers vpifregs[VPIF_NUM_CHANNELS] = {
+	/* Channel0 */
+	{
+		VPIF_CH0_H_CFG, VPIF_CH0_V_CFG_00, VPIF_CH0_V_CFG_01,
+		VPIF_CH0_V_CFG_02, VPIF_CH0_V_CFG_03, VPIF_CH0_CTRL,
+		VPIF_CH0_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF,
+		VPIF_CH0_MAX_MODES,
+	},
+	/* Channel1 */
+	{
+		VPIF_CH1_H_CFG, VPIF_CH1_V_CFG_00, VPIF_CH1_V_CFG_01,
+		VPIF_CH1_V_CFG_02, VPIF_CH1_V_CFG_03, VPIF_CH1_CTRL,
+		VPIF_CH1_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF,
+		VPIF_CH1_MAX_MODES,
+	},
+	/* Channel2 */
+	{
+		VPIF_CH2_H_CFG, VPIF_CH2_V_CFG_00, VPIF_CH2_V_CFG_01,
+		VPIF_CH2_V_CFG_02, VPIF_CH2_V_CFG_03, VPIF_CH2_CTRL,
+		VPIF_CH2_IMG_ADD_OFST, VPIF_CH2_VANC0_STRT, VPIF_CH2_VANC0_SIZE,
+		VPIF_CH2_VANC1_STRT, VPIF_CH2_VANC1_SIZE, 0x7FF, 0x7FF,
+		VPIF_CH2_MAX_MODES
+	},
+	/* Channel3 */
+	{
+		VPIF_CH3_H_CFG, VPIF_CH3_V_CFG_00, VPIF_CH3_V_CFG_01,
+		VPIF_CH3_V_CFG_02, VPIF_CH3_V_CFG_03, VPIF_CH3_CTRL,
+		VPIF_CH3_IMG_ADD_OFST, VPIF_CH3_VANC0_STRT, VPIF_CH3_VANC0_SIZE,
+		VPIF_CH3_VANC1_STRT, VPIF_CH3_VANC1_SIZE, 0x7FF, 0x7FF,
+		VPIF_CH3_MAX_MODES
+	},
+};
+
+/* vpif_set_mode_info:
+ * This function is used to set horizontal and vertical config parameters
+ * As per the standard in the channel, configure the values of L1, L3,
+ * L5, L7  L9, L11 in VPIF Register , also write width and height
+ */
+static void vpif_set_mode_info(struct vpif_channel_config_params *config,
+				u8 channel_id, u8 config_channel_id)
+{
+	u32 value;
+
+	value = (config->eav2sav & vpifregs[config_channel_id].width_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (config->sav2eav & vpifregs[config_channel_id].width_mask);
+	regw(value, vpifregs[channel_id].h_cfg);
+
+	value = (config->l1 & vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (config->l3 & vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg_00);
+
+	value = (config->l5 & vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (config->l7 & vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg_01);
+
+	value = (config->l9 & vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (config->l11 & vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg_02);
+
+	value = (config->vsize & vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg);
+}
+
+/* config_vpif_params
+ * Function to set the parameters of a channel
+ * Mainly modifies the channel ciontrol register
+ * It sets frame format, yc mux mode
+ */
+static void config_vpif_params(struct vpif_params *vpifparams,
+				u8 channel_id, u8 found)
+{
+	struct vpif_channel_config_params *config = &vpifparams->std_info;
+	u32 value, ch_nip, reg;
+	u8 start, end;
+	int i;
+
+	start = channel_id;
+	end = channel_id + found;
+
+	for (i = start; i < end; i++) {
+		reg = vpifregs[i].ch_ctrl;
+		if (channel_id < 2)
+			ch_nip = VPIF_CAPTURE_CH_NIP;
+		else
+			ch_nip = VPIF_DISPLAY_CH_NIP;
+
+		if (config->frm_fmt)	/* Progressive Frame Format */
+			vpif_set_bit(reg, ch_nip);
+		else			/* Interlaced Frame Format */
+			vpif_clr_bit(reg, ch_nip);
+
+		if (config->ycmux_mode)	/* YC Mux mode */
+			vpif_set_bit(reg, VPIF_CH_YC_MUX_BIT);
+		else
+			vpif_clr_bit(reg, VPIF_CH_YC_MUX_BIT);
+
+		if (vpifparams->video_params.storage_mode)
+			vpif_set_bit(reg, VPIF_CH_INPUT_FIELD_FRAME_BIT);
+		else
+			vpif_clr_bit(reg, VPIF_CH_INPUT_FIELD_FRAME_BIT);
+
+		/* Set raster scanning SDR Format */
+		vpif_clr_bit(reg, VPIF_CH_SDR_FMT_BIT);
+		if (config->capture_format)
+			vpif_set_bit(reg, VPIF_CH_DATA_MODE_BIT);
+		else
+			vpif_clr_bit(reg, VPIF_CH_DATA_MODE_BIT);
+
+		if (channel_id > 1)	/* Set the Pixel enable bit */
+			vpif_set_bit(reg, VPIF_DISPLAY_PIX_EN_BIT);
+		else if (config->capture_format) {
+			/* Set the polarity of various pins */
+
+			if (vpifparams->params.raw_params.fid_pol)
+				vpif_set_bit(reg, VPIF_CH_FID_POLARITY_BIT);
+			else
+				vpif_clr_bit(reg, VPIF_CH_FID_POLARITY_BIT);
+
+			if (vpifparams->params.raw_params.vd_pol)
+				vpif_set_bit(reg, VPIF_CH_V_VALID_POLARITY_BIT);
+			else
+				vpif_clr_bit(reg, VPIF_CH_V_VALID_POLARITY_BIT);
+
+			if (vpifparams->params.raw_params.hd_pol)
+				vpif_set_bit(reg, VPIF_CH_H_VALID_POLARITY_BIT);
+			else
+				vpif_clr_bit(reg, VPIF_CH_H_VALID_POLARITY_BIT);
+
+			value = regr(reg);
+			/* Set data width */
+			value &= ((~(unsigned int)(0x3)) <<
+					VPIF_CH_DATA_WIDTH_BIT);
+			value |= ((vpifparams->params.raw_params.data_sz) <<
+						     VPIF_CH_DATA_WIDTH_BIT);
+			regw(value, reg);
+		}
+
+		/* Write the pitch in the driver */
+		regw((vpifparams->video_params.hpitch),
+						vpifregs[i].line_offset);
+	}
+}
+
+/* vpif_set_video_params
+ * This function is used to set video parameters in VPIF register
+ */
+int vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id)
+{
+	struct vpif_channel_config_params *config = &vpifparams->std_info;
+	int found = -1;
+
+	vpif_set_mode_info(config, channel_id, channel_id);
+	found = 1;
+	if (!config->ycmux_mode) {
+		vpif_set_mode_info(config, channel_id + 1, channel_id);
+		found = 2;
+	}
+
+	config_vpif_params(vpifparams, channel_id, found);
+
+	regw(0x80, VPIF_REQ_SIZE);
+	regw(0x01, VPIF_EMULATION_CTRL);
+
+	return found;
+}
+EXPORT_SYMBOL(vpif_set_video_params);
+
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+				u8 channel_id)
+{
+	u32 value;
+
+	value = 0x3F8 & (vbiparams->hstart0);
+	value |= 0x3FFFFFF & ((vbiparams->vstart0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_strt);
+
+	value = 0x3F8 & (vbiparams->hstart1);
+	value |= 0x3FFFFFF & ((vbiparams->vstart1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_strt);
+
+	value = 0x3F8 & (vbiparams->hsize0);
+	value |= 0x3FFFFFF & ((vbiparams->vsize0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_size);
+
+	value = 0x3F8 & (vbiparams->hsize1);
+	value |= 0x3FFFFFF & ((vbiparams->vsize1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_size);
+
+	return 0;
+}
+EXPORT_SYMBOL(vpif_set_vbi_display_params);
+
+int vpif_channel_getfid(u8 channel_id)
+{
+	int val;
+	val = ((regr(vpifregs[channel_id].ch_ctrl) & VPIF_CH_FID_MASK)
+					>> VPIF_CH_FID_SHIFT);
+
+	return val;
+}
+EXPORT_SYMBOL(vpif_channel_getfid);
+
+void vpif_base_addr_init(void __iomem *base)
+{
+	vpif_base = base;
+}
+EXPORT_SYMBOL(vpif_base_addr_init);
Index: linux-2.6.29/drivers/media/video/davinci/vpif.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/vpif.h	2009-11-20 10:07:18.498470966 -0600
@@ -0,0 +1,640 @@
+/*
+ * VPIF header file
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef VPIF_H
+#define VPIF_H
+
+#include <linux/io.h>
+#include <linux/videodev2.h>
+#include <mach/hardware.h>
+
+/* Maximum channel allowed */
+#define VPIF_NUM_CHANNELS		(4)
+#define VPIF_CAPTURE_NUM_CHANNELS	(2)
+#define VPIF_DISPLAY_NUM_CHANNELS	(2)
+
+/* Macros to read/write registers */
+static void __iomem *vpif_base;
+#define regr(reg)               readl((reg) + vpif_base)
+#define regw(value, reg)        writel(value, (reg + vpif_base))
+
+/* Register Addresss Offsets */
+#define VPIF_PID			(0x0000)
+#define VPIF_CH0_CTRL			(0x0004)
+#define VPIF_CH1_CTRL			(0x0008)
+#define VPIF_CH2_CTRL			(0x000C)
+#define VPIF_CH3_CTRL			(0x0010)
+
+#define VPIF_INTEN			(0x0020)
+#define VPIF_INTEN_SET			(0x0024)
+#define VPIF_INTEN_CLR			(0x0028)
+#define VPIF_STATUS			(0x002C)
+#define VPIF_STATUS_CLR			(0x0030)
+#define VPIF_EMULATION_CTRL		(0x0034)
+#define VPIF_REQ_SIZE			(0x0038)
+
+#define VPIF_CH0_TOP_STRT_ADD_LUMA	(0x0040)
+#define VPIF_CH0_BTM_STRT_ADD_LUMA	(0x0044)
+#define VPIF_CH0_TOP_STRT_ADD_CHROMA	(0x0048)
+#define VPIF_CH0_BTM_STRT_ADD_CHROMA	(0x004c)
+#define VPIF_CH0_TOP_STRT_ADD_HANC	(0x0050)
+#define VPIF_CH0_BTM_STRT_ADD_HANC	(0x0054)
+#define VPIF_CH0_TOP_STRT_ADD_VANC	(0x0058)
+#define VPIF_CH0_BTM_STRT_ADD_VANC	(0x005c)
+#define VPIF_CH0_SP_CFG			(0x0060)
+#define VPIF_CH0_IMG_ADD_OFST		(0x0064)
+#define VPIF_CH0_HANC_ADD_OFST		(0x0068)
+#define VPIF_CH0_H_CFG			(0x006c)
+#define VPIF_CH0_V_CFG_00		(0x0070)
+#define VPIF_CH0_V_CFG_01		(0x0074)
+#define VPIF_CH0_V_CFG_02		(0x0078)
+#define VPIF_CH0_V_CFG_03		(0x007c)
+
+#define VPIF_CH1_TOP_STRT_ADD_LUMA	(0x0080)
+#define VPIF_CH1_BTM_STRT_ADD_LUMA	(0x0084)
+#define VPIF_CH1_TOP_STRT_ADD_CHROMA	(0x0088)
+#define VPIF_CH1_BTM_STRT_ADD_CHROMA	(0x008c)
+#define VPIF_CH1_TOP_STRT_ADD_HANC	(0x0090)
+#define VPIF_CH1_BTM_STRT_ADD_HANC	(0x0094)
+#define VPIF_CH1_TOP_STRT_ADD_VANC	(0x0098)
+#define VPIF_CH1_BTM_STRT_ADD_VANC	(0x009c)
+#define VPIF_CH1_SP_CFG			(0x00a0)
+#define VPIF_CH1_IMG_ADD_OFST		(0x00a4)
+#define VPIF_CH1_HANC_ADD_OFST		(0x00a8)
+#define VPIF_CH1_H_CFG			(0x00ac)
+#define VPIF_CH1_V_CFG_00		(0x00b0)
+#define VPIF_CH1_V_CFG_01		(0x00b4)
+#define VPIF_CH1_V_CFG_02		(0x00b8)
+#define VPIF_CH1_V_CFG_03		(0x00bc)
+
+#define VPIF_CH2_TOP_STRT_ADD_LUMA	(0x00c0)
+#define VPIF_CH2_BTM_STRT_ADD_LUMA	(0x00c4)
+#define VPIF_CH2_TOP_STRT_ADD_CHROMA	(0x00c8)
+#define VPIF_CH2_BTM_STRT_ADD_CHROMA	(0x00cc)
+#define VPIF_CH2_TOP_STRT_ADD_HANC	(0x00d0)
+#define VPIF_CH2_BTM_STRT_ADD_HANC	(0x00d4)
+#define VPIF_CH2_TOP_STRT_ADD_VANC	(0x00d8)
+#define VPIF_CH2_BTM_STRT_ADD_VANC	(0x00dc)
+#define VPIF_CH2_SP_CFG			(0x00e0)
+#define VPIF_CH2_IMG_ADD_OFST		(0x00e4)
+#define VPIF_CH2_HANC_ADD_OFST		(0x00e8)
+#define VPIF_CH2_H_CFG			(0x00ec)
+#define VPIF_CH2_V_CFG_00		(0x00f0)
+#define VPIF_CH2_V_CFG_01		(0x00f4)
+#define VPIF_CH2_V_CFG_02		(0x00f8)
+#define VPIF_CH2_V_CFG_03		(0x00fc)
+#define VPIF_CH2_HANC0_STRT		(0x0100)
+#define VPIF_CH2_HANC0_SIZE		(0x0104)
+#define VPIF_CH2_HANC1_STRT		(0x0108)
+#define VPIF_CH2_HANC1_SIZE		(0x010c)
+#define VPIF_CH2_VANC0_STRT		(0x0110)
+#define VPIF_CH2_VANC0_SIZE		(0x0114)
+#define VPIF_CH2_VANC1_STRT		(0x0118)
+#define VPIF_CH2_VANC1_SIZE		(0x011c)
+
+#define VPIF_CH3_TOP_STRT_ADD_LUMA	(0x0140)
+#define VPIF_CH3_BTM_STRT_ADD_LUMA	(0x0144)
+#define VPIF_CH3_TOP_STRT_ADD_CHROMA	(0x0148)
+#define VPIF_CH3_BTM_STRT_ADD_CHROMA	(0x014c)
+#define VPIF_CH3_TOP_STRT_ADD_HANC	(0x0150)
+#define VPIF_CH3_BTM_STRT_ADD_HANC	(0x0154)
+#define VPIF_CH3_TOP_STRT_ADD_VANC	(0x0158)
+#define VPIF_CH3_BTM_STRT_ADD_VANC	(0x015c)
+#define VPIF_CH3_SP_CFG			(0x0160)
+#define VPIF_CH3_IMG_ADD_OFST		(0x0164)
+#define VPIF_CH3_HANC_ADD_OFST		(0x0168)
+#define VPIF_CH3_H_CFG			(0x016c)
+#define VPIF_CH3_V_CFG_00		(0x0170)
+#define VPIF_CH3_V_CFG_01		(0x0174)
+#define VPIF_CH3_V_CFG_02		(0x0178)
+#define VPIF_CH3_V_CFG_03		(0x017c)
+#define VPIF_CH3_HANC0_STRT		(0x0180)
+#define VPIF_CH3_HANC0_SIZE		(0x0184)
+#define VPIF_CH3_HANC1_STRT		(0x0188)
+#define VPIF_CH3_HANC1_SIZE		(0x018c)
+#define VPIF_CH3_VANC0_STRT		(0x0190)
+#define VPIF_CH3_VANC0_SIZE		(0x0194)
+#define VPIF_CH3_VANC1_STRT		(0x0198)
+#define VPIF_CH3_VANC1_SIZE		(0x019c)
+
+#define VPIF_IODFT_CTRL			(0x01c0)
+
+/* Functions for bit Manipulation */
+static inline void vpif_set_bit(u32 reg, u32 bit)
+{
+	regw((regr(reg)) | (0x01 << bit), reg);
+}
+
+static inline void vpif_clr_bit(u32 reg, u32 bit)
+{
+	regw(((regr(reg)) & ~(0x01 << bit)), reg);
+}
+
+/* Macro for Generating mask */
+#ifdef GENERATE_MASK
+#undef GENERATE_MASK
+#endif
+
+#define GENERATE_MASK(bits, pos) \
+		((((0xFFFFFFFF) << (32 - bits)) >> (32 - bits)) << pos)
+
+/* Bit positions in the channel control registers */
+#define VPIF_CH_DATA_MODE_BIT	(2)
+#define VPIF_CH_YC_MUX_BIT	(3)
+#define VPIF_CH_SDR_FMT_BIT	(4)
+#define VPIF_CH_HANC_EN_BIT	(8)
+#define VPIF_CH_VANC_EN_BIT	(9)
+
+#define VPIF_CAPTURE_CH_NIP	(10)
+#define VPIF_DISPLAY_CH_NIP	(11)
+
+#define VPIF_DISPLAY_PIX_EN_BIT	(10)
+
+#define VPIF_CH_INPUT_FIELD_FRAME_BIT	(12)
+
+#define VPIF_CH_FID_POLARITY_BIT	(15)
+#define VPIF_CH_V_VALID_POLARITY_BIT	(14)
+#define VPIF_CH_H_VALID_POLARITY_BIT	(13)
+#define VPIF_CH_DATA_WIDTH_BIT		(28)
+
+#define VPIF_CH_CLK_EDGE_CTRL_BIT	(31)
+
+/* Mask various length */
+#define VPIF_CH_EAVSAV_MASK	GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_MASK	GENERATE_MASK(12, 0)
+#define VPIF_CH_WIDTH_MASK	GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_SHIFT	(16)
+
+/* VPIF masks for registers */
+#define VPIF_REQ_SIZE_MASK	(0x1ff)
+
+/* bit posotion of interrupt vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH0	(0x00000001)
+#define VPIF_INTEN_FRAME_CH1	(0x00000002)
+#define VPIF_INTEN_FRAME_CH2	(0x00000004)
+#define VPIF_INTEN_FRAME_CH3	(0x00000008)
+
+/* bit position of clock and channel enable in vpif_chn_ctrl register */
+
+#define VPIF_CH0_CLK_EN		(0x00000002)
+#define VPIF_CH0_EN		(0x00000001)
+#define VPIF_CH1_CLK_EN		(0x00000002)
+#define VPIF_CH1_EN		(0x00000001)
+#define VPIF_CH2_CLK_EN		(0x00000002)
+#define VPIF_CH2_EN		(0x00000001)
+#define VPIF_CH3_CLK_EN		(0x00000002)
+#define VPIF_CH3_EN		(0x00000001)
+#define VPIF_CH_CLK_EN		(0x00000002)
+#define VPIF_CH_EN	        (0x00000001)
+
+#define VPIF_INT_TOP	(0x00)
+#define VPIF_INT_BOTTOM	(0x01)
+#define VPIF_INT_BOTH	(0x02)
+
+#define VPIF_CH0_INT_CTRL_SHIFT	(6)
+#define VPIF_CH1_INT_CTRL_SHIFT	(6)
+#define VPIF_CH2_INT_CTRL_SHIFT	(6)
+#define VPIF_CH3_INT_CTRL_SHIFT	(6)
+#define VPIF_CH_INT_CTRL_SHIFT	(6)
+
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel0_intr_assert()	(regw((regr(VPIF_CH0_CTRL)|\
+				(VPIF_INT_BOTH << \
+				VPIF_CH0_INT_CTRL_SHIFT)), \
+				VPIF_CH0_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel1_intr_assert()	(regw((regr(VPIF_CH1_CTRL)|\
+				(VPIF_INT_BOTH << \
+				VPIF_CH1_INT_CTRL_SHIFT)), \
+				VPIF_CH1_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel2_intr_assert() 	(regw((regr(VPIF_CH2_CTRL)|\
+				(VPIF_INT_BOTH << \
+				VPIF_CH2_INT_CTRL_SHIFT)), \
+				VPIF_CH2_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel3_intr_assert() 	(regw((regr(VPIF_CH3_CTRL)|\
+				(VPIF_INT_BOTH << \
+				VPIF_CH3_INT_CTRL_SHIFT)), \
+				VPIF_CH3_CTRL))
+
+#define VPIF_CH_FID_MASK	(0x20)
+#define VPIF_CH_FID_SHIFT	(5)
+
+#define VPIF_NTSC_VBI_START_FIELD0	(1)
+#define VPIF_NTSC_VBI_START_FIELD1	(263)
+#define VPIF_PAL_VBI_START_FIELD0	(624)
+#define VPIF_PAL_VBI_START_FIELD1	(311)
+
+#define VPIF_NTSC_HBI_START_FIELD0	(1)
+#define VPIF_NTSC_HBI_START_FIELD1	(263)
+#define VPIF_PAL_HBI_START_FIELD0	(624)
+#define VPIF_PAL_HBI_START_FIELD1	(311)
+
+#define VPIF_NTSC_VBI_COUNT_FIELD0	(20)
+#define VPIF_NTSC_VBI_COUNT_FIELD1	(19)
+#define VPIF_PAL_VBI_COUNT_FIELD0	(24)
+#define VPIF_PAL_VBI_COUNT_FIELD1	(25)
+
+#define VPIF_NTSC_HBI_COUNT_FIELD0	(263)
+#define VPIF_NTSC_HBI_COUNT_FIELD1	(262)
+#define VPIF_PAL_HBI_COUNT_FIELD0	(312)
+#define VPIF_PAL_HBI_COUNT_FIELD1	(313)
+
+#define VPIF_NTSC_VBI_SAMPLES_PER_LINE	(720)
+#define VPIF_PAL_VBI_SAMPLES_PER_LINE	(720)
+#define VPIF_NTSC_HBI_SAMPLES_PER_LINE	(268)
+#define VPIF_PAL_HBI_SAMPLES_PER_LINE	(280)
+
+#define VPIF_CH_VANC_EN			(0x20)
+#define VPIF_DMA_REQ_SIZE		(0x080)
+#define VPIF_EMULATION_DISABLE		(0x01)
+
+extern u8 irq_vpif_capture_channel[VPIF_NUM_CHANNELS];
+
+/* inline function to enable/disable channel0 */
+static inline void enable_channel0(int enable)
+{
+	if (enable)
+		regw((regr(VPIF_CH0_CTRL) | (VPIF_CH0_EN)), VPIF_CH0_CTRL);
+	else
+		regw((regr(VPIF_CH0_CTRL) & (~VPIF_CH0_EN)), VPIF_CH0_CTRL);
+}
+
+/* inline function to enable/disable channel1 */
+static inline void enable_channel1(int enable)
+{
+	if (enable)
+		regw((regr(VPIF_CH1_CTRL) | (VPIF_CH1_EN)), VPIF_CH1_CTRL);
+	else
+		regw((regr(VPIF_CH1_CTRL) & (~VPIF_CH1_EN)), VPIF_CH1_CTRL);
+}
+
+/* inline function to enable interrupt for channel0 */
+static inline void channel0_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH0), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+							VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH0)), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+							VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel1 */
+static inline void channel1_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH1), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+							VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH1)), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+							VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to set buffer addresses in case of Y/C non mux mode */
+static inline void ch0_set_videobuf_addr_yc_nmux(unsigned long top_strt_luma,
+						 unsigned long btm_strt_luma,
+						 unsigned long top_strt_chroma,
+						 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+/* inline function to set buffer addresses in VPIF registers for video data */
+static inline void ch0_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH0_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH0_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch1_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+
+	regw(top_strt_luma, VPIF_CH1_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH1_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch0_set_vbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_VANC);
+}
+
+static inline void ch0_set_hbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_HANC);
+}
+
+static inline void ch1_set_vbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_VANC);
+}
+
+static inline void ch1_set_hbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_HANC);
+}
+
+/* Inline function to enable raw vbi in the given channel */
+static inline void disable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	if (0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+
+	if (1 == index)
+		vpif_clr_bit(ctrl_reg, VPIF_CH_VANC_EN_BIT);
+	else
+		vpif_clr_bit(ctrl_reg, VPIF_CH_HANC_EN_BIT);
+}
+
+static inline void enable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	if (0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+
+	if (1 == index)
+		vpif_set_bit(ctrl_reg, VPIF_CH_VANC_EN_BIT);
+	else
+		vpif_set_bit(ctrl_reg, VPIF_CH_HANC_EN_BIT);
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel2(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_CLK_EN)), VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_EN)), VPIF_CH2_CTRL);
+	} else {
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_CLK_EN)), VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_EN)), VPIF_CH2_CTRL);
+	}
+}
+
+/* inline function to enable/disable channel3 */
+static inline void enable_channel3(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_CLK_EN)), VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_EN)), VPIF_CH3_CTRL);
+	} else {
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_CLK_EN)), VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_EN)), VPIF_CH3_CTRL);
+	}
+}
+
+/* inline function to enable interrupt for channel2 */
+static inline void channel2_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH2), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+							VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH2)), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+							VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel3 */
+static inline void channel3_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH3), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+							VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH3)), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+							VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable raw vbi data for channel2 */
+static inline void channel2_raw_enable(int enable, u8 index)
+{
+	u32 mask;
+
+	if (1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+
+	if (enable)
+		vpif_set_bit(VPIF_CH2_CTRL, mask);
+	else
+		vpif_clr_bit(VPIF_CH2_CTRL, mask);
+}
+
+/* inline function to enable raw vbi data for channel3*/
+static inline void channel3_raw_enable(int enable, u8 index)
+{
+	u32 mask;
+
+	if (1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+
+	if (enable)
+		vpif_set_bit(VPIF_CH3_CTRL, mask);
+	else
+		vpif_clr_bit(VPIF_CH3_CTRL, mask);
+}
+
+/* inline function to set buffer addresses in case of Y/C non mux mode */
+static inline void ch2_set_videobuf_addr_yc_nmux(unsigned long top_strt_luma,
+						 unsigned long btm_strt_luma,
+						 unsigned long top_strt_chroma,
+						 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+}
+
+/* inline function to set buffer addresses in VPIF registers for video data */
+static inline void ch2_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH2_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH2_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch3_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+}
+
+/* inline function to set buffer addresses in VPIF registers for vbi data */
+static inline void ch2_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_VANC);
+}
+
+static inline void ch3_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_VANC);
+}
+
+#define VPIF_MAX_NAME	(30)
+
+/* This structure will store size parameters as per the mode selected by user */
+struct vpif_channel_config_params {
+	char name[VPIF_MAX_NAME];	/* Name of the mode */
+	u16 width;			/* Indicates width of the image */
+	u16 height;			/* Indicates height of the image */
+	u8 fps;
+	u8 frm_fmt;			/* Indicates whether this is interlaced
+					 * or progressive format */
+	u8 ycmux_mode;			/* Indicates whether this mode requires
+					 * single or two channels */
+	u16 eav2sav;			/* length of sav 2 eav */
+	u16 sav2eav;			/* length of sav 2 eav */
+	u16 l1, l3, l5, l7, l9, l11;	/* Other parameter configurations */
+	u16 vsize;			/* Vertical size of the image */
+	u8 capture_format;		/* Indicates whether capture format
+					 * is in BT or in CCD/CMOS */
+	u8  vbi_supported;		/* Indicates whether this mode
+					 * supports capturing vbi or not */
+	u8 hd_sd;
+	v4l2_std_id stdid;
+};
+
+struct vpif_interface;
+struct vpif_params;
+struct vpif_vbi_params;
+
+int vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id);
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+							u8 channel_id);
+int vpif_channel_getfid(u8 channel_id);
+void vpif_base_addr_init(void __iomem *base);
+
+/* Enumerated data types */
+enum vpif_capture_pinpol {
+	VPIF_CAPTURE_PINPOL_SAME	= 0,
+	VPIF_CAPTURE_PINPOL_INVERT	= 1
+};
+
+enum data_size {
+	_8BITS = 0,
+	_10BITS,
+	_12BITS,
+};
+
+struct vpif_capture_params_raw {
+	enum data_size data_sz;
+	enum vpif_capture_pinpol fid_pol;
+	enum vpif_capture_pinpol vd_pol;
+	enum vpif_capture_pinpol hd_pol;
+};
+
+/* Structure for vpif parameters for raw vbi data */
+struct vpif_vbi_params {
+	__u32 hstart0;  /* Horizontal start of raw vbi data for first field */
+	__u32 vstart0;  /* Vertical start of raw vbi data for first field */
+	__u32 hsize0;   /* Horizontal size of raw vbi data for first field */
+	__u32 vsize0;   /* Vertical size of raw vbi data for first field */
+	__u32 hstart1;  /* Horizontal start of raw vbi data for second field */
+	__u32 vstart1;  /* Vertical start of raw vbi data for second field */
+	__u32 hsize1;   /* Horizontal size of raw vbi data for second field */
+	__u32 vsize1;   /* Vertical size of raw vbi data for second field */
+};
+
+/* structure for vpif parameters */
+struct vpif_interface {
+	__u8 storage_mode;	/* Indicates field or frame mode */
+	unsigned long hpitch;
+	v4l2_std_id stdid;
+};
+
+struct vpif_params {
+	struct vpif_interface video_params;
+	struct vpif_channel_config_params std_info;
+	union param {
+		struct vpif_vbi_params	vbi_params;
+		struct vpif_capture_params_raw	raw_params;
+	} params;
+};
+
+#endif				/* End of #ifndef VPIF_H */
+
Index: linux-2.6.29/drivers/media/video/davinci/vpif_display.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/vpif_display.c	2009-11-20 10:07:18.498470966 -0600
@@ -0,0 +1,1687 @@
+/*
+ * vpif-display - VPIF display driver
+ * Display driver for TI DaVinci VPIF
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/string.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/version.h>
+
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <media/adv7343.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+
+#include <mach/dm646x.h>
+
+#include "vpif_display.h"
+#include "vpif.h"
+
+MODULE_DESCRIPTION("TI DaVinci VPIF Display driver");
+MODULE_LICENSE("GPL");
+
+#define DM646X_V4L2_STD (V4L2_STD_PAL | V4L2_STD_NTSC)
+
+static int debug;
+static u32 ch2_numbuffers = 3;
+static u32 ch3_numbuffers = 3;
+static u32 ch2_bufsize = 1920 * 1080 * 2;
+static u32 ch3_bufsize = 720 * 576 * 2;
+
+module_param(debug, int, 0644);
+module_param(ch2_numbuffers, uint, S_IRUGO);
+module_param(ch3_numbuffers, uint, S_IRUGO);
+module_param(ch2_bufsize, uint, S_IRUGO);
+module_param(ch3_bufsize, uint, S_IRUGO);
+
+MODULE_PARM_DESC(debug, "Debug level 0-1");
+MODULE_PARM_DESC(ch2_numbuffers, "Channel2 buffer count (default:3)");
+MODULE_PARM_DESC(ch3_numbuffers, "Channel3 buffer count (default:3)");
+MODULE_PARM_DESC(ch2_bufsize, "Channel2 buffer size (default:1920 x 1080 x 2)");
+MODULE_PARM_DESC(ch3_bufsize, "Channel3 buffer size (default:720 x 576 x 2)");
+
+static struct vpif_config_params config_params = {
+	.min_numbuffers		= 3,
+	.numbuffers[0]		= 3,
+	.numbuffers[1]		= 3,
+	.min_bufsize[0]		= 720 * 480 * 2,
+	.min_bufsize[1]		= 720 * 480 * 2,
+	.channel_bufsize[0]	= 1920 * 1080 * 2,
+	.channel_bufsize[1]	= 720 * 576 * 2,
+};
+
+static int vpif_nr[] = {2, 3,};
+static struct vpif_device vpif_obj = { {NULL} };
+static struct device *vpif_dev;
+
+static struct vpif_channel_config_params ch_params[] = {
+	{
+		"NTSC", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266,
+		286, 525, 525, 0, 1, 0, V4L2_STD_NTSC,
+	},
+	{
+		"PAL", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313,
+		336, 624, 625, 0, 1, 0, V4L2_STD_PAL,
+	},
+};
+
+/*
+ * vpif_uservirt_to_phys: This function is used to convert user
+ * space virtual address to physical address.
+ */
+static u32 vpif_uservirt_to_phys(u32 virtp)
+{
+	struct mm_struct *mm = current->mm;
+	unsigned long physp = 0;
+	struct vm_area_struct *vma;
+
+	vma = find_vma(mm, virtp);
+
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *)virtp);
+	} else if (vma && (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated, mmaped-to-usermode addr */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp = __pa(page_address(&pages[0]) +
+							(virtp & ~PAGE_MASK));
+		} else {
+			v4l2_err(&vpif_obj.v4l2_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+
+	return physp;
+}
+
+/*
+ * buffer_prepare: This is the callback function called from videobuf_qbuf()
+ * function the buffer is prepared and user space virtual address is converted
+ * into physical address
+ */
+static int vpif_buffer_prepare(struct videobuf_queue *q,
+			       struct videobuf_buffer *vb,
+			       enum v4l2_field field)
+{
+	struct vpif_fh *fh = q->priv_data;
+	struct common_obj *common;
+	unsigned long addr;
+
+	common = &fh->channel->common[VPIF_VIDEO_INDEX];
+	if (VIDEOBUF_NEEDS_INIT == vb->state) {
+		vb->width	= common->width;
+		vb->height	= common->height;
+		vb->size	= vb->width * vb->height;
+		vb->field	= field;
+	}
+	vb->state = VIDEOBUF_PREPARED;
+
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer */
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		if (!vb->baddr) {
+			v4l2_err(&vpif_obj.v4l2_dev, "buffer_address is 0\n");
+			return -EINVAL;
+		}
+
+		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff))
+			goto buf_align_exit;
+	}
+
+	addr = vb->boff;
+	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {
+		if (!ISALIGNED(addr + common->ytop_off) ||
+		    !ISALIGNED(addr + common->ybtm_off) ||
+		    !ISALIGNED(addr + common->ctop_off) ||
+		    !ISALIGNED(addr + common->cbtm_off))
+			goto buf_align_exit;
+	}
+	return 0;
+
+buf_align_exit:
+	v4l2_err(&vpif_obj.v4l2_dev, "buffer offset not aligned to 8 bytes\n");
+	return -EINVAL;
+}
+
+/*
+ * vpif_buffer_setup: This function allocates memory for the buffers
+ */
+static int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+				unsigned int *size)
+{
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	if (V4L2_MEMORY_MMAP != common->memory)
+		return 0;
+
+	*size = config_params.channel_bufsize[ch->channel_id];
+	if (*count < config_params.min_numbuffers)
+		*count = config_params.min_numbuffers;
+
+	return 0;
+}
+
+/*
+ * vpif_buffer_queue: This function adds the buffer to DMA queue
+ */
+static void vpif_buffer_queue(struct videobuf_queue *q,
+			      struct videobuf_buffer *vb)
+{
+	struct vpif_fh *fh = q->priv_data;
+	struct common_obj *common;
+
+	common = &fh->channel->common[VPIF_VIDEO_INDEX];
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	vb->state = VIDEOBUF_QUEUED;
+}
+
+/*
+ * vpif_buffer_release: This function is called from the videobuf layer to
+ * free memory allocated to the buffers
+ */
+static void vpif_buffer_release(struct videobuf_queue *q,
+				struct videobuf_buffer *vb)
+{
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common;
+	unsigned int buf_size = 0;
+
+	common = &ch->common[VPIF_VIDEO_INDEX];
+
+	videobuf_dma_contig_free(q, vb);
+	vb->state = VIDEOBUF_NEEDS_INIT;
+
+	if (V4L2_MEMORY_MMAP != common->memory)
+		return;
+
+	buf_size = config_params.channel_bufsize[ch->channel_id];
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup	= vpif_buffer_setup,
+	.buf_prepare	= vpif_buffer_prepare,
+	.buf_queue	= vpif_buffer_queue,
+	.buf_release	= vpif_buffer_release,
+};
+static u8 channel_first_int[VPIF_NUMOBJECTS][2] = { {1, 1} };
+
+static void process_progressive_mode(struct common_obj *common)
+{
+	unsigned long addr = 0;
+
+	/* Get the next buffer from buffer queue */
+	common->next_frm = list_entry(common->dma_queue.next,
+				struct videobuf_buffer, queue);
+	/* Remove that buffer from the buffer queue */
+	list_del(&common->next_frm->queue);
+	/* Mark status of the buffer as active */
+	common->next_frm->state = VIDEOBUF_ACTIVE;
+
+	/* Set top and bottom field addrs in VPIF registers */
+	addr = videobuf_to_dma_contig(common->next_frm);
+	common->set_addr(addr + common->ytop_off,
+				 addr + common->ybtm_off,
+				 addr + common->ctop_off,
+				 addr + common->cbtm_off);
+}
+
+static void process_interlaced_mode(int fid, struct common_obj *common)
+{
+	unsigned long addr = 0;
+
+	/* device field id and local field id are in sync */
+	/* If this is even field */
+	if (0 == fid) {
+		if (common->cur_frm == common->next_frm)
+			return;
+
+		/* one frame is displayed If next frame is
+		 *  available, release cur_frm and move on */
+		/* Copy frame display time */
+		do_gettimeofday(&common->cur_frm->ts);
+		/* Change status of the cur_frm */
+		common->cur_frm->state = VIDEOBUF_DONE;
+		/* unlock semaphore on cur_frm */
+		wake_up_interruptible(&common->cur_frm->done);
+		/* Make cur_frm pointing to next_frm */
+		common->cur_frm = common->next_frm;
+
+	} else if (1 == fid) {	/* odd field */
+		if (list_empty(&common->dma_queue)
+		    || (common->cur_frm != common->next_frm)) {
+			return;
+		}
+		/* one field is displayed configure the next
+		 * frame if it is available else hold on current
+		 * frame */
+		/* Get next from the buffer queue */
+		common->next_frm = list_entry(common->dma_queue.next,
+						struct videobuf_buffer,	queue);
+
+		/* Remove that from the buffer queue */
+		list_del(&common->next_frm->queue);
+
+		/* Mark state of the frame to active */
+		common->next_frm->state = VIDEOBUF_ACTIVE;
+		addr = videobuf_to_dma_contig(common->next_frm);
+		common->set_addr(addr + common->ytop_off,
+					 addr + common->ybtm_off,
+					 addr + common->ctop_off,
+					 addr + common->cbtm_off);
+
+	}
+}
+
+/*
+ * vpif_channel_isr: It changes status of the displayed buffer, takes next
+ * buffer from the queue and sets its address in VPIF registers
+ */
+static irqreturn_t vpif_channel_isr(int irq, void *dev_id)
+{
+	struct vpif_device *dev = &vpif_obj;
+	struct channel_obj *ch;
+	struct common_obj *common;
+	enum v4l2_field field;
+	int fid = -1, i;
+	int channel_id = 0;
+
+	channel_id = *(int *)(dev_id);
+	ch = dev->dev[channel_id];
+	field = ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;
+	for (i = 0; i < VPIF_NUMOBJECTS; i++) {
+		common = &ch->common[i];
+		/* If streaming is started in this channel */
+		if (0 == common->started)
+			continue;
+
+		if (1 == ch->vpifparams.std_info.frm_fmt) {
+			if (list_empty(&common->dma_queue))
+				continue;
+
+			/* Progressive mode */
+			if (!channel_first_int[i][channel_id]) {
+				/* Mark status of the cur_frm to
+				 * done and unlock semaphore on it */
+				do_gettimeofday(&common->cur_frm->ts);
+				common->cur_frm->state = VIDEOBUF_DONE;
+				wake_up_interruptible(&common->cur_frm->done);
+				/* Make cur_frm pointing to next_frm */
+				common->cur_frm = common->next_frm;
+			}
+
+			channel_first_int[i][channel_id] = 0;
+			process_progressive_mode(common);
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+
+			if (channel_first_int[i][channel_id]) {
+				channel_first_int[i][channel_id] = 0;
+				continue;
+			}
+
+			if (0 == i) {
+				ch->field_id ^= 1;
+				/* Get field id from VPIF registers */
+				fid = vpif_channel_getfid(ch->channel_id + 2);
+				/* If fid does not match with stored field id */
+				if (fid != ch->field_id) {
+					/* Make them in sync */
+					if (0 == fid)
+						ch->field_id = fid;
+
+					return IRQ_HANDLED;
+				}
+			}
+			process_interlaced_mode(fid, common);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+int vpif_get_mode_info(struct vpif_channel_config_params *std_info)
+{
+	int index, found = -1;
+
+	if (!std_info)
+		goto vpif_get_mode_exit;
+
+	for (index = 0; index < ARRAY_SIZE(ch_params); index++) {
+		struct vpif_channel_config_params *config = &ch_params[index];
+		if (config->stdid == std_info->stdid) {
+			memcpy(std_info, config, sizeof(*config));
+			found = 1;
+			break;
+		}
+	}
+
+vpif_get_mode_exit:
+	return found;
+}
+
+static void vpif_get_std_info(struct channel_obj *ch)
+{
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct video_obj *vid_ch = &ch->video;
+	struct vpif_params *vpifparams = &ch->vpifparams;
+	struct vpif_channel_config_params *std_info = &vpifparams->std_info;
+	int ret;
+
+	std_info->stdid = vid_ch->stdid;
+	/* Get standard information from VPIF layer */
+	ret = vpif_get_mode_info(std_info);
+	common->fmt.fmt.pix.width = std_info->width;
+	common->fmt.fmt.pix.height = std_info->height;
+	v4l2_dbg(1, debug, &vpif_obj.v4l2_dev,
+			"Pixel details: Width = %d,Height = %d\n",
+			common->fmt.fmt.pix.width, common->fmt.fmt.pix.height);
+
+	/* Set height and width paramateres */
+	ch->common[VPIF_VIDEO_INDEX].height = std_info->height;
+	ch->common[VPIF_VIDEO_INDEX].width = std_info->width;
+}
+
+/*
+ * vpif_calculate_offsets: This function calculates buffers offset for Y and C
+ * in the top and bottom field
+ */
+static void vpif_calculate_offsets(struct channel_obj *ch)
+{
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct vpif_params *vpifparams = &ch->vpifparams;
+	enum v4l2_field field = common->fmt.fmt.pix.field;
+	struct video_obj *vid_ch = &ch->video;
+	unsigned int hpitch, vpitch, sizeimage;
+
+	if (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {
+		if (ch->vpifparams.std_info.frm_fmt)
+			vid_ch->buf_field = V4L2_FIELD_NONE;
+		else
+			vid_ch->buf_field = V4L2_FIELD_INTERLACED;
+	} else {
+		vid_ch->buf_field = common->fmt.fmt.pix.field;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory)
+		sizeimage = common->fmt.fmt.pix.sizeimage;
+	else
+		sizeimage = config_params.channel_bufsize[ch->channel_id];
+
+	hpitch = common->fmt.fmt.pix.bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		common->ytop_off = 0;
+		common->ybtm_off = hpitch;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = sizeimage / 2 + hpitch;
+	} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {
+		common->ytop_off = 0;
+		common->ybtm_off = sizeimage / 4;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = common->ctop_off + sizeimage / 4;
+	} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {
+		common->ybtm_off = 0;
+		common->ytop_off = sizeimage / 4;
+		common->cbtm_off = sizeimage / 2;
+		common->ctop_off = common->cbtm_off + sizeimage / 4;
+	}
+
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		vpifparams->video_params.storage_mode = 1;
+	} else {
+		vpifparams->video_params.storage_mode = 0;
+	}
+
+	if (ch->vpifparams.std_info.frm_fmt == 1) {
+		vpifparams->video_params.hpitch =
+		    common->fmt.fmt.pix.bytesperline;
+	} else {
+		if ((field == V4L2_FIELD_ANY) ||
+			(field == V4L2_FIELD_INTERLACED))
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline * 2;
+		else
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline;
+	}
+
+	ch->vpifparams.video_params.stdid = ch->vpifparams.std_info.stdid;
+}
+
+static void vpif_config_format(struct channel_obj *ch)
+{
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	common->fmt.fmt.pix.field = V4L2_FIELD_ANY;
+	if (config_params.numbuffers[ch->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+
+	common->fmt.fmt.pix.sizeimage =
+			config_params.channel_bufsize[ch->channel_id];
+	common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;
+	common->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+}
+
+static int vpif_check_format(struct channel_obj *ch,
+			     struct v4l2_pix_format *pixfmt)
+{
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	enum v4l2_field field = pixfmt->field;
+	u32 sizeimage, hpitch, vpitch;
+
+	if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)
+		goto invalid_fmt_exit;
+
+	if (!(VPIF_VALID_FIELD(field)))
+		goto invalid_fmt_exit;
+
+	if (pixfmt->bytesperline <= 0)
+		goto invalid_pitch_exit;
+
+	if (V4L2_MEMORY_USERPTR == common->memory)
+		sizeimage = pixfmt->sizeimage;
+	else
+		sizeimage = config_params.channel_bufsize[ch->channel_id];
+
+	vpif_get_std_info(ch);
+
+	hpitch = pixfmt->bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	/* Check for valid value of pitch */
+	if ((hpitch < ch->vpifparams.std_info.width) ||
+	    (vpitch < ch->vpifparams.std_info.height))
+		goto invalid_pitch_exit;
+
+	/* Check for 8 byte alignment */
+	if (!ISALIGNED(hpitch)) {
+		v4l2_err(&vpif_obj.v4l2_dev, "invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = common->fmt.fmt.pix.width;
+	pixfmt->height = common->fmt.fmt.pix.height;
+
+	return 0;
+
+invalid_fmt_exit:
+	v4l2_err(&vpif_obj.v4l2_dev, "invalid field format\n");
+	return -EINVAL;
+
+invalid_pitch_exit:
+	v4l2_err(&vpif_obj.v4l2_dev, "invalid pitch\n");
+	return -EINVAL;
+}
+
+static void vpif_config_addr(struct channel_obj *ch, int muxmode)
+{
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	if (VPIF_CHANNEL3_VIDEO == ch->channel_id) {
+		common->set_addr = ch3_set_videobuf_addr;
+	} else {
+		if (2 == muxmode)
+			common->set_addr = ch2_set_videobuf_addr_yc_nmux;
+		else
+			common->set_addr = ch2_set_videobuf_addr;
+	}
+}
+
+/*
+ * vpif_mmap: It is used to map kernel space buffers into user spaces
+ */
+static int vpif_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	struct vpif_fh *fh = filep->private_data;
+	struct common_obj *common = &fh->channel->common[VPIF_VIDEO_INDEX];
+	int err = 0;
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+
+	return err;
+}
+
+/*
+ * vpif_poll: It is used for select/poll system call
+ */
+static unsigned int vpif_poll(struct file *filep, poll_table *wait)
+{
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	int err = 0;
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	return err;
+}
+
+/*
+ * vpif_open: It creates object of file handle structure and stores it in
+ * private_data member of filepointer
+ */
+static int vpif_open(struct file *filep)
+{
+	struct video_device *vdev = video_devdata(filep);
+	struct channel_obj *ch = NULL;
+	struct vpif_fh *fh = NULL;
+	int err = 0;
+
+	ch = video_get_drvdata(vdev);
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpif_fh), GFP_KERNEL);
+	if (fh == NULL) {
+		v4l2_err(&vpif_obj.v4l2_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = ch;
+	fh->initialized = 0;
+	if (!ch->initialized) {
+		fh->initialized = 1;
+		ch->initialized = 1;
+		memset(&ch->vpifparams, 0, sizeof(ch->vpifparams));
+	}
+
+	if (err < 0) {
+		if (fh->initialized)
+			ch->initialized = 0;
+
+		filep->private_data = NULL;
+		fh->initialized = 0;
+		/* Free memory allocated to file handle object */
+		if (fh != NULL)
+			kfree(fh);
+		return err;
+	}
+
+	/* Increment channel usrs counter */
+	ch->usrs++;
+	/* Set io_allowed[VPIF_VIDEO_INDEX] member to false */
+	fh->io_allowed[VPIF_VIDEO_INDEX] = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&ch->prio, &fh->prio);
+
+	return err;
+}
+
+/*
+ * vpif_release: This function deletes buffer queue, frees the buffers and
+ * the vpif file handle
+ */
+static int vpif_release(struct file *filep)
+{
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	mutex_lock_interruptible(&common->lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		common->io_usrs = 0;
+		/* Disable channel */
+		if (VPIF_CHANNEL2_VIDEO == ch->channel_id) {
+			enable_channel2(0);
+			channel2_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||
+		    (2 == common->started)) {
+			enable_channel3(0);
+			channel3_intr_enable(0);
+		}
+		common->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&common->buffer_queue);
+		videobuf_mmap_free(&common->buffer_queue);
+		common->numbuffers =
+		    config_params.numbuffers[ch->channel_id];
+	}
+
+	mutex_unlock(&common->lock);
+	/* Decrement channel usrs counter */
+	ch->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (fh->initialized)
+		ch->initialized = 0;
+
+	/* Close the priority */
+	v4l2_prio_close(&ch->prio, &fh->prio);
+	filep->private_data = NULL;
+	fh->initialized = 0;
+
+	if (fh != NULL)
+		kfree(fh);
+
+	return 0;
+}
+
+/* functions implementing ioctls */
+
+static int vpif_querycap(struct file *file, void  *priv,
+				struct v4l2_capability *cap)
+{
+	struct vpif_config *config = vpif_dev->platform_data;
+
+	cap->version = VPIF_DISPLAY_VERSION_CODE;
+	cap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;
+	strlcpy(cap->driver, "vpif display", sizeof(cap->driver));
+	strlcpy(cap->bus_info, "Platform", sizeof(cap->bus_info));
+	strlcpy(cap->card, config->card_name, sizeof(cap->card));
+
+	return 0;
+}
+
+static int vpif_enum_fmt_vid_out(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *fmt)
+{
+	if (fmt->index != 0) {
+		v4l2_err(&vpif_obj.v4l2_dev, "Invalid format index\n");
+		return -EINVAL;
+	}
+
+	/* Fill in the information about format */
+	fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	strcpy(fmt->description, "YCbCr4:2:2 YC Planar");
+	fmt->pixelformat = V4L2_PIX_FMT_YUV422P;
+
+	return 0;
+}
+
+static int vpif_g_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	int ret = 0;
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	/* Check the validity of the buffer type */
+	if (common->fmt.type != fmt->type)
+		return -EINVAL;
+
+	/* Fill in the information about format */
+	mutex_lock_interruptible(&common->lock);
+	if (ret < 0)
+		goto g_fmt_exit;
+
+	vpif_get_std_info(ch);
+	*fmt = common->fmt;
+
+g_fmt_exit:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpif_s_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	struct vpif_fh *fh = priv;
+	struct v4l2_pix_format *pixfmt;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	int ret = 0;
+
+	if ((VPIF_CHANNEL2_VIDEO == ch->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {
+		if (!fh->initialized) {
+			v4l2_dbg(1, debug, &vpif_obj.v4l2_dev,
+							"Channel Busy\n");
+			return -EBUSY;
+		}
+
+		/* Check for the priority */
+		ret = v4l2_prio_check(&ch->prio, &fh->prio);
+		if (0 != ret)
+			return ret;
+		fh->initialized = 1;
+	}
+
+	if (common->started) {
+		v4l2_dbg(1, debug, &vpif_obj.v4l2_dev,
+						"Streaming in progress\n");
+		return -EBUSY;
+	}
+
+	pixfmt = &fmt->fmt.pix;
+	/* Check for valid field format */
+	ret = vpif_check_format(ch, pixfmt);
+	if (ret)
+		return ret;
+
+	/* store the pix format in the channel object */
+	common->fmt.fmt.pix = *pixfmt;
+	/* store the format in the channel object */
+	mutex_lock_interruptible(&common->lock);
+	common->fmt = *fmt;
+	mutex_unlock(&common->lock);
+
+	return 0;
+}
+
+static int vpif_try_fmt_vid_out(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+	int ret = 0;
+
+	ret = vpif_check_format(ch, pixfmt);
+	if (ret) {
+		*pixfmt = common->fmt.fmt.pix;
+		pixfmt->sizeimage = pixfmt->width * pixfmt->height * 2;
+	}
+
+	return ret;
+}
+
+static int vpif_reqbufs(struct file *file, void *priv,
+			struct v4l2_requestbuffers *reqbuf)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common;
+	enum v4l2_field field;
+	u8 index = 0;
+	int ret = 0;
+
+	/* This file handle has not initialized the channel,
+	   It is not allowed to do settings */
+	if ((VPIF_CHANNEL2_VIDEO == ch->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {
+		if (!fh->initialized) {
+			v4l2_err(&vpif_obj.v4l2_dev,
+							"Channel Busy\n");
+			return -EBUSY;
+		}
+	}
+
+	if ((V4L2_BUF_TYPE_VIDEO_OUTPUT != reqbuf->type))
+		return -EINVAL;
+
+	index = VPIF_VIDEO_INDEX;
+
+	common = &ch->common[index];
+	mutex_lock_interruptible(&common->lock);
+	if (common->fmt.type != reqbuf->type) {
+		ret = -EINVAL;
+		goto reqbuf_exit;
+	}
+
+	if (0 != common->io_usrs) {
+		ret = -EBUSY;
+		goto reqbuf_exit;
+	}
+
+	if (reqbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		if (common->fmt.fmt.pix.field == V4L2_FIELD_ANY)
+			field = V4L2_FIELD_INTERLACED;
+		else
+			field = common->fmt.fmt.pix.field;
+	} else {
+		field = V4L2_VBI_INTERLACED;
+	}
+
+	/* Initialize videobuf queue as per the buffer type */
+	videobuf_queue_dma_contig_init(&common->buffer_queue,
+					    &video_qops, NULL,
+					    &common->irqlock,
+					    reqbuf->type, field,
+					    sizeof(struct videobuf_buffer), fh);
+
+	/* Set io allowed member of file handle to TRUE */
+	fh->io_allowed[index] = 1;
+	/* Increment io usrs member of channel object to 1 */
+	common->io_usrs = 1;
+	/* Store type of memory requested in channel object */
+	common->memory = reqbuf->memory;
+	INIT_LIST_HEAD(&common->dma_queue);
+
+	/* Allocate buffers */
+	ret = videobuf_reqbufs(&common->buffer_queue, reqbuf);
+
+reqbuf_exit:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpif_querybuf(struct file *file, void *priv,
+				struct v4l2_buffer *tbuf)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	if (common->fmt.type != tbuf->type)
+		return -EINVAL;
+
+	if (tbuf->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+
+	return videobuf_querybuf(&common->buffer_queue, tbuf);
+}
+
+static int vpif_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)
+{
+
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct v4l2_buffer tbuf = *buf;
+	struct videobuf_buffer *buf1;
+	unsigned long addr = 0;
+	unsigned long flags;
+	int ret = 0;
+
+	if (common->fmt.type != tbuf.type)
+		return -EINVAL;
+
+	if (!fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		v4l2_err(&vpif_obj.v4l2_dev, "fh->io_allowed\n");
+		return -EACCES;
+	}
+
+	if (!(list_empty(&common->dma_queue)) ||
+	    (common->cur_frm != common->next_frm) ||
+	    !(common->started) ||
+	    (common->started && (0 == ch->field_id)))
+		return videobuf_qbuf(&common->buffer_queue, buf);
+
+	/* bufferqueue is empty store buffer address in VPIF registers */
+	mutex_lock(&common->buffer_queue.vb_lock);
+	buf1 = common->buffer_queue.bufs[tbuf.index];
+	if (buf1->memory != tbuf.memory) {
+		v4l2_err(&vpif_obj.v4l2_dev, "invalid buffer type\n");
+		goto qbuf_exit;
+	}
+
+	if ((buf1->state == VIDEOBUF_QUEUED) ||
+	    (buf1->state == VIDEOBUF_ACTIVE)) {
+		v4l2_err(&vpif_obj.v4l2_dev, "invalid state\n");
+		goto qbuf_exit;
+	}
+
+	switch (buf1->memory) {
+	case V4L2_MEMORY_MMAP:
+		if (buf1->baddr == 0)
+			goto qbuf_exit;
+		break;
+
+	case V4L2_MEMORY_USERPTR:
+		if (tbuf.length < buf1->bsize)
+			goto qbuf_exit;
+
+		if ((VIDEOBUF_NEEDS_INIT != buf1->state)
+			    && (buf1->baddr != tbuf.m.userptr))
+			vpif_buffer_release(&common->buffer_queue, buf1);
+			buf1->baddr = tbuf.m.userptr;
+		break;
+
+	default:
+		goto qbuf_exit;
+	}
+
+	local_irq_save(flags);
+	ret = vpif_buffer_prepare(&common->buffer_queue, buf1,
+					common->buffer_queue.field);
+	if (ret < 0) {
+		local_irq_restore(flags);
+		goto qbuf_exit;
+	}
+
+	buf1->state = VIDEOBUF_ACTIVE;
+	addr = buf1->boff;
+	common->next_frm = buf1;
+	if (tbuf.type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {
+		common->set_addr((addr + common->ytop_off),
+				 (addr + common->ybtm_off),
+				 (addr + common->ctop_off),
+				 (addr + common->cbtm_off));
+	}
+
+	local_irq_restore(flags);
+	list_add_tail(&buf1->stream, &common->buffer_queue.stream);
+	mutex_unlock(&common->buffer_queue.vb_lock);
+	return 0;
+
+qbuf_exit:
+	mutex_unlock(&common->buffer_queue.vb_lock);
+	return -EINVAL;
+}
+
+static int vpif_s_std(struct file *file, void *priv, v4l2_std_id *std_id)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	int ret = 0;
+
+	if (common->started) {
+		v4l2_err(&vpif_obj.v4l2_dev, "streaming in progress\n");
+		return -EBUSY;
+	}
+
+	/* Call encoder subdevice function to set the standard */
+	mutex_lock_interruptible(&common->lock);
+	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,
+						s_std_output, *std_id);
+	if (ret < 0) {
+		v4l2_err(&vpif_obj.v4l2_dev, "Failed to set output standard\n");
+		goto s_std_exit;
+	}
+
+	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, tuner,
+								s_std, *std_id);
+	if (ret < 0) {
+		v4l2_err(&vpif_obj.v4l2_dev,
+				"Failed to set standard for sub devices\n");
+		goto s_std_exit;
+	}
+
+	ch->video.stdid = *std_id;
+	/* Get the information about the standard from the decoder */
+	vpif_get_std_info(ch);
+	if ((ch->vpifparams.std_info.width *
+		ch->vpifparams.std_info.height * 2) >
+		config_params.channel_bufsize[ch->channel_id]) {
+			v4l2_err(&vpif_obj.v4l2_dev,
+					"invalid std for this size\n");
+
+		ret = -EINVAL;
+		goto s_std_exit;
+	}
+
+	vpif_get_std_info(ch);
+	common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+	/* Configure the default format information */
+	vpif_config_format(ch);
+
+s_std_exit:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpif_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	if (file->f_flags & O_NONBLOCK)
+		/* Call videobuf_dqbuf for non blocking mode */
+		return videobuf_dqbuf(&common->buffer_queue, p, 1);
+	else
+		/* Call videobuf_dqbuf for blocking mode */
+		return videobuf_dqbuf(&common->buffer_queue, p, 0);
+}
+
+static int vpif_streamon(struct file *file, void *priv,
+				enum v4l2_buf_type buftype)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct channel_obj *oth_ch = vpif_obj.dev[!ch->channel_id];
+	struct vpif_params *vpif = &ch->vpifparams;
+	struct vpif_config *vpif_config_data =
+					vpif_dev->platform_data;
+	unsigned long addr = 0;
+	int ret = 0;
+
+	if (!fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		v4l2_err(&vpif_obj.v4l2_dev, "fh->io_allowed\n");
+		return -EACCES;
+	}
+
+	/* If Streaming is already started, return error */
+	if (common->started) {
+		v4l2_err(&vpif_obj.v4l2_dev, "channel->started\n");
+		return -EBUSY;
+	}
+
+	if ((ch->channel_id == VPIF_CHANNEL2_VIDEO
+		&& oth_ch->common[VPIF_VIDEO_INDEX].started &&
+		ch->vpifparams.std_info.ycmux_mode == 0)
+		|| ((ch->channel_id == VPIF_CHANNEL3_VIDEO)
+		&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].started))) {
+		v4l2_err(&vpif_obj.v4l2_dev, "other channel is using\n");
+		return -EBUSY;
+	}
+
+	ret = vpif_check_format(ch, &common->fmt.fmt.pix);
+	if (ret < 0)
+		return ret;
+
+	/* Call videobuf_streamon to start streaming  in videobuf */
+	ret = videobuf_streamon(&common->buffer_queue);
+	if (ret < 0) {
+		v4l2_err(&vpif_obj.v4l2_dev, "videobuf_streamon\n");
+		return ret;
+	}
+
+	mutex_lock_interruptible(&common->lock);
+	/* If buffer queue is empty, return error */
+	if (list_empty(&common->dma_queue)) {
+		v4l2_err(&vpif_obj.v4l2_dev, "buffer queue is empty\n");
+		ret = -EIO;
+		goto streamon_exit;
+	}
+
+	/* Get the next frame from the buffer queue */
+	common->next_frm = common->cur_frm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+
+	list_del(&common->cur_frm->queue);
+	/* Mark state of the current frame to active */
+	common->cur_frm->state = VIDEOBUF_ACTIVE;
+
+	/* Initialize field_id and started member */
+	ch->field_id = 0;
+	common->started = 1;
+	if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		addr = common->cur_frm->boff;
+		/* Calculate the offset for Y and C data  in the buffer */
+		vpif_calculate_offsets(ch);
+
+		if ((ch->vpifparams.std_info.frm_fmt &&
+			((common->fmt.fmt.pix.field != V4L2_FIELD_NONE)
+			&& (common->fmt.fmt.pix.field != V4L2_FIELD_ANY)))
+			|| (!ch->vpifparams.std_info.frm_fmt
+			&& (common->fmt.fmt.pix.field == V4L2_FIELD_NONE))) {
+			v4l2_err(&vpif_obj.v4l2_dev,
+				"conflict in field format and std format\n");
+			ret = -EINVAL;
+			goto streamon_exit;
+		}
+
+		/* clock settings */
+		ret =
+		 vpif_config_data->set_clock(ch->vpifparams.std_info.ycmux_mode,
+						ch->vpifparams.std_info.hd_sd);
+		if (ret < 0) {
+			v4l2_err(&vpif_obj.v4l2_dev, "can't set clock\n");
+			goto streamon_exit;
+		}
+
+		/* set the parameters and addresses */
+		ret = vpif_set_video_params(vpif, ch->channel_id + 2);
+		if (ret < 0)
+			goto streamon_exit;
+
+		common->started = ret;
+		vpif_config_addr(ch, ret);
+		common->set_addr((addr + common->ytop_off),
+				 (addr + common->ybtm_off),
+				 (addr + common->ctop_off),
+				 (addr + common->cbtm_off));
+
+		/* Set interrupt for both the fields in VPIF
+		   Register enable channel in VPIF register */
+		if (VPIF_CHANNEL2_VIDEO == ch->channel_id) {
+			channel2_intr_assert();
+			channel2_intr_enable(1);
+			enable_channel2(1);
+		}
+
+		if ((VPIF_CHANNEL3_VIDEO == ch->channel_id)
+			|| (common->started == 2)) {
+			channel3_intr_assert();
+			channel3_intr_enable(1);
+			enable_channel3(1);
+		}
+		channel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;
+	}
+
+streamon_exit:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpif_streamoff(struct file *file, void *priv,
+				enum v4l2_buf_type buftype)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+
+	if (!fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		v4l2_err(&vpif_obj.v4l2_dev, "fh->io_allowed\n");
+		return -EACCES;
+	}
+
+	if (!common->started) {
+		v4l2_err(&vpif_obj.v4l2_dev, "channel->started\n");
+		return -EINVAL;
+	}
+
+	mutex_lock_interruptible(&common->lock);
+	if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		/* disable channel */
+		if (VPIF_CHANNEL2_VIDEO == ch->channel_id) {
+			enable_channel2(0);
+			channel2_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||
+					(2 == common->started)) {
+			enable_channel3(0);
+			channel3_intr_enable(0);
+		}
+	}
+
+	common->started = 0;
+	mutex_unlock(&common->lock);
+
+	return videobuf_streamoff(&common->buffer_queue);
+}
+
+static int vpif_cropcap(struct file *file, void *priv,
+			struct v4l2_cropcap *crop)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT != crop->type)
+		return -EINVAL;
+
+	crop->bounds.left = crop->bounds.top = 0;
+	crop->defrect.left = crop->defrect.top = 0;
+	crop->defrect.height = crop->bounds.height = common->height;
+	crop->defrect.width = crop->bounds.width = common->width;
+
+	return 0;
+}
+
+static int vpif_enum_output(struct file *file, void *fh,
+				struct v4l2_output *output)
+{
+
+	struct vpif_config *config = vpif_dev->platform_data;
+
+	if (output->index > config->output_count) {
+		v4l2_dbg(1, debug, &vpif_obj.v4l2_dev,
+						"Invalid output index\n");
+		return -EINVAL;
+	}
+
+	strcpy(output->name, config->output[output->index].name);
+	output->type = V4L2_OUTPUT_TYPE_ANALOG;
+	output->std = DM646X_V4L2_STD;
+
+	return 0;
+}
+
+static int vpif_s_output(struct file *file, void *priv, unsigned int i)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+	struct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];
+	struct v4l2_routing route;
+	int ret = 0;
+
+	mutex_lock_interruptible(&common->lock);
+	if (common->started) {
+		v4l2_err(&vpif_obj.v4l2_dev, "Streaming in progress\n");
+		ret = -EBUSY;
+		goto s_output_exit;
+	}
+
+	route.output = i;
+	ret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,
+							s_routing, &route);
+	if (ret < 0)
+		v4l2_err(&vpif_obj.v4l2_dev,
+					"Failed to set output standard\n");
+
+s_output_exit:
+	mutex_unlock(&common->lock);
+	return ret;
+}
+
+static int vpif_g_priority(struct file *file, void *priv, enum v4l2_priority *p)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+
+	*p = v4l2_prio_max(&ch->prio);
+
+	return 0;
+}
+
+static int vpif_s_priority(struct file *file, void *priv, enum v4l2_priority p)
+{
+	struct vpif_fh *fh = priv;
+	struct channel_obj *ch = fh->channel;
+
+	return v4l2_prio_change(&ch->prio, &fh->prio, p);
+}
+
+/* vpif display ioctl operations */
+static const struct v4l2_ioctl_ops vpif_ioctl_ops = {
+	.vidioc_querycap        	= vpif_querycap,
+	.vidioc_g_priority		= vpif_g_priority,
+	.vidioc_s_priority		= vpif_s_priority,
+	.vidioc_enum_fmt_vid_out	= vpif_enum_fmt_vid_out,
+	.vidioc_g_fmt_vid_out  		= vpif_g_fmt_vid_out,
+	.vidioc_s_fmt_vid_out   	= vpif_s_fmt_vid_out,
+	.vidioc_try_fmt_vid_out 	= vpif_try_fmt_vid_out,
+	.vidioc_reqbufs         	= vpif_reqbufs,
+	.vidioc_querybuf        	= vpif_querybuf,
+	.vidioc_qbuf            	= vpif_qbuf,
+	.vidioc_dqbuf           	= vpif_dqbuf,
+	.vidioc_streamon        	= vpif_streamon,
+	.vidioc_streamoff       	= vpif_streamoff,
+	.vidioc_s_std           	= vpif_s_std,
+	.vidioc_enum_output		= vpif_enum_output,
+	.vidioc_s_output		= vpif_s_output,
+	.vidioc_cropcap         	= vpif_cropcap,
+};
+
+static struct v4l2_file_operations vpif_fops = {
+	.owner		= THIS_MODULE,
+	.open		= vpif_open,
+	.release	= vpif_release,
+	.ioctl		= video_ioctl2,
+	.mmap		= vpif_mmap,
+	.poll		= vpif_poll
+};
+
+static struct video_device vpif_video_template = {
+	.name		= "vpif",
+	.vfl_type	= VID_TYPE_CAPTURE,
+	.fops		= &vpif_fops,
+	.minor		= -1,
+	.ioctl_ops	= &vpif_ioctl_ops,
+	.tvnorms	= DM646X_V4L2_STD,
+	.current_norm	= V4L2_STD_PAL,
+
+};
+
+/*Configure the channels, buffer sizei, request irq */
+static int initialize_vpif(void)
+{
+	int free_channel_objects_index;
+	int free_buffer_channel_index;
+	int free_buffer_index;
+	int err = 0, i, j;
+
+	/* Default number of buffers should be 3 */
+	if ((ch2_numbuffers > 0) &&
+	    (ch2_numbuffers < config_params.min_numbuffers))
+		ch2_numbuffers = config_params.min_numbuffers;
+	if ((ch3_numbuffers > 0) &&
+	    (ch3_numbuffers < config_params.min_numbuffers))
+		ch3_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (ch2_bufsize < config_params.min_bufsize[VPIF_CHANNEL2_VIDEO])
+		ch2_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL2_VIDEO];
+	if (ch3_bufsize < config_params.min_bufsize[VPIF_CHANNEL3_VIDEO])
+		ch3_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL3_VIDEO];
+
+	config_params.numbuffers[VPIF_CHANNEL2_VIDEO] = ch2_numbuffers;
+
+	if (ch2_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL2_VIDEO] =
+							ch2_bufsize;
+	}
+	config_params.numbuffers[VPIF_CHANNEL3_VIDEO] = ch3_numbuffers;
+
+	if (ch3_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL3_VIDEO] =
+							ch3_bufsize;
+	}
+
+	/* Allocate memory for six channel objects */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		vpif_obj.dev[i] =
+		    kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!vpif_obj.dev[i]) {
+			free_channel_objects_index = i;
+			err = -ENOMEM;
+			goto vpif_init_free_channel_objects;
+		}
+	}
+
+	free_channel_objects_index = VPIF_DISPLAY_MAX_DEVICES;
+	free_buffer_channel_index = VPIF_DISPLAY_NUM_CHANNELS;
+	free_buffer_index = config_params.numbuffers[i - 1];
+
+	return 0;
+
+vpif_init_free_channel_objects:
+	for (j = 0; j < free_channel_objects_index; j++)
+		kfree(vpif_obj.dev[j]);
+	return err;
+}
+
+/*
+ * vpif_probe: This function creates device entries by register itself to the
+ * V4L2 driver and initializes fields of each channel objects
+ */
+static __init int vpif_probe(struct platform_device *pdev)
+{
+	int i, j = 0, k, q, m, err = 0;
+	struct vpif_config *config;
+	struct channel_obj *ch;
+	struct i2c_adapter *i2c_adap;
+	struct common_obj *common;
+	struct i2c_client *client;
+	struct video_device *vfd;
+	struct resource *res;
+	int subdev_count;
+
+	vpif_dev = &pdev->dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		v4l2_err(vpif_dev->driver,
+				"Error getting platform resource\n");
+		return -ENOENT;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+						vpif_dev->driver->name)) {
+		v4l2_err(vpif_dev->driver, "VPIF: failed request_mem_region\n");
+		return -ENXIO;
+	}
+
+	vpif_base = ioremap_nocache(res->start, res->end - res->start + 1);
+	if (!vpif_base) {
+		v4l2_err(vpif_dev->driver, "Unable to ioremap VPIF reg\n");
+		err = -ENXIO;
+		goto resource_exit;
+	}
+
+	vpif_base_addr_init(vpif_base);
+
+	initialize_vpif();
+
+	err = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);
+	if (err) {
+		v4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");
+		return err;
+	}
+
+	k = 0;
+	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, k))) {
+		for (i = res->start; i <= res->end; i++) {
+			if (request_irq(i, vpif_channel_isr, IRQF_DISABLED,
+					"DM646x_Display",
+				(void *)(&vpif_obj.dev[k]->channel_id)))
+				goto vpif_int_err;
+		}
+		k++;
+	}
+
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+
+		/* Get the pointer to the channel object */
+		ch = vpif_obj.dev[i];
+
+		/* Allocate memory for video device */
+		vfd = video_device_alloc();
+		if (vfd == NULL) {
+			for (j = 0; j < i; j++) {
+				ch = vpif_obj.dev[j];
+				video_device_release(ch->video_dev);
+			}
+			err = -ENOMEM;
+			goto video_dev_alloc_exit;
+		}
+
+		/* Initialize field of video device */
+		*vfd = vpif_video_template;
+		vfd->v4l2_dev = &vpif_obj.v4l2_dev;
+		vfd->release = video_device_release;
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "DM646x_VPIFDisplay_DRIVER_V%d.%d.%d",
+			 (VPIF_DISPLAY_VERSION_CODE >> 16) & 0xff,
+			 (VPIF_DISPLAY_VERSION_CODE >> 8) & 0xff,
+			 (VPIF_DISPLAY_VERSION_CODE) & 0xff);
+
+		/* Set video_dev to the video device */
+		ch->video_dev = vfd;
+	}
+
+	for (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {
+		ch = vpif_obj.dev[j];
+		/* Initialize field of the channel objects */
+		ch->usrs = 0;
+		for (k = 0; k < VPIF_NUMOBJECTS; k++) {
+			ch->common[k].numbuffers = 0;
+			common = &ch->common[k];
+			common->io_usrs = 0;
+			common->started = 0;
+			spin_lock_init(&common->irqlock);
+			mutex_init(&common->lock);
+			common->numbuffers = 0;
+			common->set_addr = NULL;
+			common->ytop_off = common->ybtm_off = 0;
+			common->ctop_off = common->cbtm_off = 0;
+			common->cur_frm = common->next_frm = NULL;
+			memset(&common->fmt, 0, sizeof(common->fmt));
+			common->numbuffers = config_params.numbuffers[k];
+
+		}
+		ch->initialized = 0;
+		ch->channel_id = j;
+		if (j < 2)
+			ch->common[VPIF_VIDEO_INDEX].numbuffers =
+			    config_params.numbuffers[ch->channel_id];
+		else
+			ch->common[VPIF_VIDEO_INDEX].numbuffers = 0;
+
+		memset(&ch->vpifparams, 0, sizeof(ch->vpifparams));
+
+		/* Initialize prio member of channel object */
+		v4l2_prio_init(&ch->prio);
+		ch->common[VPIF_VIDEO_INDEX].fmt.type =
+						V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+		/* register video device */
+		v4l2_dbg(1, debug, &vpif_obj.v4l2_dev,
+				"channel=%x,channel->video_dev=%x\n",
+				(int)ch, (int)&ch->video_dev);
+
+		err = video_register_device(ch->video_dev,
+					  VFL_TYPE_GRABBER, vpif_nr[j]);
+		if (err < 0)
+			goto probe_out;
+
+		video_set_drvdata(ch->video_dev, ch);
+	}
+
+	i2c_adap = i2c_get_adapter(1);
+	config = pdev->dev.platform_data;
+	subdev_count = config->subdev_count;
+	vpif_obj.sd = kmalloc(sizeof(struct v4l2_subdev *) * subdev_count,
+								GFP_KERNEL);
+	if (vpif_obj.sd == NULL) {
+		v4l2_err(&vpif_obj.v4l2_dev,
+			"unable to allocate memory for subdevice pointers\n");
+		err = -ENOMEM;
+		goto probe_out;
+	}
+
+	for (i = 0; i < subdev_count; i++) {
+		list_for_each_entry(client, &i2c_adap->clients, list) {
+		if (!strcmp(client->name, config->subdevinfo[i].name))
+			break;
+		}
+		if (client == NULL) {
+			v4l2_err(&vpif_obj.v4l2_dev, "No Subdevice found\n");
+			err =  -ENODEV;
+			goto probe_subdev_out;
+		}
+
+		/* Get subdevice data from the client */
+		vpif_obj.sd[i] = i2c_get_clientdata(client);
+		if (vpif_obj.sd[i])
+			vpif_obj.sd[i]->grp_id = 1 << i;
+
+		err = v4l2_device_register_subdev(&vpif_obj.v4l2_dev,
+							vpif_obj.sd[i]);
+		if (err) {
+			v4l2_err(&vpif_obj.v4l2_dev,
+				"Error registering v4l2 sub-device\n");
+			goto probe_subdev_out;
+		}
+	}
+
+
+	return 0;
+
+probe_subdev_out:
+	kfree(vpif_obj.sd);
+probe_out:
+	for (k = 0; k < j; k++) {
+		ch = vpif_obj.dev[k];
+		video_unregister_device(ch->video_dev);
+		video_device_release(ch->video_dev);
+		ch->video_dev = NULL;
+	}
+vpif_int_err:
+	v4l2_err(&vpif_obj.v4l2_dev, "VPIF IRQ request failed\n");
+	for (q = k; k >= 0; k--) {
+		for (m = i; m >= res->start; m--)
+			free_irq(m, (void *)(&vpif_obj.dev[k]->channel_id));
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, k-1);
+		m = res->end;
+	}
+	err = -EBUSY;
+video_dev_alloc_exit:
+	iounmap(vpif_base);
+resource_exit:
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	return err;
+}
+
+/*
+ * vpif_remove: It un-register channels from V4L2 driver
+ */
+static int vpif_remove(struct platform_device *device)
+{
+	struct channel_obj *ch;
+	int i;
+
+	v4l2_device_unregister(&vpif_obj.v4l2_dev);
+
+	/* un-register device */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		ch = vpif_obj.dev[i];
+		/* Unregister video device */
+		video_unregister_device(ch->video_dev);
+
+		ch->video_dev = NULL;
+	}
+
+	return 0;
+}
+
+static struct platform_driver vpif_driver = {
+	.driver	= {
+			.name	= "vpif_display",
+			.owner	= THIS_MODULE,
+	},
+	.probe	= vpif_probe,
+	.remove	= vpif_remove,
+};
+
+static __init int vpif_init(void)
+{
+	return platform_driver_register(&vpif_driver);
+}
+
+/*
+ * vpif_cleanup: This function un-registers device and driver to the kernel,
+ * frees requested irq handler and de-allocates memory allocated for channel
+ * objects.
+ */
+static void vpif_cleanup(void)
+{
+	struct platform_device *pdev;
+	struct resource *res;
+	int irq_num;
+	int i = 0;
+
+	pdev = container_of(vpif_dev, struct platform_device, dev);
+
+	while ((res = platform_get_resource(pdev, IORESOURCE_IRQ, i))) {
+		for (irq_num = res->start; irq_num <= res->end; irq_num++)
+			free_irq(irq_num,
+				 (void *)(&vpif_obj.dev[i]->channel_id));
+		i++;
+	}
+
+	iounmap(vpif_base);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+	platform_driver_unregister(&vpif_driver);
+	kfree(vpif_obj.sd);
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++)
+		kfree(vpif_obj.dev[i]);
+}
+
+module_init(vpif_init);
+module_exit(vpif_cleanup);
Index: linux-2.6.29/drivers/media/video/davinci/vpif_display.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/davinci/vpif_display.h	2009-11-20 10:07:18.498470966 -0600
@@ -0,0 +1,174 @@
+/*
+ * DM646x display header file
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef DAVINCIHD_DISPLAY_H
+#define DAVINCIHD_DISPLAY_H
+
+/* Header files */
+#include <linux/videodev2.h>
+#include <linux/version.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf-core.h>
+#include <media/videobuf-dma-contig.h>
+
+#include "vpif.h"
+
+/* Macros */
+#define VPIF_MAJOR_RELEASE	(0)
+#define VPIF_MINOR_RELEASE	(0)
+#define VPIF_BUILD		(1)
+
+#define VPIF_DISPLAY_VERSION_CODE \
+	((VPIF_MAJOR_RELEASE << 16) | (VPIF_MINOR_RELEASE << 8) | VPIF_BUILD)
+
+#define VPIF_VALID_FIELD(field) \
+	(((V4L2_FIELD_ANY == field) || (V4L2_FIELD_NONE == field)) || \
+	(((V4L2_FIELD_INTERLACED == field) || (V4L2_FIELD_SEQ_TB == field)) || \
+	(V4L2_FIELD_SEQ_BT == field)))
+
+#define VPIF_DISPLAY_MAX_DEVICES	(2)
+#define VPIF_SLICED_BUF_SIZE		(256)
+#define VPIF_SLICED_MAX_SERVICES	(3)
+#define VPIF_VIDEO_INDEX		(0)
+#define VPIF_VBI_INDEX			(1)
+#define VPIF_HBI_INDEX			(2)
+
+/* Setting it to 1 as HBI/VBI support yet to be added , else 3*/
+#define VPIF_NUMOBJECTS	(1)
+
+/* Macros */
+#define ISALIGNED(a)    (0 == ((a) & 7))
+
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpif_channel_id {
+	VPIF_CHANNEL2_VIDEO = 0,	/* Channel2 Video */
+	VPIF_CHANNEL3_VIDEO,		/* Channel3 Video */
+};
+
+/* structures */
+
+struct video_obj {
+	enum v4l2_field buf_field;
+	u32 latest_only;		/* indicate whether to return
+					 * most recent displayed frame only */
+	v4l2_std_id stdid;		/* Currently selected or default
+					 * standard */
+};
+
+struct vbi_obj {
+	int num_services;
+	struct vpif_vbi_params vbiparams;	/* vpif parameters for the raw
+						 * vbi data */
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	u8 *fbuffers[VIDEO_MAX_FRAME];		/* List of buffer pointers for
+						 * storing frames */
+	u32 numbuffers;				/* number of buffers */
+	struct videobuf_buffer *cur_frm;	/* Pointer pointing to current
+						 * videobuf_buffer */
+	struct videobuf_buffer *next_frm;	/* Pointer pointing to next
+						 * videobuf_buffer */
+	enum v4l2_memory memory;		/* This field keeps track of
+						 * type of buffer exchange
+						 * method user has selected */
+	struct v4l2_format fmt;			/* Used to store the format */
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						 * video-buf */
+	struct list_head dma_queue;		/* Queue of filled frames */
+	spinlock_t irqlock;			/* Used in video-buf */
+
+	/* channel specifc parameters */
+	struct mutex lock;			/* lock used to access this
+						 * structure */
+	u32 io_usrs;				/* number of users performing
+						 * IO */
+	u8 started;				/* Indicates whether streaming
+						 * started */
+	u32 ytop_off;				/* offset of Y top from the
+						 * starting of the buffer */
+	u32 ybtm_off;				/* offset of Y bottom from the
+						 * starting of the buffer */
+	u32 ctop_off;				/* offset of C top from the
+						 * starting of the buffer */
+	u32 cbtm_off;				/* offset of C bottom from the
+						 * starting of the buffer */
+	/* Function pointer to set the addresses */
+	void (*set_addr) (unsigned long, unsigned long,
+				unsigned long, unsigned long);
+	u32 height;
+	u32 width;
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					 * this channel */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					 * the priority */
+	u32 usrs;			/* number of open instances of
+					 * the channel */
+	u32 field_id;			/* Indicates id of the field
+					 * which is being displayed */
+	u8 initialized;			/* flag to indicate whether
+					 * encoder is initialized */
+
+	enum vpif_channel_id channel_id;/* Identifies channel */
+	struct vpif_params vpifparams;
+	struct common_obj common[VPIF_NUMOBJECTS];
+	struct video_obj video;
+	struct vbi_obj vbi;
+};
+
+/* File handle structure */
+struct vpif_fh {
+	struct channel_obj *channel;	/* pointer to channel object for
+					 * opened device */
+	u8 io_allowed[VPIF_NUMOBJECTS];	/* Indicates whether this file handle
+					 * is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					 * this instance */
+	u8 initialized;			/* Used to keep track of whether this
+					 * file handle has initialized
+					 * channel or not */
+};
+
+/* vpif device structure */
+struct vpif_device {
+	struct v4l2_device v4l2_dev;
+	struct channel_obj *dev[VPIF_DISPLAY_NUM_CHANNELS];
+	struct v4l2_subdev **sd;
+
+};
+
+struct vpif_config_params {
+	u32 min_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+	u32 channel_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+	u8 numbuffers[VPIF_DISPLAY_NUM_CHANNELS];
+	u8 min_numbuffers;
+};
+
+/* Struct which keeps track of the line numbers for the sliced vbi service */
+struct vpif_service_line {
+	u16 service_id;
+	u16 service_line[2];
+	u16 enc_service_id;
+	u8 bytestowrite;
+};
+
+#endif				/* DAVINCIHD_DISPLAY_H */
Index: linux-2.6.29/drivers/media/video/davinci_vpfe.c
===================================================================
--- linux-2.6.29.orig/drivers/media/video/davinci_vpfe.c	2009-11-20 10:07:08.214716665 -0600
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,1136 +0,0 @@
-/*
- *
- *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_vpfe.c */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/kdev_t.h>
-#include <linux/string.h>
-#include <linux/videodev.h>
-#include <linux/wait.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-
-#include <asm/irq.h>
-#include <asm/page.h>
-#include <asm/io.h>
-#include <asm/dma-mapping.h>
-
-#include <media/davinci_vpfe.h>
-
-#define debug_print(x...)	//printk(x)
-
-MODULE_LICENSE("GPL");
-
-static struct v4l2_rect ntsc_bounds = VPFE_WIN_NTSC;
-static struct v4l2_rect pal_bounds = VPFE_WIN_PAL;
-static struct v4l2_fract ntsc_aspect = VPFE_PIXELASPECT_NTSC;
-static struct v4l2_fract pal_aspect = VPFE_PIXELASPECT_PAL;
-static struct v4l2_rect ntscsp_bounds = VPFE_WIN_NTSC_SP;
-static struct v4l2_rect palsp_bounds = VPFE_WIN_PAL_SP;
-static struct v4l2_fract sp_aspect = VPFE_PIXELASPECT_NTSC_SP;
-
-static vpfe_obj vpfe_device = {	/* the default format is NTSC */
-	.usrs = 0,
-	.io_usrs = 0,
-	.std = VPFE_STD_AUTO,
-	.vwin = VPFE_WIN_PAL,
-	.bounds = VPFE_WIN_PAL,
-	.pixelaspect = VPFE_PIXELASPECT_NTSC,
-	.pixelfmt = V4L2_PIX_FMT_UYVY,
-	.field = V4L2_FIELD_INTERLACED,
-	.numbuffers = VPFE_DEFNUM_FBUFS,
-	.ccdc_params = {
-		.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
-		.frm_fmt = CCDC_FRMFMT_INTERLACED,
-		.win = VPFE_WIN_PAL,
-		.fid_pol = CCDC_PINPOL_POSITIVE,
-		.vd_pol = CCDC_PINPOL_POSITIVE,
-		.hd_pol = CCDC_PINPOL_POSITIVE,
-		.bt656_enable = TRUE,
-		.pix_order = CCDC_PIXORDER_CBYCRY,
-		.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
-	},
-	.tvp5146_params = {
-		.mode = TVP5146_MODE_AUTO,
-		.amuxmode = TVP5146_AMUX_COMPOSITE,
-		.enablebt656sync = TRUE
-	},
-        .irqlock = SPIN_LOCK_UNLOCKED
-};
-
-struct v4l2_capability vpfe_drvcap = {
-	.driver = "vpfe driver",
-	.card = "DaVinci EVM",
-	.bus_info = "Platform",
-	.version = VPFE_VERSION_CODE,
-	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING
-};
-
-static int sense_std(v4l2_std_id* std_id)
-{
-	v4l2_std_id id = 0;
-	tvp5146_mode mode;
-	int ret;
-	ret = tvp5146_ctrl(TVP5146_GET_STD, &mode);
-	if(ret < 0)
-		return ret;
-	switch (mode & 0x7) {
-	case TVP5146_MODE_NTSC:
-		id = V4L2_STD_NTSC;
-		break;
-	case TVP5146_MODE_PAL:
-		id = V4L2_STD_PAL;
-		break;
-	case TVP5146_MODE_PAL_M:
-		id = V4L2_STD_PAL_M;
-		break;
-	case TVP5146_MODE_PAL_CN:
-		id = V4L2_STD_PAL_N;
-		break;
-	case TVP5146_MODE_SECAM:
-		id = V4L2_STD_SECAM;
-		break;
-	case TVP5146_MODE_PAL_60:
-		id = V4L2_STD_PAL_60;
-		break;
-	}
-	if (mode & 0x8) {	/* square pixel mode */
-		id <<= 32;
-	}
-	if (mode == TVP5146_MODE_AUTO) {
-		id = VPFE_STD_AUTO;	/* auto-detection for all other modes */
-	} else if (mode == TVP5146_MODE_AUTO_SQP) {
-		id = VPFE_STD_AUTO_SQP;
-	}
-	if(id == 0)
-		return -EINVAL;
-	*std_id =  id;
-	return 0;
-}
-
-static irqreturn_t vpfe_isr(int irq, void *dev_id)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int fid;
-
-	/* check which field we are in hardware */
-	fid = ccdc_getfid();
-	vpfe->field_id ^= 1;	/* switch the software maintained field id */
-	debug_print(KERN_INFO "field id = %x:%x.\n", fid, vpfe->field_id);
-	if (fid == vpfe->field_id) {	/* we are in-sync here, continue */
-		if (fid == 0) {
-			/*  One frame is just being captured. If the next frame
-			is available, release the current frame and move on */
-			if (vpfe->curFrm != vpfe->nextFrm) {
-				vpfe->curFrm->state = STATE_DONE;
-				wake_up_interruptible(&vpfe->curFrm->done);
-				vpfe->curFrm = vpfe->nextFrm;
-			}
-			/* based on whether the two fields are stored interleavely      */
-			/* or separately in memory, reconfigure the CCDC memory address */
-			if (vpfe->field == V4L2_FIELD_SEQ_TB) {
-				u32 addr =
-				    vpfe->curFrm->boff + vpfe->field_offset;
-				ccdc_setfbaddr((unsigned long)addr);
-			}
-	} else if (fid == 1) {
-			/* if one field is just being captured */
-			/* configure the next frame */
-			/* get the next frame from the empty queue */
-			/* if no frame is available, hold on to the current buffer */
-			if (!list_empty(&vpfe->dma_queue)
-			    && vpfe->curFrm == vpfe->nextFrm) {
-				vpfe->nextFrm = list_entry(vpfe->dma_queue.next,
-					struct videobuf_buffer, queue);
-				list_del(&vpfe->nextFrm->queue);
-				vpfe->nextFrm->state = STATE_ACTIVE;
-				ccdc_setfbaddr(
-					(unsigned long)vpfe->nextFrm->boff);
-			}
-			if (vpfe->mode_changed) {
-				ccdc_setwin(&vpfe->ccdc_params);
-				/* update the field offset */
-				vpfe->field_offset =
-				    (vpfe->vwin.height - 2) * vpfe->vwin.width;
-				vpfe->mode_changed = FALSE;
-			}
-		}
-	} else if (fid == 0) {
-		/* recover from any hardware out-of-sync due to */
-		/* possible switch of video source              */
-		/* for fid == 0, sync up the two fids           */
-		/* for fid == 1, no action, one bad frame will  */
-		/* go out, but it is not a big deal             */
-		vpfe->field_id = fid;
-	}
-	debug_print(KERN_INFO "interrupt returned.\n");
-	return IRQ_RETVAL(1);
-}
-
-/* this is the callback function called from videobuf_qbuf() function */
-/* the buffer is prepared and queued into the dma queue */
-static int buffer_prepare(struct videobuf_queue *q,
-			  struct videobuf_buffer *vb,
-			  enum v4l2_field field)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-
-
-	if (vb->state == STATE_NEEDS_INIT) {
-		vb->width  = vpfe->vwin.width;
-		vb->height = vpfe->vwin.height;
-		vb->size   = VPFE_MAX_FBUF_SIZE;
-		vb->field  = field;
-	}
-	vb->state = STATE_PREPARED;
-
-	return 0;
-
-}
-static void
-buffer_config(struct videobuf_queue *q, unsigned int count)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int i;
-	for(i = 0; i < count; i++) {
-		q->bufs[i]->boff = virt_to_phys(vpfe->fbuffers[i]);
-		debug_print(KERN_INFO "buffer address: %x\n", q->bufs[i]->boff);
-	}
-}
-
-static int
-buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	int i;
-	*size = VPFE_MAX_FBUF_SIZE;
-
-
-	for (i = VPFE_DEFNUM_FBUFS; i < *count; i++) {
-		u32 size = PAGE_SIZE << VPFE_MAX_FBUF_ORDER;
-		void *mem = (void *)__get_free_pages(GFP_KERNEL |GFP_DMA,
-						     VPFE_MAX_FBUF_ORDER);
-		if (mem) {
-			unsigned long adr = (unsigned long)mem;
-			while (size > 0) {
-				/* make sure the frame buffers are never
-				   swapped out of memory */
-				SetPageReserved(virt_to_page(adr));
-				adr += PAGE_SIZE;
-				size -= PAGE_SIZE;
-			}
-			vpfe->fbuffers[i] = mem;
-		} else {
-			break;
-		}
-	}
-	*count = vpfe->numbuffers = i;
-
-	return 0;
-}
-
-static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-        /* add the buffer to the DMA queue */
-	list_add_tail(&vb->queue, &vpfe->dma_queue);
-	vb->state = STATE_QUEUED;
-}
-
-static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
-{
-	/* free the buffer if it is not one of the 3 allocated at initializaiton time */
-	if(vb->i < vpfe_device.numbuffers
-	 && vb->i >= VPFE_DEFNUM_FBUFS
-	 && vpfe_device.fbuffers[vb->i]){
-		free_pages((unsigned long)vpfe_device.fbuffers[vb->i],
-			   VPFE_MAX_FBUF_ORDER);
-		vpfe_device.fbuffers[vb->i] = NULL;
-	}
-}
-
-
-static struct videobuf_queue_ops video_qops = {
-	.buf_setup    = buffer_setup,
-	.buf_prepare  = buffer_prepare,
-	.buf_queue    = buffer_queue,
-	.buf_release  = buffer_release,
-	.buf_config   = buffer_config,
-};
-
-
-
-
-static int vpfe_doioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, void *arg)
-{
-	vpfe_obj *vpfe = &vpfe_device;
-	vpfe_fh *fh = file->private_data;
-	int ret = 0;
-	switch (cmd) {
-	case VIDIOC_S_CTRL:
-	case VIDIOC_S_FMT:
-	case VIDIOC_S_STD:
-	case VIDIOC_S_CROP:
-		ret = v4l2_prio_check(&vpfe->prio, &fh->prio);
-		if (0 != ret) {
-			return ret;
-		}
-		break;
-	}
-
-	switch (cmd) {
-	case VIDIOC_QUERYCAP:
-	{
-		struct v4l2_capability *cap =
-		    (struct v4l2_capability *)arg;
-		memset(cap, 0, sizeof(*cap));
-		*cap = vpfe_drvcap;
-		break;
-	}
-	case VIDIOC_ENUM_FMT:
-	{
-		struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
-		u32 index = fmt->index;
-		memset(fmt, 0, sizeof(*fmt));
-		fmt->index = index;
-		if (index == 0) {
-			/* only yuv4:2:2 format is supported at this point */
-			fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-			strcpy(fmt->description,
-			       "YCbCr4:2:2 Interleaved UYUV");
-			fmt->pixelformat = V4L2_PIX_FMT_UYVY;
-		} else if (index == 1) {
-			fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-			strcpy(fmt->description,
-			       "YCbCr4:2:2 Interleaved YUYV");
-			fmt->pixelformat = V4L2_PIX_FMT_YUYV;
-		} else {
-			ret = -EINVAL;
-		}
-		break;
-	}
-	case VIDIOC_G_FMT:
-	{
-		struct v4l2_format *fmt = (struct v4l2_format *)arg;
-		if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret = -EINVAL;
-		} else {
-			struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-			down_interruptible(&vpfe->lock);
-			pixfmt->width = vpfe->vwin.width;
-			pixfmt->height = vpfe->vwin.height;
-			pixfmt->field = vpfe->field;
-			pixfmt->pixelformat = vpfe->pixelfmt;
-			pixfmt->bytesperline = pixfmt->width * 2;
-			pixfmt->sizeimage =
-			    pixfmt->bytesperline * pixfmt->height;
-			pixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;
-			up(&vpfe->lock);
-		}
-		break;
-	}
-	case VIDIOC_S_FMT:
-	{
-		struct v4l2_format *fmt = (struct v4l2_format *)arg;
-		struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-		ccdc_params_ycbcr *params = &vpfe->ccdc_params;
-		if (vpfe->started) {	/* make sure streaming is not started */
-			ret = -EBUSY;
-			break;
-		}
-
-		down_interruptible(&vpfe->lock);
-		if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret = -EINVAL;
-			up(&vpfe->lock);
-			break;
-		}
-		if ((pixfmt->width + vpfe->vwin.left <=
-		     vpfe->bounds.width)
-		    & (pixfmt->height + vpfe->vwin.top <=
-		       vpfe->bounds.height)) {
-			/* this is the case when no scaling is supported */
-			/* crop window is directed modified */
-			vpfe->vwin.height = pixfmt->height;
-			vpfe->vwin.width = pixfmt->width;
-			params->win.width = pixfmt->width;
-			params->win.height = pixfmt->height;
-		} else {
-			ret = -EINVAL;
-			up(&vpfe->lock);
-			break;
-		}
-		/* setup the CCDC parameters accordingly */
-		if (pixfmt->pixelformat == V4L2_PIX_FMT_YUYV) {
-			params->pix_order = CCDC_PIXORDER_YCBYCR;
-			vpfe->pixelfmt = pixfmt->pixelformat;
-		} else if (pixfmt->pixelformat == V4L2_PIX_FMT_UYVY) {
-			params->pix_order = CCDC_PIXORDER_CBYCRY;
-			vpfe->pixelfmt = pixfmt->pixelformat;
-		} else {
-			ret = -EINVAL;	/* not supported format */
-			up(&vpfe->lock);
-			break;
-		}
-		if (pixfmt->field == V4L2_FIELD_NONE
-		    || pixfmt->field == V4L2_FIELD_INTERLACED) {
-			params->buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED;
-			vpfe->field = pixfmt->field;
-		} else if (pixfmt->field == V4L2_FIELD_SEQ_TB) {
-			params->buf_type = CCDC_BUFTYPE_FLD_SEPARATED;
-			vpfe->field = pixfmt->field;
-		} else {
-			ret = -EINVAL;
-		}
-		up(&vpfe->lock);
-		break;
-	}
-	case VIDIOC_TRY_FMT:
-	{
-		struct v4l2_format *fmt = (struct v4l2_format *)arg;
-		if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret = -EINVAL;
-		} else {
-			struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
-			if (pixfmt->width > vpfe->bounds.width
-			    || pixfmt->height > vpfe->bounds.height
-			    || (pixfmt->pixelformat != V4L2_PIX_FMT_UYVY
-				&& pixfmt->pixelformat !=
-				V4L2_PIX_FMT_YUYV)) {
-				ret = -EINVAL;
-			}
-		}
-		break;
-	}
-	case VIDIOC_G_STD:
-	{
-		v4l2_std_id *id = (v4l2_std_id *) arg;
-		*id = vpfe->std;
-		break;
-	}
-	case VIDIOC_S_STD:
-	{
-		v4l2_std_id id = *(v4l2_std_id *) arg;
-		tvp5146_mode mode = TVP5146_MODE_INV;
-		int sqp = 0;
-
-		if (vpfe->started) {	/* make sure streaming is not started */
-			ret = -EBUSY;
-			break;
-		}
-		down_interruptible(&vpfe->lock);
-		if (id & V4L2_STD_625_50) {
-			vpfe->std = id;
-			vpfe->bounds = vpfe->vwin = pal_bounds;
-			vpfe->pixelaspect = pal_aspect;
-			vpfe->ccdc_params.win = pal_bounds;
-
-		} else if (id & V4L2_STD_525_60) {
-			vpfe->std = id;
-			vpfe->bounds = vpfe->vwin = ntsc_bounds;
-			vpfe->pixelaspect = ntsc_aspect;
-			vpfe->ccdc_params.win = ntsc_bounds;
-		} else if (id & VPFE_STD_625_50_SQP) {
-			vpfe->std = id;
-			vpfe->bounds = vpfe->vwin = palsp_bounds;
-			vpfe->pixelaspect = sp_aspect;
-			sqp = 1;
-			id >>= 32;
-		} else if (id & VPFE_STD_525_60_SQP) {
-			vpfe->std = id;
-			sqp = 1;
-			vpfe->std = id;
-			id >>= 32;
-			vpfe->bounds = vpfe->vwin = ntscsp_bounds;
-			vpfe->pixelaspect = sp_aspect;
-			vpfe->ccdc_params.win = ntscsp_bounds;
-		} else if (id & VPFE_STD_AUTO) {
-			mode = TVP5146_MODE_AUTO;
-			vpfe->bounds = vpfe->vwin = pal_bounds;
-			vpfe->pixelaspect = pal_aspect;
-			vpfe->ccdc_params.win = pal_bounds;
-			vpfe->std = id;
-		} else if (id & VPFE_STD_AUTO_SQP) {
-			vpfe->std = id;
-			vpfe->bounds = vpfe->vwin = palsp_bounds;
-			vpfe->pixelaspect = sp_aspect;
-			sqp = 1;
-			mode = TVP5146_MODE_AUTO_SQP;
-			vpfe->pixelaspect = sp_aspect;
-		} else {
-			ret = -EINVAL;
-		}
-		if (id == V4L2_STD_PAL_60) {
-			mode = TVP5146_MODE_PAL_60;
-		} else if (id == V4L2_STD_PAL_M) {
-			mode = TVP5146_MODE_PAL_M;
-		} else if (id == V4L2_STD_PAL_Nc
-			   || id == V4L2_STD_PAL_N) {
-			mode = TVP5146_MODE_PAL_CN;
-		} else if (id & V4L2_STD_PAL) {
-			mode = TVP5146_MODE_PAL;
-		} else if (id & V4L2_STD_NTSC) {
-			mode = TVP5146_MODE_NTSC;
-		} else if (id & V4L2_STD_SECAM) {
-			mode = TVP5146_MODE_SECAM;
-		}
-		vpfe->tvp5146_params.mode = mode | (sqp << 3);
-		tvp5146_ctrl(TVP5146_CONFIG, &vpfe->tvp5146_params);
-
-		up(&vpfe->lock);
-		break;
-	}
-	case VIDIOC_ENUMSTD:
-	{
-		struct v4l2_standard *std = (struct v4l2_standard *)arg;
-		u32 index = std->index;
-		memset(std, 0, sizeof(*std));
-		std->index = index;
-		if (index == 0) {
-			std->id = V4L2_STD_525_60;
-			strcpy(std->name, "SD-525line-30fps");
-			std->framelines = 525;
-			std->frameperiod.numerator = 1001;
-			std->frameperiod.denominator = 30000;
-		} else if (index == 1) {
-			std->id = V4L2_STD_625_50;
-			strcpy(std->name, "SD-625line-25fps");
-			std->framelines = 625;
-			std->frameperiod.numerator = 1;
-			std->frameperiod.denominator = 25;
-		} else if (index == 2) {
-			std->id = VPFE_STD_625_50_SQP;
-			strcpy(std->name,
-			       "SD-625line-25fps square pixel");
-			std->framelines = 625;
-			std->frameperiod.numerator = 1;
-			std->frameperiod.denominator = 25;
-		} else if (index == 3) {
-			std->id = VPFE_STD_525_60_SQP;
-			strcpy(std->name,
-			       "SD-525line-25fps square pixel");
-			std->framelines = 525;
-			std->frameperiod.numerator = 1001;
-			std->frameperiod.denominator = 30000;
-		} else if (index == 4) {
-			std->id = VPFE_STD_AUTO;
-			strcpy(std->name, "automatic detect");
-			std->framelines = 625;
-			std->frameperiod.numerator = 1;
-			std->frameperiod.denominator = 1;
-		} else if (index == 5) {
-			std->id = VPFE_STD_AUTO_SQP;
-			strcpy(std->name,
-			       "automatic detect square pixel");
-			std->framelines = 625;
-			std->frameperiod.numerator = 1;
-			std->frameperiod.denominator = 1;
-		} else {
-			ret = -EINVAL;
-		}
-		break;
-	}
-	case VIDIOC_ENUMINPUT:
-	{
-		u32 index=0;
-		struct v4l2_input *input = (struct v4l2_input *)arg;
-		if (input->index > 1) 	/* only two inputs are available */
-			ret = -EINVAL;
-		index = input->index;
-		memset(input, 0, sizeof(*input));
-                input->index = index;
-		input->type = V4L2_INPUT_TYPE_CAMERA;
-		input->std = V4L2_STD_ALL;
-		if(input->index == 0){
-			sprintf(input->name, "COMPOSITE");
-		}else if(input->index == 1) {
-			sprintf(input->name, "S-VIDEO");
-		}
-		break;
-	}
-	case VIDIOC_G_INPUT:
-	{
-		int *index = (int *)arg;
-		*index = vpfe->tvp5146_params.amuxmode;
-		break;
-	}
-	case VIDIOC_S_INPUT:
-	{
-		int *index = (int *)arg;
-		if (*index > 1 || *index < 0) {
-			ret = -EINVAL;
-		}
-		vpfe->tvp5146_params.amuxmode = *index;
-		tvp5146_ctrl(TVP5146_SET_AMUXMODE, index);
-		break;
-	}
-	case VIDIOC_CROPCAP:
-	{
-		struct v4l2_cropcap *cropcap =
-		    (struct v4l2_cropcap *)arg;
-		cropcap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		down_interruptible(&vpfe->lock);
-		cropcap->bounds = cropcap->defrect = vpfe->vwin;
-		cropcap->pixelaspect = vpfe->pixelaspect;
-		up(&vpfe->lock);
-		break;
-	}
-	case VIDIOC_G_PARM:
-	{
-		struct v4l2_streamparm *parm =
-		    (struct v4l2_streamparm *)arg;
-		if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			/* only capture is supported */
-			ret = -EINVAL;
-		} else {
-			struct v4l2_captureparm *capparm =
-			    &parm->parm.capture;
-			memset(capparm, 0,
-			       sizeof(struct v4l2_captureparm));
-			down_interruptible(&vpfe->lock);
-			if (vpfe->std & V4L2_STD_625_50) {
-				capparm->timeperframe.numerator = 1;
-				capparm->timeperframe.denominator = 25;	/* PAL 25fps */
-			} else {
-				capparm->timeperframe.numerator = 1001;
-				capparm->timeperframe.denominator = 30000;	/*NTSC 29.97fps */
-			}
-			capparm->readbuffers = vpfe->numbuffers;
-			up(&vpfe->lock);
-		}
-		break;
-	}
-	case VIDIOC_G_CTRL:
-		down_interruptible(&vpfe->lock);
-		tvp5146_ctrl(VIDIOC_G_CTRL, arg);
-		up(&vpfe->lock);
-		break;
-	case VIDIOC_S_CTRL:
-		down_interruptible(&vpfe->lock);
-		tvp5146_ctrl(VIDIOC_S_CTRL, arg);
-		up(&vpfe->lock);
-		break;
-	case VIDIOC_QUERYCTRL:
-		down_interruptible(&vpfe->lock);
-		tvp5146_ctrl(VIDIOC_QUERYCTRL, arg);
-		up(&vpfe->lock);
-		break;
-	case VIDIOC_G_CROP:
-	{
-		struct v4l2_crop *crop = arg;
-		if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret = -EINVAL;
-		} else {
-			crop->c = vpfe->vwin;
-		}
-		break;
-	}
-	case VIDIOC_S_CROP:
-	{
-		struct v4l2_crop *crop = arg;
-		ccdc_params_ycbcr *params = &vpfe->ccdc_params;
-		if (vpfe->started) {	/* make sure streaming is not started */
-			ret = -EBUSY;
-			break;
-		}
-		/*adjust the width to 16 pixel boundry */
-                crop->c.width = ((crop->c.width + 15 )/16 ) * 16;
-
-		/* make sure parameters are valid */
-		if (crop->type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-		    && (crop->c.left + crop->c.width
-			<= vpfe->bounds.left + vpfe->bounds.width)
-		    && (crop->c.top + crop->c.height
-			<= vpfe->bounds.top + vpfe->bounds.height)) {
-
-			down_interruptible(&vpfe->lock);
-			vpfe->vwin = crop->c;
-			params->win = vpfe->vwin;
-			up(&vpfe->lock);
-		} else {
-			ret = -EINVAL;
-		}
-		break;
-	}
-	case VIDIOC_QUERYSTD:
-	{
-		v4l2_std_id *id = (v4l2_std_id *) arg;
-		down_interruptible(&vpfe->lock);
-		ret = sense_std(id);
-		up(&vpfe->lock);
-		break;
-	}
-	case VIDIOC_G_PRIORITY:
-	{
-		enum v4l2_priority *p = arg;
-		*p = v4l2_prio_max(&vpfe->prio);
-		break;
-	}
-	case VIDIOC_S_PRIORITY:
-	{
-		enum v4l2_priority *p = arg;
-		ret = v4l2_prio_change(&vpfe->prio, &fh->prio, *p);
-		break;
-	}
-
-	case VIDIOC_REQBUFS:
-		if (vpfe->io_usrs != 0) {
-			ret = -EBUSY;
-			break;
-		}
-		down_interruptible(&vpfe->lock);
-		videobuf_queue_init(&vpfe->bufqueue, &video_qops, NULL,
-		&vpfe->irqlock, V4L2_BUF_TYPE_VIDEO_CAPTURE, vpfe->field,
-		sizeof(struct videobuf_buffer), fh);
-
-		videobuf_set_buftype(&vpfe->bufqueue, VIDEOBUF_BUF_LINEAR);
-
-		fh->io_allowed = TRUE;
-		vpfe->io_usrs = 1;
-		INIT_LIST_HEAD(&vpfe->dma_queue);
-		ret = videobuf_reqbufs(&vpfe->bufqueue, arg);
-		up(&vpfe->lock);
-		break;
-	case VIDIOC_QUERYBUF:
-		ret = videobuf_querybuf(&vpfe->bufqueue, arg);
-		break;
-	case VIDIOC_QBUF:
-		if (!fh->io_allowed)
-			ret = -EACCES;
-		else
-			ret = videobuf_qbuf(&vpfe->bufqueue, arg);
-		break;
-	case VIDIOC_DQBUF:
-		if (!fh->io_allowed)
-			ret = -EACCES;
-		else
-			ret =  videobuf_dqbuf(&vpfe->bufqueue, arg, 0);
-		break;
-	case VIDIOC_STREAMON:
-		if (!fh->io_allowed) {
-			ret = -EACCES;
-			break;
-		}
-		if(vpfe->started){
-			ret = -EBUSY;
-			break;
-		}
-		ret = videobuf_streamon(&vpfe->bufqueue);
-		if(ret) break;
-
-		down_interruptible(&vpfe->lock);
-		/* get the current and next frame buffers */
-		/* we expect at least one buffer is in driver at this point */
-		/* if not, error is returned */
-		if (list_empty(&vpfe->dma_queue)) {
-			ret = -EIO;
-			break;
-		}
-		debug_print(KERN_INFO "cur frame %x.\n",
-			    vpfe->dma_queue.next);
-		vpfe->nextFrm = vpfe->curFrm =
-		    list_entry(vpfe->dma_queue.next,
-			       struct videobuf_buffer, queue);
-		/* remove the buffer from the queue */
-		list_del(&vpfe->curFrm->queue);
-		vpfe->curFrm->state = STATE_ACTIVE;
-
-		/* sense the current video input standard */
-		tvp5146_ctrl(TVP5146_CONFIG, &vpfe->tvp5146_params);
-		/* configure the ccdc and resizer as needed   */
-		/* start capture by enabling CCDC and resizer */
-		ccdc_config_ycbcr(&vpfe->ccdc_params);
-		/* setup the memory address for the frame buffer */
-		ccdc_setfbaddr(((unsigned long)(vpfe->curFrm->boff)));
-		/* enable CCDC */
-		vpfe->field_id = 0;
-		vpfe->started = TRUE;
-		vpfe->mode_changed = FALSE;
-		vpfe->field_offset =
-		    (vpfe->vwin.height - 2) * vpfe->vwin.width;
-		ccdc_enable(TRUE);
-		up(&vpfe->lock);
-		debug_print(KERN_INFO "started video streaming.\n");
-		break;
-	case VIDIOC_STREAMOFF:
-	{
-		if (!fh->io_allowed) {
-			ret = -EACCES;
-			break;
-		}
-		if(!vpfe->started){
-			ret = -EINVAL;
-			break;
-		}
-		/* disable CCDC */
-		down_interruptible(&vpfe->lock);
-		ccdc_enable(FALSE);
-		vpfe->started = FALSE;
-		up(&vpfe->lock);
-		ret = videobuf_streamoff(&vpfe->bufqueue);
-		break;
-	}
-	case VPFE_CMD_CONFIG_CCDC:
-	{
-		/* this can be used directly and bypass the V4L2 APIs */
-		ccdc_params_ycbcr *params = &vpfe->ccdc_params;
-		if(vpfe->started){
-		/* only allowed if streaming is not started */
-			ret = -EBUSY;
-			break;
-		}
-		down_interruptible(&vpfe->lock);
-		/* make sure the other v4l2 related fields
-		   have consistant settings */
-		*params = (*(ccdc_params_ycbcr *) arg);
-		vpfe->vwin = params->win;
-		if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
-			vpfe->field = V4L2_FIELD_INTERLACED;
-		} else if (params->buf_type ==
-		   CCDC_BUFTYPE_FLD_SEPARATED) {
-			vpfe->field = V4L2_FIELD_SEQ_TB;
-		}
-		if (params->pix_order == CCDC_PIXORDER_YCBYCR) {
-			vpfe->pixelfmt = V4L2_PIX_FMT_YUYV;
-		} else if (params->pix_order == CCDC_PIXORDER_CBYCRY) {
-			vpfe->pixelfmt = V4L2_PIX_FMT_UYVY;
-		}
-		up(&vpfe->lock);
-		break;
-	}
-	case VPFE_CMD_CONFIG_TVP5146:
-	/* this can be used directly and bypass the V4L2 APIs */
-	{
-		/* the settings here must be consistant with that of the CCDC's,
-		   driver does not check the consistancy */
-		tvp5146_params *params = (tvp5146_params *) arg;
-		v4l2_std_id std = 0;
-		if(vpfe->started){
-		/* only allowed if streaming is not started */
-			ret = -EBUSY;
-			break;
-		}
-		down_interruptible(&vpfe->lock);
-		/*make sure the other v4l2 related fields have consistant settings */
-		switch (params->mode & 0x7) {
-		case TVP5146_MODE_NTSC:
-			std = V4L2_STD_NTSC;
-			break;
-		case TVP5146_MODE_PAL:
-			std = V4L2_STD_PAL;
-			break;
-		case TVP5146_MODE_PAL_M:
-			std = V4L2_STD_PAL_M;
-			break;
-		case TVP5146_MODE_PAL_CN:
-			std = V4L2_STD_PAL_N;
-			break;
-		case TVP5146_MODE_SECAM:
-			std = V4L2_STD_SECAM;
-			break;
-		case TVP5146_MODE_PAL_60:
-			std = V4L2_STD_PAL_60;
-			break;
-		}
-
-		if (params->mode & 0x8) {	/* square pixel mode */
-			std <<= 32;
-		}
-
-		if (params->mode == TVP5146_MODE_AUTO) {	/* auto-detection modes */
-			std = VPFE_STD_AUTO;
-		} else if (params->mode == TVP5146_MODE_AUTO_SQP) {
-			std = VPFE_STD_AUTO_SQP;
-		}
-
-		if (std & V4L2_STD_625_50) {
-			vpfe->bounds = pal_bounds;
-			vpfe->pixelaspect = pal_aspect;
-		} else if (std & V4L2_STD_525_60) {
-			vpfe->bounds = ntsc_bounds;
-			vpfe->pixelaspect = ntsc_aspect;
-		} else if (std & VPFE_STD_625_50_SQP) {
-			vpfe->bounds = palsp_bounds;
-			vpfe->pixelaspect = sp_aspect;
-		} else if (std & VPFE_STD_525_60_SQP) {
-			vpfe->bounds = ntscsp_bounds;
-			vpfe->pixelaspect = sp_aspect;
-		}
-		vpfe->std = std;
-		tvp5146_ctrl(TVP5146_CONFIG, params);
-		vpfe->tvp5146_params = *params;
-		up(&vpfe->lock);
-		break;
-	}
-	default:
-		ret = -ENOIOCTLCMD;
-		break;
-	}			/* end switch(cmd) */
-	return ret;
-}
-
-static int vpfe_ioctl(struct inode *inode, struct file *file,
-		      unsigned int cmd, unsigned long arg)
-{
-	int ret;
-	ret =  video_usercopy(inode, file, cmd, arg, vpfe_doioctl);
-	if( cmd == VIDIOC_S_FMT || cmd == VIDIOC_TRY_FMT ){
-		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
-			arg, vpfe_doioctl);
-	}
-	return ret;
-}
-
-static int vpfe_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	return videobuf_mmap_mapper(&vpfe_device.bufqueue, vma);
-}
-
-static int vpfe_open(struct inode *inode, struct file *filep)
-{
-	int minor = iminor(inode);
-	vpfe_obj *vpfe = NULL;
-	vpfe_fh *fh = NULL;
-
-	debug_print(KERN_INFO "vpfe: open minor=%d\n", minor);
-
-	/* check to make sure the minor numbers match */
-	if (vpfe_device.video_dev && vpfe_device.video_dev->minor == minor) {
-		vpfe = &vpfe_device;
-	} else {		/* device not found here */
-		return -ENODEV;
-	}
-
-	/* allocate per filehandle data */
-	if ((fh = kmalloc(sizeof(*fh), GFP_KERNEL)) == NULL) {
-		return -ENOMEM;
-	}
-	filep->private_data = fh;
-	fh->dev = vpfe;
-	fh->io_allowed = FALSE;
-	fh->prio = V4L2_PRIORITY_UNSET;
-	v4l2_prio_open(&vpfe->prio, &fh->prio);
-	vpfe->usrs++;
-
-	return 0;
-}
-
-static int vpfe_release(struct inode *inode, struct file *filep)
-{
-	vpfe_fh *fh = filep->private_data;
-	vpfe_obj *vpfe = fh->dev;
-
-	down_interruptible(&vpfe->lock);
-	if (fh->io_allowed) {
-		vpfe->io_usrs = 0;
-		ccdc_enable(FALSE);
-		vpfe->started = FALSE;
-		videobuf_queue_cancel(&vpfe->bufqueue);
-		vpfe->numbuffers = VPFE_DEFNUM_FBUFS;
-	}
-	vpfe->usrs--;
-	v4l2_prio_close(&vpfe->prio, &fh->prio);
-	filep->private_data = NULL;
-	kfree(fh);
-	up(&vpfe->lock);
-
-	return 0;
-}
-
-static struct file_operations vpfe_fops = {
-	.owner = THIS_MODULE,
-	.open = vpfe_open,
-	.release = vpfe_release,
-	.ioctl = vpfe_ioctl,
-	.mmap = vpfe_mmap
-};
-
-static struct video_device vpfe_video_template = {
-	.name = "vpfe",
-	.type = VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
-	.hardware = 0,
-	.fops = &vpfe_fops,
-	.minor = -1,
-};
-
-static void vpfe_platform_release(struct device *device)
-{
-	/* This is called when the reference count goes to zero. */
-}
-
-static int __init vpfe_probe(struct device *device)
-{
-	struct video_device *vfd;
-	vpfe_obj *vpfe = &vpfe_device;
-
-	/* alloc video device */
-	if ((vfd = video_device_alloc()) == NULL) {
-		return -ENOMEM;
-	}
-	*vfd = vpfe_video_template;
-	vfd->dev = device;
-	vfd->release = video_device_release;
-	snprintf(vfd->name, sizeof(vfd->name), "DM644X_VPFE_DRIVER_V%d.%d.%d",
-		 (VPFE_VERSION_CODE >> 16) & 0xff,
-		 (VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
-
-	vpfe->video_dev = vfd;
-	vpfe->usrs = 0;
-	vpfe->io_usrs = 0;
-	vpfe->started = FALSE;
-	vpfe->latest_only = TRUE;
-
-	v4l2_prio_init(&vpfe->prio);
-	init_MUTEX(&vpfe->lock);
-	/* register video device */
-	debug_print(KERN_INFO "trying to register vpfe device.\n");
-	debug_print(KERN_INFO "vpfe=%x,vpfe->video_dev=%x\n", (int)vpfe,
-		    (int)&vpfe->video_dev);
-	if (video_register_device(vpfe->video_dev, VFL_TYPE_GRABBER, -1) < 0) {
-		video_device_release(vpfe->video_dev);
-		vpfe->video_dev = NULL;
-		return -1;
-	}
-
-	debug_print(KERN_INFO "DM644X vpfe: driver version V%d.%d.%d loaded\n",
-		    (VPFE_VERSION_CODE >> 16) & 0xff,
-		    (VPFE_VERSION_CODE >> 8) & 0xff,
-		    (VPFE_VERSION_CODE) & 0xff);
-
-	debug_print(KERN_INFO "vpfe: registered device video%d\n",
-		    vpfe->video_dev->minor & 0x1f);
-
-	/* all done */
-	return 0;
-}
-
-static int vpfe_remove(struct device *device)
-{
-	/* un-register device */
-	video_unregister_device(vpfe_device.video_dev);
-
-	return 0;
-}
-
-#ifdef NEW
-static struct platform_driver vpfe_driver = {
-	.driver = {
-		.name		= "VPFE",
-		.owner		= THIS_MODULE,
-	},
-	.probe			= vpfe_probe,
-	.remove			= vpfe_remove,
-};
-
-#else
-static struct device_driver vpfe_driver = {
-	.name = "vpfe",
-	.bus = &platform_bus_type,
-	.probe = vpfe_probe,
-	.remove = vpfe_remove,
-};
-#endif
-
-static struct platform_device _vpfe_device = {
-	.name = "vpfe",
-	.id = 1,
-	.dev = {
-		.release = vpfe_platform_release,
-		}
-};
-
-static int vpfe_init(void)
-{
-	int i = 0;
-	void *mem;
-	/* allocate memory at initialization time to guarentee availability */
-	for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
-		mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
-					       VPFE_MAX_FBUF_ORDER);
-		if (mem) {
-			unsigned long adr = (unsigned long)mem;
-			u32 size = PAGE_SIZE << VPFE_MAX_FBUF_ORDER;
-			while (size > 0) {
-				/* make sure the frame buffers
-				   are never swapped out of memory */
-				SetPageReserved(virt_to_page(adr));
-				adr += PAGE_SIZE;
-				size -= PAGE_SIZE;
-			}
-			vpfe_device.fbuffers[i] = (u8 *) mem;
-			debug_print(KERN_INFO "memory address %d\t%x\n", i,
-				    mem);
-		} else {
-			while (--i >= 0) {
-				free_pages((unsigned long)vpfe_device.fbuffers[i],
-					   VPFE_MAX_FBUF_ORDER);
-			}
-			debug_print(KERN_INFO
-				    "frame buffer memory allocation failed.\n");
-			return -ENOMEM;
-		}
-	}
-	if (driver_register(&vpfe_driver) != 0) {
-		debug_print(KERN_INFO "driver registration failed\n");
-		return -1;
-	}
-	if (platform_device_register(&_vpfe_device) != 0) {
-		driver_unregister(&vpfe_driver);
-		debug_print(KERN_INFO "device registration failed\n");
-		return -1;
-	}
-
-	ccdc_reset();
-	tvp5146_ctrl(TVP5146_RESET, NULL);
-	/* configure the tvp5146 to default parameters */
-	tvp5146_ctrl(TVP5146_CONFIG, &vpfe_device.tvp5146_params);
-	/* setup interrupt handling */
-	request_irq(IRQ_VDINT0, vpfe_isr, SA_INTERRUPT,
-		    "dm644xv4l2", (void *)&vpfe_device);
-
-	printk(KERN_INFO "DaVinci v4l2 capture driver V1.0 loaded\n");
-	return 0;
-}
-
-static void vpfe_cleanup(void)
-{
-	int i = vpfe_device.numbuffers;
-	platform_device_unregister(&_vpfe_device);
-	driver_unregister(&vpfe_driver);
-	/* disable interrupt */
-	free_irq(IRQ_VDINT0, &vpfe_device);
-
-	while (--i >= 0) {
-		free_pages((unsigned long)vpfe_device.fbuffers[i],
-			   VPFE_MAX_FBUF_ORDER);
-	}
-	debug_print(KERN_INFO "vpfe: un-registered device video.\n");
-}
-
-module_init(vpfe_init);
-module_exit(vpfe_cleanup);
Index: linux-2.6.29/drivers/media/video/mt9v113_davinci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/mt9v113_davinci.c	2009-11-20 10:08:11.605906181 -0600
@@ -0,0 +1,1517 @@
+/*
+ * drivers/media/video/mt9v113.c
+ *
+ * Based on TI TVP5146/47 decoder driver
+ *
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-int-device.h>
+#include <media/mt9v113_davinci.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+
+#include "mt9v113_regs_davinci.h"
+
+/* Module Name */
+#define MT9V113_MODULE_NAME		"mt9v113"
+
+/* Private macros for TVP */
+#define I2C_RETRY_COUNT                 (5)
+#define LOCK_RETRY_COUNT                (5)
+#define LOCK_RETRY_DELAY                (200)
+
+/* Debug functions */
+static int debug = 1;
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+#define dump_reg(client, reg, val)				\
+	do {							\
+		val = mt9v113_read_reg(client, reg);		\
+		v4l_info(client, "Reg(0x%.2X): 0x%.2X\n", reg, val); \
+	} while (0)
+
+/**
+ * enum mt9v113_std - enum for supported standards
+ */
+enum mt9v113_std {
+	MT9V113_STD_VGA = 0,
+	MT9V113_STD_QVGA,
+	MT9V113_STD_INVALID
+};
+
+/**
+ * enum mt9v113_state - enum for different decoder states
+ */
+enum mt9v113_state {
+	STATE_NOT_DETECTED,
+	STATE_DETECTED
+};
+
+/**
+ * struct mt9v113_std_info - Structure to store standard informations
+ * @width: Line width in pixels
+ * @height:Number of active lines
+ * @video_std: Value to write in REG_VIDEO_STD register
+ * @standard: v4l2 standard structure information
+ */
+struct mt9v113_std_info {
+	unsigned long width;
+	unsigned long height;
+	u8 video_std;
+	struct v4l2_standard standard;
+};
+
+/**
+ * struct mt9v113_decoded - decoder object
+ * @v4l2_int_device: Slave handle
+ * @pdata: Board specific
+ * @client: I2C client data
+ * @id: Entry from I2C table
+ * @ver: Chip version
+ * @state: decoder state - detected or not-detected
+ * @pix: Current pixel format
+ * @num_fmts: Number of formats
+ * @fmt_list: Format list
+ * @current_std: Current standard
+ * @num_stds: Number of standards
+ * @std_list: Standards list
+ * @route: input and output routing at chip level
+ */
+struct mt9v113_decoder {
+	struct v4l2_int_device *v4l2_int_device;
+	const struct mt9v113_platform_data *pdata;
+	struct i2c_client *client;
+
+	struct i2c_device_id *id;
+
+	int ver;
+	enum mt9v113_state state;
+
+	struct v4l2_pix_format pix;
+	int num_fmts;
+	const struct v4l2_fmtdesc *fmt_list;
+
+	enum mt9v113_std current_std;
+	int num_stds;
+	struct mt9v113_std_info *std_list;
+
+	struct v4l2_routing route;
+};
+
+/* MT9V113 register set for VGA mode */
+static struct mt9v113_reg mt9v113_vga_reg[] = {
+	{TOK_WRITE, 0x098C, 0x2739},
+	{TOK_WRITE, 0x0990, 0x0000},
+	{TOK_WRITE, 0x098C, 0x273B},
+	{TOK_WRITE, 0x0990, 0x027F},
+	{TOK_WRITE, 0x098C, 0x273D},
+	{TOK_WRITE, 0x0990, 0x0000},
+	{TOK_WRITE, 0x098C, 0x273F},
+	{TOK_WRITE, 0x0990, 0x01DF},
+	{TOK_WRITE, 0x098C, 0x2703},
+	{TOK_WRITE, 0x0990, 0x0280},
+	{TOK_WRITE, 0x098C, 0x2705},
+	{TOK_WRITE, 0x0990, 0x01E0},
+	{TOK_WRITE, 0x098C, 0xA103},
+	{TOK_WRITE, 0x0990, 0x0005},
+	{TOK_DELAY, 0, 100},
+	{TOK_TERM, 0, 0},
+};
+
+/* MT9V113 default register values */
+static struct mt9v113_reg mt9v113_reg_list[] = {
+	{TOK_WRITE, 0x0018, 0x4028},
+	{TOK_DELAY, 0, 100},
+	{TOK_WRITE, 0x001A, 0x0011},
+	{TOK_WRITE, 0x001A, 0x0010},
+	{TOK_WRITE, 0x0018, 0x4028},
+	{TOK_DELAY, 0, 100},
+	{TOK_WRITE, 0x098C, 0x02F0},
+	{TOK_WRITE, 0x0990, 0x0000},
+	{TOK_WRITE, 0x098C, 0x02F2},
+	{TOK_WRITE, 0x0990, 0x0210},
+	{TOK_WRITE, 0x098C, 0x02F4},
+	{TOK_WRITE, 0x0990, 0x001A},
+	{TOK_WRITE, 0x098C, 0x2145},
+	{TOK_WRITE, 0x0990, 0x02F4},
+	{TOK_WRITE, 0x098C, 0xA134},
+	{TOK_WRITE, 0x0990, 0x0001},
+	{TOK_WRITE, 0x31E0, 0x0001},
+	{TOK_WRITE, 0x001A, 0x0210},
+	{TOK_WRITE, 0x001E, 0x0777},
+	{TOK_WRITE, 0x0016, 0x42DF},
+	{TOK_WRITE, 0x0014, 0x2145},
+	{TOK_WRITE, 0x0014, 0x2145},
+	{TOK_WRITE, 0x0010, 0x0431},
+	{TOK_WRITE, 0x0012, 0x0000},
+	{TOK_WRITE, 0x0014, 0x244B},
+	{TOK_WRITE, 0x0014, 0x304B},
+	{TOK_DELAY, 0, 100},
+	{TOK_WRITE, 0x0014, 0xB04A},
+	{TOK_WRITE, 0x098C, 0xAB1F},
+	{TOK_WRITE, 0x0990, 0x00C7},
+	{TOK_WRITE, 0x098C, 0xAB31},
+	{TOK_WRITE, 0x0990, 0x001E},
+	{TOK_WRITE, 0x098C, 0x274F},
+	{TOK_WRITE, 0x0990, 0x0004},
+	{TOK_WRITE, 0x098C, 0x2741},
+	{TOK_WRITE, 0x0990, 0x0004},
+	{TOK_WRITE, 0x098C, 0xAB20},
+	{TOK_WRITE, 0x0990, 0x0054},
+	{TOK_WRITE, 0x098C, 0xAB21},
+	{TOK_WRITE, 0x0990, 0x0046},
+	{TOK_WRITE, 0x098C, 0xAB22},
+	{TOK_WRITE, 0x0990, 0x0002},
+	{TOK_WRITE, 0x098C, 0xAB24},
+	{TOK_WRITE, 0x0990, 0x0005},
+	{TOK_WRITE, 0x098C, 0x2B28},
+	{TOK_WRITE, 0x0990, 0x170C},
+	{TOK_WRITE, 0x098C, 0x2B2A},
+	{TOK_WRITE, 0x0990, 0x3E80},
+	{TOK_WRITE, 0x3210, 0x09A8},
+	{TOK_WRITE, 0x098C, 0x2306},
+	{TOK_WRITE, 0x0990, 0x0315},
+	{TOK_WRITE, 0x098C, 0x2308},
+	{TOK_WRITE, 0x0990, 0xFDDC},
+	{TOK_WRITE, 0x098C, 0x230A},
+	{TOK_WRITE, 0x0990, 0x003A},
+	{TOK_WRITE, 0x098C, 0x230C},
+	{TOK_WRITE, 0x0990, 0xFF58},
+	{TOK_WRITE, 0x098C, 0x230E},
+	{TOK_WRITE, 0x0990, 0x02B7},
+	{TOK_WRITE, 0x098C, 0x2310},
+	{TOK_WRITE, 0x0990, 0xFF31},
+	{TOK_WRITE, 0x098C, 0x2312},
+	{TOK_WRITE, 0x0990, 0xFF4C},
+	{TOK_WRITE, 0x098C, 0x2314},
+	{TOK_WRITE, 0x0990, 0xFE4C},
+	{TOK_WRITE, 0x098C, 0x2316},
+	{TOK_WRITE, 0x0990, 0x039E},
+	{TOK_WRITE, 0x098C, 0x2318},
+	{TOK_WRITE, 0x0990, 0x001C},
+	{TOK_WRITE, 0x098C, 0x231A},
+	{TOK_WRITE, 0x0990, 0x0039},
+	{TOK_WRITE, 0x098C, 0x231C},
+	{TOK_WRITE, 0x0990, 0x007F},
+	{TOK_WRITE, 0x098C, 0x231E},
+	{TOK_WRITE, 0x0990, 0xFF77},
+	{TOK_WRITE, 0x098C, 0x2320},
+	{TOK_WRITE, 0x0990, 0x000A},
+	{TOK_WRITE, 0x098C, 0x2322},
+	{TOK_WRITE, 0x0990, 0x0020},
+	{TOK_WRITE, 0x098C, 0x2324},
+	{TOK_WRITE, 0x0990, 0x001B},
+	{TOK_WRITE, 0x098C, 0x2326},
+	{TOK_WRITE, 0x0990, 0xFFC6},
+	{TOK_WRITE, 0x098C, 0x2328},
+	{TOK_WRITE, 0x0990, 0x0086},
+	{TOK_WRITE, 0x098C, 0x232A},
+	{TOK_WRITE, 0x0990, 0x00B5},
+	{TOK_WRITE, 0x098C, 0x232C},
+	{TOK_WRITE, 0x0990, 0xFEC3},
+	{TOK_WRITE, 0x098C, 0x232E},
+	{TOK_WRITE, 0x0990, 0x0001},
+	{TOK_WRITE, 0x098C, 0x2330},
+	{TOK_WRITE, 0x0990, 0xFFEF},
+	{TOK_WRITE, 0x098C, 0xA348},
+	{TOK_WRITE, 0x0990, 0x0008},
+	{TOK_WRITE, 0x098C, 0xA349},
+	{TOK_WRITE, 0x0990, 0x0002},
+	{TOK_WRITE, 0x098C, 0xA34A},
+	{TOK_WRITE, 0x0990, 0x0090},
+	{TOK_WRITE, 0x098C, 0xA34B},
+	{TOK_WRITE, 0x0990, 0x00FF},
+	{TOK_WRITE, 0x098C, 0xA34C},
+	{TOK_WRITE, 0x0990, 0x0075},
+	{TOK_WRITE, 0x098C, 0xA34D},
+	{TOK_WRITE, 0x0990, 0x00EF},
+	{TOK_WRITE, 0x098C, 0xA351},
+	{TOK_WRITE, 0x0990, 0x0000},
+	{TOK_WRITE, 0x098C, 0xA352},
+	{TOK_WRITE, 0x0990, 0x007F},
+	{TOK_WRITE, 0x098C, 0xA354},
+	{TOK_WRITE, 0x0990, 0x0043},
+	{TOK_WRITE, 0x098C, 0xA355},
+	{TOK_WRITE, 0x0990, 0x0001},
+	{TOK_WRITE, 0x098C, 0xA35D},
+	{TOK_WRITE, 0x0990, 0x0078},
+	{TOK_WRITE, 0x098C, 0xA35E},
+	{TOK_WRITE, 0x0990, 0x0086},
+	{TOK_WRITE, 0x098C, 0xA35F},
+	{TOK_WRITE, 0x0990, 0x007E},
+	{TOK_WRITE, 0x098C, 0xA360},
+	{TOK_WRITE, 0x0990, 0x0082},
+	{TOK_WRITE, 0x098C, 0x2361},
+	{TOK_WRITE, 0x0990, 0x0040},
+	{TOK_WRITE, 0x098C, 0xA363},
+	{TOK_WRITE, 0x0990, 0x00D2},
+	{TOK_WRITE, 0x098C, 0xA364},
+	{TOK_WRITE, 0x0990, 0x00F6},
+	{TOK_WRITE, 0x098C, 0xA302},
+	{TOK_WRITE, 0x0990, 0x0000},
+	{TOK_WRITE, 0x098C, 0xA303},
+	{TOK_WRITE, 0x0990, 0x00EF},
+	{TOK_WRITE, 0x098C, 0xAB20},
+	{TOK_WRITE, 0x0990, 0x0024},
+	{TOK_WRITE, 0x098C, 0xA103},
+	{TOK_WRITE, 0x0990, 0x0006},
+	{TOK_DELAY, 0, 100},
+	{TOK_WRITE, 0x098C, 0xA103},
+	{TOK_WRITE, 0x0990, 0x0005},
+	{TOK_DELAY, 0, 100},
+	{TOK_WRITE, 0x098C, 0x222D},
+	{TOK_WRITE, 0x0990, 0x0088},
+	{TOK_WRITE, 0x098C, 0xA408},
+	{TOK_WRITE, 0x0990, 0x0020},
+	{TOK_WRITE, 0x098C, 0xA409},
+	{TOK_WRITE, 0x0990, 0x0023},
+	{TOK_WRITE, 0x098C, 0xA40A},
+	{TOK_WRITE, 0x0990, 0x0027},
+	{TOK_WRITE, 0x098C, 0xA40B},
+	{TOK_WRITE, 0x0990, 0x002A},
+	{TOK_WRITE, 0x098C, 0x2411},
+	{TOK_WRITE, 0x0990, 0x0088},
+	{TOK_WRITE, 0x098C, 0x2413},
+	{TOK_WRITE, 0x0990, 0x00A4},
+	{TOK_WRITE, 0x098C, 0x2415},
+	{TOK_WRITE, 0x0990, 0x0088},
+	{TOK_WRITE, 0x098C, 0x2417},
+	{TOK_WRITE, 0x0990, 0x00A4},
+	{TOK_WRITE, 0x098C, 0xA404},
+	{TOK_WRITE, 0x0990, 0x0010},
+	{TOK_WRITE, 0x098C, 0xA40D},
+	{TOK_WRITE, 0x0990, 0x0002},
+	{TOK_WRITE, 0x098C, 0xA40E},
+	{TOK_WRITE, 0x0990, 0x0003},
+	{TOK_WRITE, 0x098C, 0xA103},
+	{TOK_WRITE, 0x0990, 0x0006},
+	{TOK_DELAY, 0, 100},
+	/* test pattern all white*/
+	/* {TOK_WRITE, 0x098C, 0xA766},
+	{TOK_WRITE, 0x0990, 0x0001},
+	*/
+	{TOK_WRITE, 0x098C, 0xA103},
+	{TOK_WRITE, 0x0990, 0x0005},
+	{TOK_DELAY, 0, 100},
+	{TOK_TERM, 0, 0},
+};
+
+/* List of image formats supported by mt9v113 
+ * Currently we are using 8 bit mode only, but can be
+ * extended to 10/20 bit mode.
+ */
+static const struct v4l2_fmtdesc mt9v113_fmt_list[] = {
+	{
+	 .index = 0,
+	 .type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+	 .flags = 0,
+	 .description = "8-bit UYVY 4:2:2 Format",
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	},
+};
+
+/*
+ * Supported standards -
+ *
+ * Currently supports two standards only, need to add support for rest of the
+ * modes, like SECAM, etc...
+ */
+static struct mt9v113_std_info mt9v113_std_list[] = {
+	/* Standard: STD_NTSC_MJ */
+	[MT9V113_STD_VGA] = {
+	 .width = VGA_NUM_ACTIVE_PIXELS,
+	 .height = VGA_NUM_ACTIVE_LINES,
+	 .video_std = MT9V113_IMAGE_STD_VGA,
+	 .standard = {
+		      .index = 0,
+		      .id = MT9V113_IMAGE_STD_VGA,
+		      .name = "VGA",
+		      .frameperiod = {1001, 30000},
+		      .framelines = 480
+		     },
+	/* Standard: STD_PAL_BDGHIN */
+	},
+	[MT9V113_STD_QVGA] = {
+	 .width = QVGA_NUM_ACTIVE_PIXELS,
+	 .height = QVGA_NUM_ACTIVE_LINES,
+	 .video_std = MT9V113_IMAGE_STD_QVGA,
+	 .standard = {
+		      .index = 1,
+		      .id = MT9V113_IMAGE_STD_QVGA,
+		      .name = "QVGA",
+		      .frameperiod = {1001, 30000},
+		      .framelines = 320
+		     },
+	},
+	/* Standard: need to add for additional standard */
+};
+/*
+ * Control structure for Auto Gain
+ *     This is temporary data, will get replaced once
+ *     v4l2_ctrl_query_fill supports it.
+ */
+static const struct v4l2_queryctrl mt9v113_autogain_ctrl = {
+	.id = V4L2_CID_AUTOGAIN,
+	.name = "Gain, Automatic",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.minimum = 0,
+	.maximum = 1,
+	.step = 1,
+	.default_value = 1,
+};
+
+static int mt9v113_read_reg(struct i2c_client *client, unsigned short reg)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	unsigned short val = 0;
+
+	if (!client->adapter) {
+		err = -ENODEV;
+		return err;
+	}else {
+		// TODO: addr should be set up where else
+		msg->addr = MT9V113_I2C_ADDR;//client->addr;  
+		msg->flags = 0;
+		msg->len = I2C_TWO_BYTE_TRANSFER;
+		msg->buf = data;
+		data[0] = (reg & I2C_TXRX_DATA_MASK_UPPER) >>
+			    I2C_TXRX_DATA_SHIFT;
+		data[1] = (reg & I2C_TXRX_DATA_MASK);
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			msg->len = I2C_TWO_BYTE_TRANSFER;	/* 2 byte read */
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				val = ((data[0] & I2C_TXRX_DATA_MASK)
+					<< I2C_TXRX_DATA_SHIFT)
+				    | (data[1] & I2C_TXRX_DATA_MASK);
+			}
+		}
+	}
+	return (int)(0x0000ffff & val);
+}
+
+
+
+static int mt9v113_write_reg(struct i2c_client *client, unsigned short reg, unsigned short val)
+{
+	int err = 0;
+	int trycnt = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[4];
+	err = -1;
+
+	v4l_dbg(1, debug, client,
+		 "mt9v113_write_reg reg=0x%x, val=0x%x\n",
+		 reg,val);
+	
+	while ((err < 0) && (trycnt < I2C_RETRY_COUNT)) {
+		trycnt++;
+		if (!client->adapter) {
+			err = -ENODEV;
+		} else {
+			// TODO: addr should be set up where else
+			msg->addr = MT9V113_I2C_ADDR;//client->addr;  
+			msg->flags = 0;
+			msg->len = I2C_FOUR_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (reg & I2C_TXRX_DATA_MASK_UPPER) >>
+			    I2C_TXRX_DATA_SHIFT;
+			data[1] = (reg & I2C_TXRX_DATA_MASK);
+			data[2] = (val & I2C_TXRX_DATA_MASK_UPPER) >>
+			    I2C_TXRX_DATA_SHIFT;
+			data[3] = (val & I2C_TXRX_DATA_MASK);
+			err = i2c_transfer(client->adapter, msg, 1);
+		}
+	}
+	if (err < 0) {
+		printk(KERN_INFO "\n I2C write failed");
+	}
+	return err;
+}
+
+/* configure mux, for DM355 EVM only */
+#ifndef CONFIG_MACH_DM355_LEOPARD
+static int mt9v113_en_mux(struct i2c_client *client)
+{
+	int err = 0;
+	int trycnt = 0;
+	/* unsigned short readval = 0;*/
+
+	struct i2c_msg msg[1];
+	unsigned char data[4];
+	err = -1;
+	printk(KERN_INFO
+		       "\n entering mt9v113_en_mux \n");
+	
+	while ((err < 0) && (trycnt < 5)) {
+		trycnt++;
+		if (!client->adapter) {
+			err = -ENODEV;
+		} else {
+			msg->addr = 0x25;
+			msg->flags = 0;
+			msg->len = I2C_TWO_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (unsigned char)(0x08 & I2C_TXRX_DATA_MASK);
+			data[1] = (unsigned char)(0x80 & I2C_TXRX_DATA_MASK);
+
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err < 0) {
+				printk(KERN_INFO
+				       "\n ERROR in ECP  register write\n");
+			}
+		} 
+	}
+	if (err < 0) {
+		printk(KERN_INFO "\n I2C write failed");
+	}
+	return err;
+}
+#endif
+
+/*
+ * mt9v113_write_regs : Initializes a list of registers
+ *		if token is TOK_TERM, then entire write operation terminates
+ *		if token is TOK_DELAY, then a delay of 'val' msec is introduced
+ *		if token is TOK_SKIP, then the register write is skipped
+ *		if token is TOK_WRITE, then the register write is performed
+ *
+ * reglist - list of registers to be written
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int mt9v113_write_regs(struct i2c_client *client,
+			      const struct mt9v113_reg reglist[])
+{
+	int err;
+	const struct mt9v113_reg *next = reglist;
+
+	for (; next->token != TOK_TERM; next++) {
+		if (next->token == TOK_DELAY) {
+			msleep(next->val);
+			continue;
+		}
+
+		if (next->token == TOK_SKIP)
+			continue;
+
+		err = mt9v113_write_reg(client, next->reg, next->val);
+		if (err < 0) {
+			v4l_err(client, "Write failed. Err[%d]\n", err);
+			return err;
+		}
+	}
+	return 0;
+}
+
+/*
+ * mt9v113_get_current_std:
+ * Returns the current standard 
+ */
+static enum mt9v113_std mt9v113_get_current_std(struct mt9v113_decoder
+						*decoder)
+{
+	return MT9V113_STD_VGA;
+}
+
+/*
+ * Configure the mt9v113 with the current register settings
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int mt9v113_configure(struct mt9v113_decoder *decoder)
+{
+	int err;
+
+	/* common register initialization */
+	err =
+	    mt9v113_write_regs(decoder->client, mt9v113_reg_list);
+	if (err)
+		return err;
+
+//	if (debug)
+//		mt9v113_reg_dump(decoder);
+
+	return 0;
+}
+
+/*
+ * Configure the MT9V113 to VGA mode 
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int mt9v113_vga_mode(struct mt9v113_decoder *decoder)
+{
+	int err;
+
+	err =
+	    mt9v113_write_regs(decoder->client, mt9v113_vga_reg);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+
+/*
+ * Detect if an mt9v113 is present, and if so which revision.
+ * A device is considered to be detected if the chip ID (LSB and MSB)
+ * registers match the expected values.
+ * Any value of the rom version register is accepted.
+ * Returns ENODEV error number if no device is detected, or zero
+ * if a device is detected.
+ */
+static int mt9v113_detect(struct mt9v113_decoder *decoder)
+{
+	unsigned short val=0;
+
+#ifndef CONFIG_MACH_DM355_LEOPARD
+	mt9v113_en_mux(decoder->client);
+#endif
+
+	val = mt9v113_read_reg(decoder->client, REG_CHIP_ID);
+
+	v4l_dbg(1, debug, decoder->client,
+		 "chip id detected 0x%x\n",
+		 val);
+	
+	if (MT9V113_CHIP_ID != val) {
+		/* We didn't read the values we expected, so this must not be
+		 * MT9V113.
+		 */
+		v4l_err(decoder->client,
+			"chip id mismatch read 0x%x, expecting 0x%x\n", val, MT9V113_CHIP_ID);
+		return -ENODEV;
+	}
+
+	decoder->ver = val;
+	decoder->state = STATE_DETECTED;
+
+	v4l_info(decoder->client,
+			"%s found at 0x%x (%s)\n", decoder->client->name,
+			decoder->client->addr << 1,
+			decoder->client->adapter->name);
+
+	return 0;
+}
+
+/*
+ * Following are decoder interface functions implemented by
+ * mt9v113 decoder driver.
+ */
+
+/**
+ * ioctl_querystd - V4L2 decoder interface handler for VIDIOC_QUERYSTD ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @std_id: standard V4L2 std_id ioctl enum
+ *
+ * Returns the current standard detected by mt9v113. If no active input is
+ * detected, returns -EINVAL
+ */
+static int ioctl_querystd(struct v4l2_int_device *s, v4l2_std_id *std_id)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	enum mt9v113_std current_std;
+
+	if (std_id == NULL)
+		return -EINVAL;
+
+	/* get the current standard */
+	current_std = mt9v113_get_current_std(decoder);
+	if (current_std == MT9V113_IMAGE_STD_INVALID)
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+	*std_id = decoder->std_list[current_std].standard.id;
+
+	v4l_dbg(1, debug, decoder->client, "Current STD: %s",
+			decoder->std_list[current_std].standard.name);
+	return 0;
+}
+
+/**
+ * ioctl_s_std - V4L2 decoder interface handler for VIDIOC_S_STD ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @std_id: standard V4L2 v4l2_std_id ioctl enum
+ *
+ * If std_id is supported, sets the requested standard. Otherwise, returns
+ * -EINVAL
+ */
+static int ioctl_s_std(struct v4l2_int_device *s, v4l2_std_id *std_id)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int err, i;
+
+	if (std_id == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < decoder->num_stds; i++)
+		if (*std_id & decoder->std_list[i].standard.id)
+			break;
+
+	if ((i == decoder->num_stds) || (i == MT9V113_STD_INVALID))
+		return -EINVAL;
+
+	err = mt9v113_write_reg(decoder->client, REG_VIDEO_STD,
+				decoder->std_list[i].video_std);
+	if (err)
+		return err;
+
+	decoder->current_std = i;
+	mt9v113_reg_list[REG_VIDEO_STD].val = decoder->std_list[i].video_std;
+
+	v4l_dbg(1, debug, decoder->client, "Standard set to: %s",
+			decoder->std_list[i].standard.name);
+	return 0;
+}
+
+/**
+ * ioctl_s_routing - V4L2 decoder interface handler for VIDIOC_S_INPUT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @index: number of the input
+ *
+ * If index is valid, selects the requested input. Otherwise, returns -EINVAL if
+ * the input is not supported or there is no active signal present in the
+ * selected input.
+ */
+static int ioctl_s_routing(struct v4l2_int_device *s,
+				struct v4l2_routing *route)
+{
+	return 0;
+}
+
+/**
+ * ioctl_queryctrl - V4L2 decoder interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qctrl: standard V4L2 v4l2_queryctrl structure
+ *
+ * If the requested control is supported, returns the control information.
+ * Otherwise, returns -EINVAL if the control is not supported.
+ */
+static int
+ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qctrl)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int err = -EINVAL;
+
+	if (qctrl == NULL)
+		return err;
+
+	switch (qctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* Brightness supported is same as standard one (0-255),
+		 * so make use of standard API provided.
+		 */
+		err = v4l2_ctrl_query_fill_std(qctrl);
+		break;
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+		/* Saturation and Contrast supported is -
+		 *	Contrast: 0 - 255 (Default - 128)
+		 *	Saturation: 0 - 255 (Default - 128)
+		 */
+		err = v4l2_ctrl_query_fill(qctrl, 0, 255, 1, 128);
+		break;
+	case V4L2_CID_HUE:
+		/* Hue Supported is -
+		 *	Hue - -180 - +180 (Default - 0, Step - +180)
+		 */
+		err = v4l2_ctrl_query_fill(qctrl, -180, 180, 180, 0);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		/* Autogain is either 0 or 1*/
+		memcpy(qctrl, &mt9v113_autogain_ctrl,
+				sizeof(struct v4l2_queryctrl));
+		err = 0;
+		break;
+	default:
+		v4l_err(decoder->client,
+			"invalid control id %d\n", qctrl->id);
+		return err;
+	}
+
+	v4l_dbg(1, debug, decoder->client,
+			"Query Control: %s : Min - %d, Max - %d, Def - %d",
+			qctrl->name,
+			qctrl->minimum,
+			qctrl->maximum,
+			qctrl->default_value);
+
+	return err;
+}
+
+/**
+ * ioctl_g_ctrl - V4L2 decoder interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @ctrl: pointer to v4l2_control structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the decoder. Otherwise, returns -EINVAL if the control is not
+ * supported.
+ */
+static int
+ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *ctrl)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ctrl->value = mt9v113_reg_list[REG_BRIGHTNESS].val;
+		break;
+	case V4L2_CID_CONTRAST:
+		ctrl->value = mt9v113_reg_list[REG_CONTRAST].val;
+		break;
+	case V4L2_CID_SATURATION:
+		ctrl->value = mt9v113_reg_list[REG_SATURATION].val;
+		break;
+	case V4L2_CID_HUE:
+		ctrl->value = mt9v113_reg_list[REG_HUE].val;
+		if (ctrl->value == 0x7F)
+			ctrl->value = 180;
+		else if (ctrl->value == 0x80)
+			ctrl->value = -180;
+		else
+			ctrl->value = 0;
+
+		break;
+	case V4L2_CID_AUTOGAIN:
+		ctrl->value = mt9v113_reg_list[REG_AFE_GAIN_CTRL].val;
+		if ((ctrl->value & 0x3) == 3)
+			ctrl->value = 1;
+		else
+			ctrl->value = 0;
+
+		break;
+	default:
+		v4l_err(decoder->client,
+			"invalid control id %d\n", ctrl->id);
+		return -EINVAL;
+	}
+
+	v4l_dbg(1, debug, decoder->client,
+			"Get Control: ID - %d - %d",
+			ctrl->id, ctrl->value);
+	return 0;
+}
+
+/**
+ * ioctl_s_ctrl - V4L2 decoder interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @ctrl: pointer to v4l2_control structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW. Otherwise, returns -EINVAL if the control is not supported.
+ */
+static int
+ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *ctrl)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int err = -EINVAL, value;
+
+	if (ctrl == NULL)
+		return err;
+
+	value = (__s32) ctrl->value;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		if (ctrl->value < 0 || ctrl->value > 255) {
+			v4l_err(decoder->client,
+					"invalid brightness setting %d\n",
+					ctrl->value);
+			return -ERANGE;
+		}
+		err = mt9v113_write_reg(decoder->client, REG_BRIGHTNESS,
+				value);
+		if (err)
+			return err;
+		mt9v113_reg_list[REG_BRIGHTNESS].val = value;
+		break;
+	case V4L2_CID_CONTRAST:
+		if (ctrl->value < 0 || ctrl->value > 255) {
+			v4l_err(decoder->client,
+					"invalid contrast setting %d\n",
+					ctrl->value);
+			return -ERANGE;
+		}
+		err = mt9v113_write_reg(decoder->client, REG_CONTRAST,
+				value);
+		if (err)
+			return err;
+		mt9v113_reg_list[REG_CONTRAST].val = value;
+		break;
+	case V4L2_CID_SATURATION:
+		if (ctrl->value < 0 || ctrl->value > 255) {
+			v4l_err(decoder->client,
+					"invalid saturation setting %d\n",
+					ctrl->value);
+			return -ERANGE;
+		}
+		err = mt9v113_write_reg(decoder->client, REG_SATURATION,
+				value);
+		if (err)
+			return err;
+		mt9v113_reg_list[REG_SATURATION].val = value;
+		break;
+	case V4L2_CID_HUE:
+		if (value == 180)
+			value = 0x7F;
+		else if (value == -180)
+			value = 0x80;
+		else if (value == 0)
+			value = 0;
+		else {
+			v4l_err(decoder->client,
+					"invalid hue setting %d\n",
+					ctrl->value);
+			return -ERANGE;
+		}
+		err = mt9v113_write_reg(decoder->client, REG_HUE,
+				value);
+		if (err)
+			return err;
+		mt9v113_reg_list[REG_HUE].val = value;
+		break;
+	case V4L2_CID_AUTOGAIN:
+		if (value == 1)
+			value = 0x0F;
+		else if (value == 0)
+			value = 0x0C;
+		else {
+			v4l_err(decoder->client,
+					"invalid auto gain setting %d\n",
+					ctrl->value);
+			return -ERANGE;
+		}
+		err = mt9v113_write_reg(decoder->client, REG_AFE_GAIN_CTRL,
+				value);
+		if (err)
+			return err;
+		mt9v113_reg_list[REG_AFE_GAIN_CTRL].val = value;
+		break;
+	default:
+		v4l_err(decoder->client,
+			"invalid control id %d\n", ctrl->id);
+		return err;
+	}
+
+	v4l_dbg(1, debug, decoder->client,
+			"Set Control: ID - %d - %d",
+			ctrl->id, ctrl->value);
+
+	return err;
+}
+
+/**
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl to enumerate supported formats
+ */
+static int
+ioctl_enum_fmt_cap(struct v4l2_int_device *s, struct v4l2_fmtdesc *fmt)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int index;
+
+	if (fmt == NULL)
+		return -EINVAL;
+
+	index = fmt->index;
+	if ((index >= decoder->num_fmts) || (index < 0))
+		return -EINVAL;	/* Index out of bound */
+
+	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	memcpy(fmt, &decoder->fmt_list[index],
+		sizeof(struct v4l2_fmtdesc));
+
+	v4l_dbg(1, debug, decoder->client,
+			"Current FMT: index - %d (%s)",
+			decoder->fmt_list[index].index,
+			decoder->fmt_list[index].description);
+	return 0;
+}
+
+/**
+ * ioctl_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type. This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+static int
+ioctl_try_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int ifmt;
+	struct v4l2_pix_format *pix;
+	enum mt9v113_std current_std;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	pix = &f->fmt.pix;
+
+	/* Calculate height and width based on current standard */
+	current_std = mt9v113_get_current_std(decoder);
+	if (current_std == MT9V113_STD_INVALID)
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+	pix->width = decoder->std_list[current_std].width;
+	pix->height = decoder->std_list[current_std].height;
+
+	for (ifmt = 0; ifmt < decoder->num_fmts; ifmt++) {
+		if (pix->pixelformat ==
+			decoder->fmt_list[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == decoder->num_fmts)
+		ifmt = 0;	/* None of the format matched, select default */
+	pix->pixelformat = decoder->fmt_list[ifmt].pixelformat;
+
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->priv = 0;
+
+	v4l_dbg(1, debug, decoder->client,
+			"Try FMT: pixelformat - %s, bytesperline - %d"
+			"Width - %d, Height - %d",
+			decoder->fmt_list[ifmt].description, pix->bytesperline,
+			pix->width, pix->height);
+	return 0;
+}
+
+/**
+ * ioctl_s_fmt_cap - V4L2 decoder interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ */
+static int
+ioctl_s_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	struct v4l2_pix_format *pix;
+	int rval;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	pix = &f->fmt.pix;
+	rval = ioctl_try_fmt_cap(s, f);
+	if (rval)
+		return rval;
+
+		decoder->pix = *pix;
+
+	return rval;
+}
+
+/**
+ * ioctl_g_fmt_cap - V4L2 decoder interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the decoder's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int
+ioctl_g_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+
+	if (f == NULL)
+		return -EINVAL;
+
+	if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	f->fmt.pix = decoder->pix;
+
+	v4l_dbg(1, debug, decoder->client,
+			"Current FMT: bytesperline - %d"
+			"Width - %d, Height - %d",
+			decoder->pix.bytesperline,
+			decoder->pix.width, decoder->pix.height);
+	return 0;
+}
+
+/**
+ * ioctl_g_parm - V4L2 decoder interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the decoder's video CAPTURE parameters.
+ */
+static int
+ioctl_g_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	struct v4l2_captureparm *cparm;
+	enum mt9v113_std current_std;
+
+	if (a == NULL)
+		return -EINVAL;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	/* get the current standard */
+	current_std = mt9v113_get_current_std(decoder);
+	if (current_std == MT9V113_STD_INVALID)
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+
+	cparm = &a->parm.capture;
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe =
+		decoder->std_list[current_std].standard.frameperiod;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_parm - V4L2 decoder interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the decoder to use the input parameters, if possible. If
+ * not possible, returns the appropriate error code.
+ */
+static int
+ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	struct v4l2_fract *timeperframe;
+	enum mt9v113_std current_std;
+
+	if (a == NULL)
+		return -EINVAL;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;	/* only capture is supported */
+
+	timeperframe = &a->parm.capture.timeperframe;
+
+	/* get the current standard */
+	current_std = mt9v113_get_current_std(decoder);
+	if (current_std == MT9V113_STD_INVALID)
+		return -EINVAL;
+
+	decoder->current_std = current_std;
+
+	*timeperframe =
+	    decoder->std_list[current_std].standard.frameperiod;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_ifparm - V4L2 decoder interface handler for vidioc_int_g_ifparm_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: pointer to standard V4L2 vidioc_int_g_ifparm_num ioctl structure
+ *
+ * Gets slave interface parameters.
+ * Calculates the required xclk value to support the requested
+ * clock parameters in p. This value is returned in the p
+ * parameter.
+ */
+static int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int rval;
+
+	if (p == NULL)
+		return -EINVAL;
+
+	if (NULL == decoder->pdata->ifparm)
+		return -EINVAL;
+
+	rval = decoder->pdata->ifparm(p);
+	if (rval) {
+		v4l_err(decoder->client, "g_ifparm.Err[%d]\n", rval);
+		return rval;
+	}
+
+	p->u.bt656.clock_curr = 27000000; // TODO: read clock rate from sensor
+
+	return 0;
+}
+
+/**
+ * ioctl_g_priv - V4L2 decoder interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold decoder's private data address
+ *
+ * Returns device's (decoder's) private data area address in p parameter
+ */
+static int ioctl_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+
+	if (NULL == decoder->pdata->priv_data_set)
+		return -EINVAL;
+
+	return decoder->pdata->priv_data_set(p);
+}
+
+/**
+ * ioctl_s_power - V4L2 decoder interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ */
+static int ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power on)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int err = 0;
+
+	switch (on) {
+	case V4L2_POWER_OFF:
+		/* Power Down Sequence */
+		err =
+		    mt9v113_write_reg(decoder->client, REG_OPERATION_MODE,
+					0x01);
+		/* Disable mux for mt9v113 data path */
+		if (decoder->pdata->power_set)
+			err |= decoder->pdata->power_set(on);
+		decoder->state = STATE_NOT_DETECTED;
+		break;
+
+	case V4L2_POWER_STANDBY:
+		if (decoder->pdata->power_set)
+			err = decoder->pdata->power_set(on);
+		break;
+
+	case V4L2_POWER_ON:
+		/* Enable mux for mt9v113 data path */
+		if ((decoder->pdata->power_set) &&
+				(decoder->state == STATE_NOT_DETECTED)) {
+
+			err = decoder->pdata->power_set(on);
+			
+			/* Detect the sensor is not already detected */
+			err |= mt9v113_detect(decoder);
+			if (err) {
+				v4l_err(decoder->client,
+						"Unable to detect decoder\n");
+				return err;
+			}
+		}
+		// Only VGA mode for now
+		err |= mt9v113_vga_mode(decoder);
+		break;
+
+	default:
+		err = -ENODEV;
+		break;
+	}
+
+	return err;
+}
+
+/**
+ * ioctl_init - V4L2 decoder interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialize the decoder device (calls mt9v113_configure())
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+//	struct mt9v113_decoder *decoder = s->priv;
+	int err = 0;
+	
+	/* Set default standard to auto */
+	//mt9v113_reg_list[REG_VIDEO_STD].val =
+	//    VIDEO_STD_AUTO_SWITCH_BIT;
+//	err |= mt9v113_configure(decoder);
+//	err |= mt9v113_vga_mode(decoder);
+
+	return err;
+}
+
+/**
+ * ioctl_dev_exit - V4L2 decoder interface handler for vidioc_int_dev_exit_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Delinitialise the dev. at slave detach. The complement of ioctl_dev_init.
+ */
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_init - V4L2 decoder interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master. Returns 0 if
+ * mt9v113 device could be found, otherwise returns appropriate error.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct mt9v113_decoder *decoder = s->priv;
+	int err;
+
+	err = mt9v113_detect(decoder);
+	if (err < 0) {
+		v4l_err(decoder->client,
+			"Unable to detect decoder\n");
+		return err;
+	}
+
+	v4l_info(decoder->client,
+		 "chip version 0x%.2x detected\n", decoder->ver);
+
+	err |= mt9v113_configure(decoder);
+	err |= mt9v113_vga_mode(decoder);
+
+	return 0;
+}
+
+static struct v4l2_int_ioctl_desc mt9v113_ioctl_desc[] = {
+	{vidioc_int_dev_init_num, (v4l2_int_ioctl_func*) ioctl_dev_init},
+	{vidioc_int_dev_exit_num, (v4l2_int_ioctl_func*) ioctl_dev_exit},
+	{vidioc_int_s_power_num, (v4l2_int_ioctl_func*) ioctl_s_power},
+	{vidioc_int_g_priv_num, (v4l2_int_ioctl_func*) ioctl_g_priv},
+	{vidioc_int_g_ifparm_num, (v4l2_int_ioctl_func*) ioctl_g_ifparm},
+	{vidioc_int_init_num, (v4l2_int_ioctl_func*) ioctl_init},
+	{vidioc_int_enum_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_enum_fmt_cap},
+	{vidioc_int_try_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_try_fmt_cap},
+	{vidioc_int_g_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_g_fmt_cap},
+	{vidioc_int_s_fmt_cap_num,
+	 (v4l2_int_ioctl_func *) ioctl_s_fmt_cap},
+	{vidioc_int_g_parm_num, (v4l2_int_ioctl_func *) ioctl_g_parm},
+	{vidioc_int_s_parm_num, (v4l2_int_ioctl_func *) ioctl_s_parm},
+	{vidioc_int_queryctrl_num,
+	 (v4l2_int_ioctl_func *) ioctl_queryctrl},
+	{vidioc_int_g_ctrl_num, (v4l2_int_ioctl_func *) ioctl_g_ctrl},
+	{vidioc_int_s_ctrl_num, (v4l2_int_ioctl_func *) ioctl_s_ctrl},
+	{vidioc_int_querystd_num, (v4l2_int_ioctl_func *) ioctl_querystd},
+	{vidioc_int_s_std_num, (v4l2_int_ioctl_func *) ioctl_s_std},
+	{vidioc_int_s_video_routing_num,
+		(v4l2_int_ioctl_func *) ioctl_s_routing},
+};
+
+static struct v4l2_int_slave mt9v113_slave = {
+	.ioctls = mt9v113_ioctl_desc,
+	.num_ioctls = ARRAY_SIZE(mt9v113_ioctl_desc),
+};
+
+static struct mt9v113_decoder mt9v113_dev = {
+	.state = STATE_NOT_DETECTED,
+
+	.fmt_list = mt9v113_fmt_list,
+	.num_fmts = ARRAY_SIZE(mt9v113_fmt_list),
+
+	.pix = {		/* Default to 8-bit YUV 422 */
+		.width = VGA_NUM_ACTIVE_PIXELS,
+		.height = VGA_NUM_ACTIVE_LINES,
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+		.field = V4L2_FIELD_NONE,
+		.bytesperline = VGA_NUM_ACTIVE_PIXELS * 2,
+		.sizeimage =
+		VGA_NUM_ACTIVE_PIXELS * 2 * VGA_NUM_ACTIVE_LINES,
+		.colorspace = V4L2_COLORSPACE_SMPTE170M,
+		},
+
+	.current_std = MT9V113_STD_VGA,
+	.std_list = mt9v113_std_list,
+	.num_stds = ARRAY_SIZE(mt9v113_std_list),
+
+};
+
+static struct v4l2_int_device mt9v113_int_device = {
+	.module = THIS_MODULE,
+	.name = MT9V113_MODULE_NAME,
+	.priv = &mt9v113_dev,
+	.type = v4l2_int_type_slave,
+	.u = {
+	      .slave = &mt9v113_slave,
+	      },
+};
+
+/**
+ * mt9v113_probe - decoder driver i2c probe handler
+ * @client: i2c driver client device structure
+ *
+ * Register decoder as an i2c client device and V4L2
+ * device.
+ */
+static int
+mt9v113_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct mt9v113_decoder *decoder = &mt9v113_dev;
+	int err;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -EIO;
+
+	decoder->pdata = client->dev.platform_data;
+	if (!decoder->pdata) {
+		v4l_err(client, "No platform data!!\n");
+		return -ENODEV;
+	}
+	/*
+	 * Fetch platform specific data, and configure the
+	 * mt9v113_reg_list[] accordingly. Since this is one
+	 * time configuration, no need to preserve.
+	 */
+
+	/*mt9v113_reg_list[REG_OUTPUT_FORMATTER2].val |=
+			(decoder->pdata->clk_polarity << 1);
+	mt9v113_reg_list[REG_SYNC_CONTROL].val |=
+			((decoder->pdata->hs_polarity << 2) |
+			(decoder->pdata->vs_polarity << 3));
+	*/
+	/*
+	 * Save the id data, required for power up sequence
+	 */
+	decoder->id = (struct i2c_device_id *)id;
+	/* Attach to Master */
+	strcpy(mt9v113_int_device.u.slave->attach_to, decoder->pdata->master);
+	decoder->v4l2_int_device = &mt9v113_int_device;
+	decoder->client = client;
+	i2c_set_clientdata(client, decoder);
+
+	/* Register with V4L2 layer as slave device */
+	err = v4l2_int_device_register(decoder->v4l2_int_device);
+	if (err) {
+		i2c_set_clientdata(client, NULL);
+		v4l_err(client,
+			"Unable to register to v4l2. Err[%d]\n", err);
+
+	} else
+		v4l_info(client, "Registered to v4l2 master %s!!\n",
+				decoder->pdata->master);
+	return 0;
+}
+
+/**
+ * mt9v113_remove - decoder driver i2c remove handler
+ * @client: i2c driver client device structure
+ *
+ * Unregister decoder as an i2c client device and V4L2
+ * device. Complement of mt9v113_probe().
+ */
+static int __exit mt9v113_remove(struct i2c_client *client)
+{
+	struct mt9v113_decoder *decoder = i2c_get_clientdata(client);
+
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	v4l2_int_device_unregister(decoder->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+/*
+ * mt9v113 Init/Power on Sequence
+ */
+static const struct mt9v113_reg mt9v113m_init_reg_seq[] = {
+	{TOK_WRITE, REG_OPERATION_MODE, 0x01},
+	{TOK_WRITE, REG_OPERATION_MODE, 0x00},
+};
+static const struct mt9v113_init_seq mt9v113m_init = {
+	.no_regs = ARRAY_SIZE(mt9v113m_init_reg_seq),
+	.init_reg_seq = mt9v113m_init_reg_seq,
+};
+/*
+ * I2C Device Table -
+ *
+ * name - Name of the actual device/chip.
+ * driver_data - Driver data
+ */
+static const struct i2c_device_id mt9v113_id[] = {
+	{"mt9v113", (unsigned long)&mt9v113m_init},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mt9v113_id);
+
+static struct i2c_driver mt9v113_i2c_driver = {
+	.driver = {
+		   .name = MT9V113_MODULE_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mt9v113_probe,
+	.remove = __exit_p(mt9v113_remove),
+	.id_table = mt9v113_id,
+};
+
+/**
+ * mt9v113_init
+ *
+ * Module init function
+ */
+static int __init mt9v113_init(void)
+{
+	return i2c_add_driver(&mt9v113_i2c_driver);
+}
+
+/**
+ * mt9v113_cleanup
+ *
+ * Module exit function
+ */
+static void __exit mt9v113_cleanup(void)
+{
+	i2c_del_driver(&mt9v113_i2c_driver);
+}
+
+module_init(mt9v113_init);
+module_exit(mt9v113_cleanup);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("MT9V113 linux decoder driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.29/drivers/media/video/mt9v113_regs_davinci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/drivers/media/video/mt9v113_regs_davinci.h	2009-11-20 10:07:18.502464492 -0600
@@ -0,0 +1,294 @@
+/*
+ * drivers/media/video/mt9v113_regs.h
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Contributors:
+ *     Sivaraj R <sivaraj@ti.com>
+ *     Brijesh R Jadav <brijesh.j@ti.com>
+ *     Hardik Shah <hardik.shah@ti.com>
+ *     Manjunath Hadli <mrh@ti.com>
+ *     Karicheri Muralidharan <m-karicheri2@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _MT9V113_REGS_H
+#define _MT9V113_REGS_H
+
+/*
+ * MT9V113 registers
+ */
+#define REG_CHIP_ID				(0x00)
+
+/*
+ * MT9V113 registers
+ */
+#define REG_INPUT_SEL			(0x00)
+#define REG_AFE_GAIN_CTRL		(0x01)
+#define REG_VIDEO_STD			(0x02)
+#define REG_OPERATION_MODE		(0x03)
+#define REG_AUTOSWITCH_MASK		(0x04)
+
+#define REG_COLOR_KILLER		(0x05)
+#define REG_LUMA_CONTROL1		(0x06)
+#define REG_LUMA_CONTROL2		(0x07)
+#define REG_LUMA_CONTROL3		(0x08)
+
+#define REG_BRIGHTNESS			(0x09)
+#define REG_CONTRAST			(0x0A)
+#define REG_SATURATION			(0x0B)
+#define REG_HUE				(0x0C)
+
+#define REG_CHROMA_CONTROL1		(0x0D)
+#define REG_CHROMA_CONTROL2		(0x0E)
+
+/* 0x0F Reserved */
+
+#define REG_COMP_PR_SATURATION		(0x10)
+#define REG_COMP_Y_CONTRAST		(0x11)
+#define REG_COMP_PB_SATURATION		(0x12)
+
+/* 0x13 Reserved */
+
+#define REG_COMP_Y_BRIGHTNESS		(0x14)
+
+/* 0x15 Reserved */
+
+#define REG_AVID_START_PIXEL_LSB	(0x16)
+#define REG_AVID_START_PIXEL_MSB	(0x17)
+#define REG_AVID_STOP_PIXEL_LSB		(0x18)
+#define REG_AVID_STOP_PIXEL_MSB		(0x19)
+
+#define REG_HSYNC_START_PIXEL_LSB	(0x1A)
+#define REG_HSYNC_START_PIXEL_MSB	(0x1B)
+#define REG_HSYNC_STOP_PIXEL_LSB	(0x1C)
+#define REG_HSYNC_STOP_PIXEL_MSB	(0x1D)
+
+#define REG_VSYNC_START_LINE_LSB	(0x1E)
+#define REG_VSYNC_START_LINE_MSB	(0x1F)
+#define REG_VSYNC_STOP_LINE_LSB		(0x20)
+#define REG_VSYNC_STOP_LINE_MSB		(0x21)
+
+#define REG_VBLK_START_LINE_LSB		(0x22)
+#define REG_VBLK_START_LINE_MSB		(0x23)
+#define REG_VBLK_STOP_LINE_LSB		(0x24)
+#define REG_VBLK_STOP_LINE_MSB		(0x25)
+
+/* 0x26 - 0x27 Reserved */
+
+#define REG_FAST_SWTICH_CONTROL		(0x28)
+
+/* 0x29 Reserved */
+
+#define REG_FAST_SWTICH_SCART_DELAY	(0x2A)
+
+/* 0x2B Reserved */
+
+#define REG_SCART_DELAY			(0x2C)
+#define REG_CTI_DELAY			(0x2D)
+#define REG_CTI_CONTROL			(0x2E)
+
+/* 0x2F - 0x31 Reserved */
+
+#define REG_SYNC_CONTROL		(0x32)
+#define REG_OUTPUT_FORMATTER1		(0x33)
+#define REG_OUTPUT_FORMATTER2		(0x34)
+#define REG_OUTPUT_FORMATTER3		(0x35)
+#define REG_OUTPUT_FORMATTER4		(0x36)
+#define REG_OUTPUT_FORMATTER5		(0x37)
+#define REG_OUTPUT_FORMATTER6		(0x38)
+#define REG_CLEAR_LOST_LOCK		(0x39)
+
+#define REG_STATUS1			(0x3A)
+#define REG_STATUS2			(0x3B)
+
+#define REG_AGC_GAIN_STATUS_LSB		(0x3C)
+#define REG_AGC_GAIN_STATUS_MSB		(0x3D)
+
+/* 0x3E Reserved */
+
+#define REG_VIDEO_STD_STATUS		(0x3F)
+#define REG_GPIO_INPUT1			(0x40)
+#define REG_GPIO_INPUT2			(0x41)
+
+/* 0x42 - 0x45 Reserved */
+
+#define REG_AFE_COARSE_GAIN_CH1		(0x46)
+#define REG_AFE_COARSE_GAIN_CH2		(0x47)
+#define REG_AFE_COARSE_GAIN_CH3		(0x48)
+#define REG_AFE_COARSE_GAIN_CH4		(0x49)
+
+#define REG_AFE_FINE_GAIN_PB_B_LSB	(0x4A)
+#define REG_AFE_FINE_GAIN_PB_B_MSB	(0x4B)
+#define REG_AFE_FINE_GAIN_Y_G_CHROMA_LSB	(0x4C)
+#define REG_AFE_FINE_GAIN_Y_G_CHROMA_MSB	(0x4D)
+#define REG_AFE_FINE_GAIN_PR_R_LSB	(0x4E)
+#define REG_AFE_FINE_GAIN_PR_R_MSB	(0x4F)
+#define REG_AFE_FINE_GAIN_CVBS_LUMA_LSB	(0x50)
+#define REG_AFE_FINE_GAIN_CVBS_LUMA_MSB	(0x51)
+
+/* 0x52 - 0x68 Reserved */
+
+#define REG_FBIT_VBIT_CONTROL1		(0x69)
+
+/* 0x6A - 0x6B Reserved */
+
+#define REG_BACKEND_AGC_CONTROL		(0x6C)
+
+/* 0x6D - 0x6E Reserved */
+
+#define REG_AGC_DECREMENT_SPEED_CONTROL	(0x6F)
+#define REG_ROM_VERSION			(0x70)
+
+/* 0x71 - 0x73 Reserved */
+
+#define REG_AGC_WHITE_PEAK_PROCESSING	(0x74)
+#define REG_FBIT_VBIT_CONTROL2		(0x75)
+#define REG_VCR_TRICK_MODE_CONTROL	(0x76)
+#define REG_HORIZONTAL_SHAKE_INCREMENT	(0x77)
+#define REG_AGC_INCREMENT_SPEED		(0x78)
+#define REG_AGC_INCREMENT_DELAY		(0x79)
+
+/* 0x7A - 0x7F Reserved */
+
+#define REG_CHIP_ID_MSB			(0x80)
+#define REG_CHIP_ID_LSB			(0x81)
+
+/* 0x82 Reserved */
+
+#define REG_CPLL_SPEED_CONTROL		(0x83)
+
+/* 0x84 - 0x96 Reserved */
+
+#define REG_STATUS_REQUEST		(0x97)
+
+/* 0x98 - 0x99 Reserved */
+
+#define REG_VERTICAL_LINE_COUNT_LSB	(0x9A)
+#define REG_VERTICAL_LINE_COUNT_MSB	(0x9B)
+
+/* 0x9C - 0x9D Reserved */
+
+#define REG_AGC_DECREMENT_DELAY		(0x9E)
+
+/* 0x9F - 0xB0 Reserved */
+
+#define REG_VDP_TTX_FILTER_1_MASK1	(0xB1)
+#define REG_VDP_TTX_FILTER_1_MASK2	(0xB2)
+#define REG_VDP_TTX_FILTER_1_MASK3	(0xB3)
+#define REG_VDP_TTX_FILTER_1_MASK4	(0xB4)
+#define REG_VDP_TTX_FILTER_1_MASK5	(0xB5)
+#define REG_VDP_TTX_FILTER_2_MASK1	(0xB6)
+#define REG_VDP_TTX_FILTER_2_MASK2	(0xB7)
+#define REG_VDP_TTX_FILTER_2_MASK3	(0xB8)
+#define REG_VDP_TTX_FILTER_2_MASK4	(0xB9)
+#define REG_VDP_TTX_FILTER_2_MASK5	(0xBA)
+#define REG_VDP_TTX_FILTER_CONTROL	(0xBB)
+#define REG_VDP_FIFO_WORD_COUNT		(0xBC)
+#define REG_VDP_FIFO_INTERRUPT_THRLD	(0xBD)
+
+/* 0xBE Reserved */
+
+#define REG_VDP_FIFO_RESET		(0xBF)
+#define REG_VDP_FIFO_OUTPUT_CONTROL	(0xC0)
+#define REG_VDP_LINE_NUMBER_INTERRUPT	(0xC1)
+#define REG_VDP_PIXEL_ALIGNMENT_LSB	(0xC2)
+#define REG_VDP_PIXEL_ALIGNMENT_MSB	(0xC3)
+
+/* 0xC4 - 0xD5 Reserved */
+
+#define REG_VDP_LINE_START		(0xD6)
+#define REG_VDP_LINE_STOP		(0xD7)
+#define REG_VDP_GLOBAL_LINE_MODE	(0xD8)
+#define REG_VDP_FULL_FIELD_ENABLE	(0xD9)
+#define REG_VDP_FULL_FIELD_MODE		(0xDA)
+
+/* 0xDB - 0xDF Reserved */
+
+#define REG_VBUS_DATA_ACCESS_NO_VBUS_ADDR_INCR	(0xE0)
+#define REG_VBUS_DATA_ACCESS_VBUS_ADDR_INCR	(0xE1)
+#define REG_FIFO_READ_DATA			(0xE2)
+
+/* 0xE3 - 0xE7 Reserved */
+
+#define REG_VBUS_ADDRESS_ACCESS1	(0xE8)
+#define REG_VBUS_ADDRESS_ACCESS2	(0xE9)
+#define REG_VBUS_ADDRESS_ACCESS3	(0xEA)
+
+/* 0xEB - 0xEF Reserved */
+
+#define REG_INTERRUPT_RAW_STATUS0	(0xF0)
+#define REG_INTERRUPT_RAW_STATUS1	(0xF1)
+#define REG_INTERRUPT_STATUS0		(0xF2)
+#define REG_INTERRUPT_STATUS1		(0xF3)
+#define REG_INTERRUPT_MASK0		(0xF4)
+#define REG_INTERRUPT_MASK1		(0xF5)
+#define REG_INTERRUPT_CLEAR0		(0xF6)
+#define REG_INTERRUPT_CLEAR1		(0xF7)
+
+/* 0xF8 - 0xFF Reserved */
+
+/* The ID values we are looking for */
+#define MT9V113_CHIP_ID_MSB		(0x51)
+
+#define MT9V113_IMAGE_STD_VGA			(0x01)
+#define MT9V113_IMAGE_STD_QVGA			(0x02)
+#define MT9V113_IMAGE_STD_INVALID		(0xFF)
+
+/*
+ * Status bit
+ */
+#define STATUS_TV_VCR_BIT		(1<<0)
+#define STATUS_HORZ_SYNC_LOCK_BIT	(1<<1)
+#define STATUS_VIRT_SYNC_LOCK_BIT	(1<<2)
+#define STATUS_CLR_SUBCAR_LOCK_BIT	(1<<3)
+#define STATUS_LOST_LOCK_DETECT_BIT	(1<<4)
+#define STATUS_FEILD_RATE_BIT		(1<<5)
+#define STATUS_LINE_ALTERNATING_BIT	(1<<6)
+#define STATUS_PEAK_WHITE_DETECT_BIT	(1<<7)
+
+/* Tokens for register write */
+#define TOK_WRITE                       (0)     /* token for write operation */
+#define TOK_TERM                        (1)     /* terminating token */
+#define TOK_DELAY                       (2)     /* delay token for reg list */
+#define TOK_SKIP                        (3)     /* token to skip a register */
+/**
+ * struct mt9v113_reg - Structure for TVP5146/47 register initialization values
+ * @token - Token: TOK_WRITE, TOK_TERM etc..
+ * @reg - Register offset
+ * @val - Register Value for TOK_WRITE or delay in ms for TOK_DELAY
+ */
+struct mt9v113_reg {
+	unsigned short token;
+	unsigned short reg;
+	unsigned short val;
+};
+
+/**
+ * struct mt9v113_init_seq - Structure for TVP5146/47/46M2/47M1 power up
+ *		Sequence.
+ * @ no_regs - Number of registers to write for power up sequence.
+ * @ init_reg_seq - Array of registers and respective value to write.
+ */
+struct mt9v113_init_seq {
+	unsigned int no_regs;
+	const struct mt9v113_reg *init_reg_seq;
+};
+
+#define MT9V113_CHIP_ID			(0x2280)
+
+#endif				/* ifndef _MT9V113_REGS_H */
Index: linux-2.6.29/drivers/misc/eeprom/at24.c
===================================================================
--- linux-2.6.29.orig/drivers/misc/eeprom/at24.c	2009-11-20 10:07:08.197906423 -0600
+++ linux-2.6.29/drivers/misc/eeprom/at24.c	2009-11-20 10:07:18.502464492 -0600
@@ -53,7 +53,7 @@
 
 struct at24_data {
 	struct at24_platform_data chip;
-	struct at24_iface iface;
+	struct memory_accessor macc;
 	bool use_smbus;
 
 	/*
@@ -226,14 +226,11 @@
 		return status;
 }
 
-static ssize_t at24_bin_read(struct kobject *kobj, struct bin_attribute *attr,
+static ssize_t at24_read(struct at24_data *at24,
 		char *buf, loff_t off, size_t count)
 {
-	struct at24_data *at24;
 	ssize_t retval = 0;
 
-	at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
-
 	if (unlikely(!count))
 		return count;
 
@@ -263,6 +260,15 @@
 	return retval;
 }
 
+static ssize_t at24_bin_read(struct kobject *kobj, struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct at24_data *at24;
+
+	at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	return at24_read(at24, buf, off, count);
+}
+
 
 /*
  * Note that if the hardware write-protect pin is pulled high, the whole
@@ -341,14 +347,11 @@
 	return -ETIMEDOUT;
 }
 
-static ssize_t at24_bin_write(struct kobject *kobj, struct bin_attribute *attr,
+static ssize_t at24_write(struct at24_data *at24,
 		char *buf, loff_t off, size_t count)
 {
-	struct at24_data *at24;
 	ssize_t retval = 0;
 
-	at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
-
 	if (unlikely(!count))
 		return count;
 
@@ -378,6 +381,15 @@
 	return retval;
 }
 
+static ssize_t at24_bin_write(struct kobject *kobj, struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct at24_data *at24;
+
+	at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	return at24_write(at24, buf, off, count);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -386,20 +398,20 @@
  * data generated on the manufacturing floor.
  */
 
-static ssize_t at24_iface_read(struct at24_iface *iface, char *buf,
-			      off_t offset, size_t count)
+static ssize_t at24_macc_read(struct memory_accessor *macc, char *buf,
+			 off_t offset, size_t count)
 {
-	struct at24_data *at24 = container_of(iface, struct at24_data, iface);
+	struct at24_data *at24 = container_of(macc, struct at24_data, macc);
 
-	return at24_eeprom_read(at24, buf, offset, count);
+	return at24_read(at24, buf, offset, count);
 }
 
-static ssize_t at24_iface_write(struct at24_iface *iface, char *buf,
-			       off_t offset, size_t count)
+static ssize_t at24_macc_write(struct memory_accessor *macc, char *buf,
+			  off_t offset, size_t count)
 {
-	struct at24_data *at24 = container_of(iface, struct at24_data, iface);
+	struct at24_data *at24 = container_of(macc, struct at24_data, macc);
 
-	return at24_eeprom_write(at24, buf, offset, count);
+	return at24_write(at24, buf, offset, count);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -470,9 +482,6 @@
 		goto err_out;
 	}
 
-	at24->iface.read = at24_iface_read;
-	at24->iface.write = at24_iface_write;
-
 	mutex_init(&at24->lock);
 	at24->use_smbus = use_smbus;
 	at24->chip = chip;
@@ -487,6 +496,8 @@
 	at24->bin.read = at24_bin_read;
 	at24->bin.size = chip.byte_len;
 
+	at24->macc.read = at24_macc_read;
+
 	writable = !(chip.flags & AT24_FLAG_READONLY);
 	if (writable) {
 		if (!use_smbus || i2c_check_functionality(client->adapter,
@@ -494,6 +505,8 @@
 
 			unsigned write_max = chip.page_size;
 
+			at24->macc.write = at24_macc_write;
+
 			at24->bin.write = at24_bin_write;
 			at24->bin.attr.mode |= S_IWUSR;
 
@@ -546,7 +559,7 @@
 
 	/* export data to kernel code */
 	if (chip.setup)
-		chip.setup(&at24->iface, chip.context);
+		chip.setup(&at24->macc, chip.context);
 
 	return 0;
 
Index: linux-2.6.29/drivers/misc/eeprom/at25.c
===================================================================
--- linux-2.6.29.orig/drivers/misc/eeprom/at25.c	2009-11-20 10:07:08.186065529 -0600
+++ linux-2.6.29/drivers/misc/eeprom/at25.c	2009-11-20 10:07:18.506468075 -0600
@@ -30,6 +30,7 @@
 
 struct at25_data {
 	struct spi_device	*spi;
+	struct memory_accessor	mem;
 	struct mutex		lock;
 	struct spi_eeprom	chip;
 	struct bin_attribute	bin;
@@ -75,6 +76,13 @@
 	struct spi_transfer	t[2];
 	struct spi_message	m;
 
+	if (unlikely(offset >= at25->bin.size))
+		return 0;
+	if ((offset + count) > at25->bin.size)
+		count = at25->bin.size - offset;
+	if (unlikely(!count))
+		return count;
+
 	cp = command;
 	*cp++ = AT25_READ;
 
@@ -127,13 +135,6 @@
 	dev = container_of(kobj, struct device, kobj);
 	at25 = dev_get_drvdata(dev);
 
-	if (unlikely(off >= at25->bin.size))
-		return 0;
-	if ((off + count) > at25->bin.size)
-		count = at25->bin.size - off;
-	if (unlikely(!count))
-		return count;
-
 	return at25_ee_read(at25, buf, off, count);
 }
 
@@ -146,6 +147,13 @@
 	unsigned		buf_size;
 	u8			*bounce;
 
+	if (unlikely(off >= at25->bin.size))
+		return -EFBIG;
+	if ((off + count) > at25->bin.size)
+		count = at25->bin.size - off;
+	if (unlikely(!count))
+		return count;
+
 	/* Temp buffer starts with command and address */
 	buf_size = at25->chip.page_size;
 	if (buf_size > io_limit)
@@ -253,18 +261,31 @@
 	dev = container_of(kobj, struct device, kobj);
 	at25 = dev_get_drvdata(dev);
 
-	if (unlikely(off >= at25->bin.size))
-		return -EFBIG;
-	if ((off + count) > at25->bin.size)
-		count = at25->bin.size - off;
-	if (unlikely(!count))
-		return count;
-
 	return at25_ee_write(at25, buf, off, count);
 }
 
 /*-------------------------------------------------------------------------*/
 
+/* Let in-kernel code access the eeprom data. */
+
+static ssize_t at25_mem_read(struct memory_accessor *mem, char *buf,
+			 off_t offset, size_t count)
+{
+	struct at25_data *at25 = container_of(mem, struct at25_data, mem);
+
+	return at25_ee_read(at25, buf, offset, count);
+}
+
+static ssize_t at25_mem_write(struct memory_accessor *mem, char *buf,
+			  off_t offset, size_t count)
+{
+	struct at25_data *at25 = container_of(mem, struct at25_data, mem);
+
+	return at25_ee_write(at25, buf, offset, count);
+}
+
+/*-------------------------------------------------------------------------*/
+
 static int at25_probe(struct spi_device *spi)
 {
 	struct at25_data	*at25 = NULL;
@@ -317,6 +338,10 @@
 	at25->addrlen = addrlen;
 
 	/* Export the EEPROM bytes through sysfs, since that's convenient.
+	 * And maybe to other kernel code; it might hold a board's Ethernet
+	 * address, or board-specific calibration data generated on the
+	 * manufacturing floor.
+	 *
 	 * Default to root-only access to the data; EEPROMs often hold data
 	 * that's sensitive for read and/or write, like ethernet addresses,
 	 * security codes, board-specific manufacturing calibrations, etc.
@@ -324,17 +349,22 @@
 	at25->bin.attr.name = "eeprom";
 	at25->bin.attr.mode = S_IRUSR;
 	at25->bin.read = at25_bin_read;
+	at25->mem.read = at25_mem_read;
 
 	at25->bin.size = at25->chip.byte_len;
 	if (!(chip->flags & EE_READONLY)) {
 		at25->bin.write = at25_bin_write;
 		at25->bin.attr.mode |= S_IWUSR;
+		at25->mem.write = at25_mem_write;
 	}
 
 	err = sysfs_create_bin_file(&spi->dev.kobj, &at25->bin);
 	if (err)
 		goto fail;
 
+	if (chip->setup)
+		chip->setup(&at25->mem, chip->context);
+
 	dev_info(&spi->dev, "%Zd %s %s eeprom%s, pagesize %u\n",
 		(at25->bin.size < 1024)
 			? at25->bin.size
Index: linux-2.6.29/drivers/net/dm9000.c
===================================================================
--- linux-2.6.29.orig/drivers/net/dm9000.c	2009-11-20 10:07:08.302156291 -0600
+++ linux-2.6.29/drivers/net/dm9000.c	2009-11-20 10:08:11.685852956 -0600
@@ -758,7 +758,11 @@
 	if (db->tx_pkt_cnt > 1)
 		return 1;
 
+	netif_stop_queue(dev);
+
 	spin_lock_irqsave(&db->lock, flags);
+	/* Disable all interrupts */
+	//iow(db, DM9000_IMR, IMR_PAR);
 
 	/* Move data to DM9000 TX RAM */
 	writeb(DM9000_MWCMD, db->io_addr);
@@ -783,11 +787,18 @@
 		netif_stop_queue(dev);
 	}
 
-	spin_unlock_irqrestore(&db->lock, flags);
-
 	/* free this SKB */
 	dev_kfree_skb(skb);
 
+        /* Re-enable resource check */
+        if (db->tx_pkt_cnt == 1)
+                netif_wake_queue(dev);
+
+	/* Re-enable interrupt */
+	//iow(db, DM9000_IMR, IMR_PAR | IMR_PTM | IMR_PRM);
+
+	spin_unlock_irqrestore(&db->lock, flags);
+	
 	return 0;
 }
 
Index: linux-2.6.29/include/linux/i2c/at24.h
===================================================================
--- linux-2.6.29.orig/include/linux/i2c/at24.h	2009-11-20 10:07:08.374419401 -0600
+++ linux-2.6.29/include/linux/i2c/at24.h	2009-11-20 10:07:18.506468075 -0600
@@ -2,6 +2,7 @@
 #define _LINUX_AT24_H
 
 #include <linux/types.h>
+#include <linux/memory.h>
 
 /*
  * As seen through Linux I2C, differences between the most common types of I2C
@@ -15,13 +16,6 @@
  * is bigger than what the chip actually supports!
  */
 
-struct at24_iface {
-	ssize_t (*read)(struct at24_iface *, char *buf, off_t offset,
-			size_t count);
-	ssize_t (*write)(struct at24_iface *, char *buf, off_t offset,
-			 size_t count);
-};
-
 struct at24_platform_data {
 	u32		byte_len;		/* size (sum of all addr) */
 	u16		page_size;		/* for writes */
@@ -31,7 +25,7 @@
 #define AT24_FLAG_IRUGO		0x20	/* sysfs-entry will be world-readable */
 #define AT24_FLAG_TAKE8ADDR	0x10	/* take always 8 addresses (24c00) */
 
-	int             (*setup)(struct at24_iface *, void *context);
+	void		(*setup)(struct memory_accessor *, void *context);
 	void		*context;
 };
 
Index: linux-2.6.29/include/linux/memory.h
===================================================================
--- linux-2.6.29.orig/include/linux/memory.h	2009-11-20 10:07:08.381794642 -0600
+++ linux-2.6.29/include/linux/memory.h	2009-11-20 10:07:18.506468075 -0600
@@ -99,4 +99,15 @@
 #define hotplug_memory_notifier(fn, pri) do { } while (0)
 #endif
 
+/*
+ * 'struct memory_accessor' is a generic interface to provide
+ * in-kernel access to persistent memory such as i2c or SPI EEPROMs
+ */
+struct memory_accessor {
+	ssize_t (*read)(struct memory_accessor *, char *buf, off_t offset,
+			size_t count);
+	ssize_t (*write)(struct memory_accessor *, const char *buf,
+			 off_t offset, size_t count);
+};
+
 #endif /* _LINUX_MEMORY_H_ */
Index: linux-2.6.29/include/linux/spi/eeprom.h
===================================================================
--- linux-2.6.29.orig/include/linux/spi/eeprom.h	2009-11-20 10:07:08.366156059 -0600
+++ linux-2.6.29/include/linux/spi/eeprom.h	2009-11-20 10:07:18.506468075 -0600
@@ -1,6 +1,8 @@
 #ifndef __LINUX_SPI_EEPROM_H
 #define __LINUX_SPI_EEPROM_H
 
+#include <linux/memory.h>
+
 /*
  * Put one of these structures in platform_data for SPI EEPROMS handled
  * by the "at25" driver.  On SPI, most EEPROMS understand the same core
@@ -17,6 +19,10 @@
 #define	EE_ADDR2	0x0002			/* 16 bit addrs */
 #define	EE_ADDR3	0x0004			/* 24 bit addrs */
 #define	EE_READONLY	0x0008			/* disallow writes */
+
+	/* for exporting this chip's data to other kernel code */
+	void (*setup)(struct memory_accessor *mem, void *context);
+	void *context;
 };
 
 #endif /* __LINUX_SPI_EEPROM_H */
Index: linux-2.6.29/include/media/ccdc_davinci.h
===================================================================
--- linux-2.6.29.orig/include/media/ccdc_davinci.h	2009-11-20 10:07:08.313893260 -0600
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,144 +0,0 @@
-/*
- *
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* ccdc_davinci.h */
-
-#ifndef CCDC_DAVINCI_H
-#define CCDC_DAVINCI_H
-#include <linux/types.h>
-
-#ifdef __KERNEL__
-#include <asm/arch/hardware.h>
-#include <asm/io.h>
-#endif
-
-#include <linux/videodev.h>
-
-typedef enum ccdc_pixfmt {
-	CCDC_PIXFMT_RAW = 0,
-	CCDC_PIXFMT_YCBCR_16BIT = 1,
-	CCDC_PIXFMT_YCBCR_8BIT = 2
-} ccdc_pixfmt;
-
-typedef enum ccdc_frmfmt {
-	CCDC_FRMFMT_PROGRESSIVE = 0,
-	CCDC_FRMFMT_INTERLACED = 1
-} ccdc_frmfmt;
-
-typedef enum ccdc_pinpol {
-	CCDC_PINPOL_POSITIVE = 0,
-	CCDC_PINPOL_NEGATIVE = 1
-} ccdc_pinpol;
-
-/* PIXEL ORDER IN MEMORY from LSB to MSB */
-/* only applicable for 8-bit input mode  */
-typedef enum ccdc_pixorder {
-	CCDC_PIXORDER_CBYCRY = 1,
-	CCDC_PIXORDER_YCBYCR = 0
-} ccdc_pixorder;
-
-typedef enum ccdc_buftype {
-	CCDC_BUFTYPE_FLD_INTERLEAVED,
-	CCDC_BUFTYPE_FLD_SEPARATED
-} ccdc_buftype;
-
-typedef struct v4l2_rect ccdc_imgwin;
-
-typedef struct ccdc_params_ycbcr {
-	ccdc_pixfmt pix_fmt;	/* pixel format                     */
-	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame  */
-	ccdc_imgwin win;	/* video window                     */
-	ccdc_pinpol fid_pol;	/* field id polarity                */
-	ccdc_pinpol vd_pol;	/* vertical sync polarity           */
-	ccdc_pinpol hd_pol;	/* horizontal sync polarity         */
-	int bt656_enable;	/* enable BT.656 embedded sync mode */
-	ccdc_pixorder pix_order;/* cb:y:cr:y or y:cb:y:cr in memory */
-	ccdc_buftype buf_type;	/* interleaved or separated fields  */
-} ccdc_params_ycbcr;
-
-#ifdef __KERNEL__
-/**************************************************************************\
-* Register OFFSET Definitions
-\**************************************************************************/
-#define PID                             0x0
-#define PCR                             0x4
-#define SYN_MODE                        0x8
-#define HD_VD_WID                       0xc
-#define PIX_LINES                       0x10
-#define HORZ_INFO                       0x14
-#define VERT_START                      0x18
-#define VERT_LINES                      0x1c
-#define CULLING                         0x20
-#define HSIZE_OFF                       0x24
-#define SDOFST                          0x28
-#define SDR_ADDR                        0x2c
-#define CLAMP                           0x30
-#define DCSUB                           0x34
-#define COLPTN                          0x38
-#define BLKCMP                          0x3c
-#define FPC                             0x40
-#define FPC_ADDR                        0x44
-#define VDINT                           0x48
-#define ALAW                            0x4c
-#define REC656IF                        0x50
-#define CCDCFG                          0x54
-#define FMTCFG                          0x58
-#define FMT_HORZ                        0x5c
-#define FMT_VERT                        0x50
-#define FMT_ADDR0                       0x64
-#define FMT_ADDR1                       0x68
-#define FMT_ADDR2                       0x6c
-#define FMT_ADDR3                       0x70
-#define FMT_ADDR4                       0x74
-#define FMT_ADDR5                       0x78
-#define FMT_ADDR6                       0x7c
-#define FMT_ADDR7                       0x80
-#define PRGEVEN_0                       0x84
-#define PRGEVEN_1                       0x88
-#define PRGODD_0                        0x8c
-#define PRGODD_1                        0x90
-#define VP_OUT                          0x94
-
-#define CCDC_IOBASE                     (0x01c70400)
-
-#define regw(val, reg)    davinci_writel(val, (reg)+CCDC_IOBASE)
-#define regr(reg)         davinci_readl((reg)+CCDC_IOBASE)
-
-extern void ccdc_reset(void);
-extern void ccdc_config_ycbcr(ccdc_params_ycbcr * params);
-extern void ccdc_setwin(ccdc_params_ycbcr * params);
-
-/* inline functions that must be fast because they are called frequently */
-static inline void ccdc_enable(int flag)
-{
-	regw(flag, PCR);
-}
-
-static inline void ccdc_setfbaddr(unsigned long paddr)
-{
-	regw(paddr & 0xffffffe0, SDR_ADDR);
-}
-
-static inline int ccdc_getfid(void)
-{
-	int fid = (regr(SYN_MODE) >> 15) & 0x1;
-	return fid;
-}
-#endif
-
-#endif /* CCDC_DAVINCI_H */
Index: linux-2.6.29/include/media/davinci/ccdc_common.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/media/davinci/ccdc_common.h	2009-11-20 10:07:18.506468075 -0600
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2008-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ **************************************************************************/
+#ifndef _CCDC_COMMON_H
+#define _CCDC_COMMON_H
+enum ccdc_pixfmt {
+	CCDC_PIXFMT_RAW = 0,
+	CCDC_PIXFMT_YCBCR_16BIT = 1,
+	CCDC_PIXFMT_YCBCR_8BIT = 2
+};
+
+enum ccdc_frmfmt {
+	CCDC_FRMFMT_PROGRESSIVE = 0,
+	CCDC_FRMFMT_INTERLACED = 1
+};
+
+/* PIXEL ORDER IN MEMORY from LSB to MSB */
+/* only applicable for 8-bit input mode  */
+enum ccdc_pixorder {
+	CCDC_PIXORDER_CBYCRY = 1,
+	CCDC_PIXORDER_YCBYCR = 0
+};
+
+enum ccdc_buftype {
+	CCDC_BUFTYPE_FLD_INTERLEAVED,
+	CCDC_BUFTYPE_FLD_SEPARATED
+};
+
+enum ccdc_pinpol {
+	CCDC_PINPOL_POSITIVE = 0,
+	CCDC_PINPOL_NEGATIVE = 1
+};
+#endif
Index: linux-2.6.29/include/media/davinci/ccdc_hw_device.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/media/davinci/ccdc_hw_device.h	2009-11-20 10:07:18.506468075 -0600
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ccdc device API
+ */
+#ifndef _CCDC_HW_DEVICE_H
+#define _CCDC_HW_DEVICE_H
+
+#ifdef __KERNEL__
+#include <linux/videodev2.h>
+#include <linux/device.h>
+#include <media/davinci/vpfe_types.h>
+#include <media/davinci/ccdc_common.h>
+/*
+ * Maximum number of capture channels supported by VPFE
+ */
+#define CCDC_CAPTURE_NUM_CHANNELS 1
+/*
+ * vpfe hw interface
+ */
+struct ccdc_hw_device {
+
+	/* vpfe device name */
+	char name[30];
+
+	/* Pointer to initialize function to initialize ccdc device */
+	int (*open) (struct device *dev);
+	/* Set of functions pointers for control related functions.
+	 * Use queryctrl of decoder interface to check if it is a decoder
+	 * control id. If not passed to ccdc to process it
+	 */
+	/* set ccdc base address */
+	void (*set_ccdc_base)(void *base, int size);
+
+	/* set vpss base address */
+	void (*set_vpss_base)(void *base, int size);
+
+	/* get ccdc base */
+	void * (*get_ccdc_base)(void);
+
+	/* get vpss base */
+	void * (*get_vpss_base)(void);
+
+	void (*enable) (int en);
+	/*
+	 * Pointer to function to enable or disable ccdc
+	 */
+	u32 (*reset) (void);
+	/* reset sbl. only for 6446 */
+	void (*enable_out_to_sdram) (int en);
+	/* Pointer to function to set hw frame type */
+	int (*set_hw_if_type) (enum vpfe_hw_if_type iface);
+	/* get interface parameters */
+	int (*get_hw_if_params) (struct vpfe_hw_if_param *param);
+	/* Pointer to function to set parameters. Used
+	 * for implementing VPFE_S_CCDC_PARAMS
+	 */
+	int (*setparams) (void *params);
+	/* Pointer to function to get parameter. Used
+	 * for implementing VPFE_G_CCDC_PARAMS
+	 */
+	int (*getparams) (void *params);
+	/* Pointer to function to configure ccdc */
+	int (*configure) (void);
+
+	/* enumerate hw pix formats */
+	int (*enum_pix)(enum vpfe_hw_pix_format *hw_pix, int i);
+	/* Pointer to function to set buffer type */
+	int (*set_buftype) (enum ccdc_buftype buf_type);
+	/* Pointer to function to get buffer type */
+	int (*get_buftype) (enum ccdc_buftype *buf_type);
+	/* Pointer to function to set frame format */
+	int (*set_frame_format) (enum ccdc_frmfmt frm_fmt);
+	/* Pointer to function to get frame format */
+	int (*get_frame_format) (enum ccdc_frmfmt *frm_fmt);
+	/* Pointer to function to set buffer type */
+	int (*get_pixelformat) (enum vpfe_hw_pix_format *pixfmt);
+	/* Pointer to function to get pixel format. Uses V4L2 type */
+	int (*set_pixelformat) (enum vpfe_hw_pix_format pixfmt);
+	/* Pointer to function to set image window */
+	int (*set_image_window) (struct v4l2_rect *win);
+	/* Pointer to function to set image window */
+	int (*get_image_window) (struct v4l2_rect *win);
+	/* Pointer to function to get line length */
+	int (*get_line_length) (unsigned int *len);
+
+	/* Query SoC control IDs */
+	int (*queryctrl)(struct v4l2_queryctrl *qctrl);
+	/* Set SoC control */
+	int (*setcontrol)(struct v4l2_control *ctrl);
+	/* Get SoC control */
+	int (*getcontrol)(struct v4l2_control *ctrl);
+	/* Pointer to function to set current standard info */
+	/* Pointer to function to set frame buffer address */
+	void (*setfbaddr) (unsigned long addr);
+	/* Pointer to function to get field id */
+	int (*getfid) (void);
+	/* Pointer to deinitialize function */
+	int (*close) (struct device *dev);
+};
+
+#endif
+#endif
Index: linux-2.6.29/include/media/davinci/vpfe_capture.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/media/davinci/vpfe_capture.h	2009-11-20 10:07:18.510465233 -0600
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2008-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _VPFE_CAPTURE_H
+#define _VPFE_CAPTURE_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev2.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-int-device.h>
+#include <media/videobuf-dma-contig.h>
+#include <media/davinci/ccdc_hw_device.h>
+
+#define VPFE_CAPTURE_NUM_DECODERS        5
+
+/* Macros */
+#define VPFE_MAJOR_RELEASE              0
+#define VPFE_MINOR_RELEASE              0
+#define VPFE_BUILD                      1
+#define VPFE_CAPTURE_VERSION_CODE       ((VPFE_MAJOR_RELEASE << 16) | \
+	(VPFE_MINOR_RELEASE << 8)  | \
+	VPFE_BUILD)
+
+#define VPFE_VALID_FIELD(field)  ((V4L2_FIELD_ANY == field) || \
+	(V4L2_FIELD_NONE == field) || \
+	(V4L2_FIELD_INTERLACED == field) || \
+	(V4L2_FIELD_SEQ_TB == field))
+
+#define VPFE_VALID_BUFFER_TYPE(buftype)	{ \
+			(V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) }
+
+#define VPFE_CAPTURE_MAX_DEVICES	1
+#define VPFE_MAX_DECODER_STD		50
+#define VPFE_TIMER_COUNT		5
+#define VPFE_SLICED_BUF_SIZE		256
+#define VPFE_SLICED_MAX_SERVICES	3
+#define VPFE_HBI_INDEX			2
+#define VPFE_VBI_INDEX			1
+#define VPFE_VIDEO_INDEX		0
+
+/* Define for device type to be passed in init */
+#define	MT9T001				0
+#define	TVP5146				1
+#define	MT9T031				2
+#define	MT9P031				3
+#define TVP7002				4
+
+#define VPFE_NUMBER_OF_OBJECTS		1
+
+/* Macros */
+#define ISALIGNED(a)    (0 == (a % 32))
+#define ISEXTERNALCMD(cmd)       ((VPFE_CMD_S_DECODER_PARAMS == cmd) || \
+		(VPFE_CMD_G_DECODER_PARAMS == cmd) || \
+		(VPFE_CMD_S_CCDC_PARAMS == cmd) || \
+		(VPFE_CMD_G_CCDC_PARAMS == cmd) || \
+		(VPFE_CMD_CONFIG_CCDC_YCBCR == cmd) || \
+		(VPFE_CMD_CONFIG_CCDC_RAW == cmd) || \
+		(VPFE_CMD_CONFIG_TVP5146 == cmd) || \
+		(VPFE_CMD_S_MT9T001_PARAMS == cmd) || \
+		(VPFE_CMD_G_MT9T001_PARAMS == cmd))
+
+#include <media/v4l2-dev.h>
+#define VPFE_MAX_SECOND_RESOLUTION_SIZE  (640 * 480 * 2)
+#define ROUND32(x)	((((x)+31) >> 5) << 5)
+#define ISNULL(val) ((val == NULL) ? 1 : 0)
+#define VPFE_MAX_PIX_FORMATS	6
+enum vpfe_irq_use_type {
+	VPFE_USE_CCDC_IRQ,
+	VPFE_USE_IMP_IRQ,
+	VPFE_NO_IRQ
+};
+
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpfe_channel_id {
+	/* Channel0 Video */
+	VPFE_CHANNEL0_VIDEO = 0,
+	/* Channel1 Video */
+	VPFE_CHANNEL1_VIDEO,
+};
+
+/* structures */
+/* Table to keep track of the standards supported in all the decoders */
+struct vpfe_decoder_std_tbl {
+	u8 dec_idx;
+	u8 std_idx;
+	v4l2_std_id std;
+};
+
+enum output_src {
+	VPFE_CCDC_OUT = 1,
+	VPFE_IMP_PREV_OUT = 2,
+	VPFE_IMP_RSZ_OUT = 4
+};
+
+struct vpfe_pixel_format {
+	unsigned int pix_fmt;
+	char *desc;
+	enum vpfe_hw_pix_format hw_fmt;
+};
+
+struct vpfe_std_info {
+	int activepixels;
+	int activelines;
+	/* current frame format */
+	int frame_format;
+};
+
+#define VPFE_MAX_DEC_INPUTS	5
+
+/* To map high level input name to decoder input */
+struct vpfe_dec_input {
+	char dec_name[32];
+	struct v4l2_input input;
+	struct v4l2_routing route;
+	int routing_supported;
+};
+
+struct vpfe_capture_input {
+	int num_inputs;
+	struct vpfe_dec_input inputs[VPFE_MAX_DEC_INPUTS];
+	int current_input;
+};
+
+struct video_obj {
+	/* Keeps track of the information about the standard */
+	struct vpfe_std_info std_info;
+	/* index into std table */
+	int index;
+	/* All inputs to the driver */
+	struct vpfe_capture_input *input;
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	/* List of buffer pointers for storing frames */
+	u8 *fbuffers[VIDEO_MAX_FRAME];
+	/* number of buffers in fbuffers */
+	u32 numbuffers;
+	/* Pointer pointing to current v4l2_buffer */
+	struct videobuf_buffer *curFrm;
+	/* Pointer pointing to next v4l2_buffer */
+	struct videobuf_buffer *nextFrm;
+	/* This field keeps track of type of buffer exchange mechanism
+	 * user has selected
+	 */
+	enum v4l2_memory memory;
+	/* Used to store pixel format */
+	struct v4l2_format fmt;
+	/* Buffer queue used in video-buf */
+	struct videobuf_queue buffer_queue;
+	/* Queue of filled frames */
+	struct list_head dma_queue;
+	/* Used in video-buf */
+	spinlock_t irqlock;
+	/* channel specifc parameters */
+	/* lock used to access this structure */
+	struct mutex lock;
+	/* number of users performing IO */
+	u32 io_usrs;
+	/* Indicates whether streaming started */
+	u8 started;
+	/* offset where second field starts from the starting of the
+	 * buffer for field seperated YCbCr formats
+	 */
+	u32 field_off;
+	/* Indicates width of the image data */
+	u32 width;
+	/* Indicates height of the image data */
+	u32 height;
+	/* used when IMP is chained to store the crop window which
+	 * is different from the image window
+	 */
+	struct v4l2_rect crop;
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	/* Identifies video device for this channel */
+	struct video_device *video_dev;
+	/* Used to keep track of state of the priority */
+	struct v4l2_prio_state prio;
+	/* number of open instances of the channel */
+	u32 usrs;
+	/* Indicates id of the field which is being displayed */
+	u32 field_id;
+	/* flag to indicate whether decoder is initialized */
+	u8 initialized;
+	/* Identifies channel */
+	enum vpfe_channel_id channel_id;
+	/* current interface parameters */
+	struct v4l2_ifparm ifparams;
+	/* current interface type */
+	enum vpfe_hw_if_type vpfe_if;
+	/* number of decoders registered with the master */
+	u8 numdecoders;
+	/* decoder slave ptrs */
+	struct v4l2_int_device *decoder[VPFE_CAPTURE_NUM_DECODERS];
+	/* Index of the currently selected decoder */
+	u8 current_decoder;
+	void *res1;
+	void *res2;
+	/* To track if we need to attach IPIPE IRQ or CCDC IRQ */
+	enum vpfe_irq_use_type irq_type;
+	/* CCDC IRQs used when CCDC/ISIF output to SDRAM */
+	unsigned int ccdc_irq0;
+	unsigned int ccdc_irq1;
+	enum output_src out_from;
+	struct common_obj common[VPFE_NUMBER_OF_OBJECTS];
+	struct video_obj video;
+};
+
+/* File handle structure */
+struct vpfe_fh {
+	/* pointer to channel object for opened device */
+	struct channel_obj *channel;
+	/* Indicates whether this file handle is doing IO */
+	u8 io_allowed[VPFE_NUMBER_OF_OBJECTS];
+	/* Used to keep track priority of this instance */
+	enum v4l2_priority prio;
+	/* Used to indicate channel is initialize or not */
+	u8 initialized;
+};
+
+/* vpfe device structure */
+struct vpfe_device {
+	struct channel_obj *dev[CCDC_CAPTURE_NUM_CHANNELS];
+};
+
+struct vpfe_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[CCDC_CAPTURE_NUM_CHANNELS];
+	u32 min_bufsize[CCDC_CAPTURE_NUM_CHANNELS];
+	u32 channel_bufsize[CCDC_CAPTURE_NUM_CHANNELS];
+};
+
+
+/* SoC Capture hardware interface */
+extern struct ccdc_hw_device ccdc_hw_dev;
+#define CAPTURE_DRV_NAME "vpfe-capture"
+#endif				/* End of __KERNEL__ */
+
+/* IOCTLs */
+#define VPFE_CMD_LATEST_FRM_ONLY \
+			_IOW('V', BASE_VIDIOC_PRIVATE + 1, int)
+#define VPFE_CMD_G_DECODER_PARAMS _IOR('V', BASE_VIDIOC_PRIVATE + 2, \
+					void *)
+#define VPFE_CMD_S_DECODER_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE + 3, \
+					void *)
+#define VPFE_CMD_S_SOC_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE + 4, \
+					void *)
+#define VPFE_CMD_G_SOC_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE + 5, \
+					void *)
+
+#endif				/* _DAVINCI_VPFE_H */
Index: linux-2.6.29/include/media/davinci/vpfe_types.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/media/davinci/vpfe_types.h	2009-11-20 10:07:18.510465233 -0600
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2008-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef _VPFE_TYPES_H
+#define _VPFE_TYPES_H
+
+#ifdef __KERNEL__
+
+enum vpfe_hw_if_type {
+	/* BT656 - 8 bit */
+	VPFE_BT656,
+	/* BT1120 - 16 bit */
+	VPFE_BT1120,
+	/* Raw Bayer */
+	VPFE_RAW_BAYER,
+	/* YCbCr - 8 bit with external sync */
+	VPFE_YCBCR_SYNC_8,
+	/* YCbCr - 16 bit with external sync */
+	VPFE_YCBCR_SYNC_16,
+	/* BT656 - 10 bit */
+	VPFE_BT656_10BIT
+};
+
+enum vpfe_sync_pol {
+	VPFE_SYNC_POSITIVE = 0,
+	VPFE_SYNC_NEGATIVE
+};
+
+/* Pixel format to be used across vpfe driver */
+enum vpfe_hw_pix_format {
+	VPFE_BAYER_8BIT_PACK,
+	VPFE_BAYER_8BIT_PACK_ALAW,
+	VPFE_BAYER_8BIT_PACK_DPCM,
+	VPFE_BAYER_12BIT_PACK,
+	/* 16 bit Bayer */
+	VPFE_BAYER,
+	VPFE_UYVY,
+	VPFE_YUYV,
+	VPFE_RGB565,
+	VPFE_RGB888,
+	/* YUV 420 */
+	VPFE_YUV420,
+	/* YUV 420, Y data */
+	VPFE_420_Y,
+	/* YUV 420, C data */
+	VPFE_420_C,
+};
+
+/* interface description */
+struct vpfe_hw_if_param {
+	enum vpfe_hw_if_type if_type;
+	enum vpfe_sync_pol hdpol;
+	enum vpfe_sync_pol vdpol;
+};
+
+#endif
+#endif
Index: linux-2.6.29/include/media/davinci_vpfe.h
===================================================================
--- linux-2.6.29.orig/include/media/davinci_vpfe.h	2009-11-20 10:07:08.326156274 -0600
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2006 Texas Instruments Inc
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/* davinci_vpfe.h */
-
-#ifndef DAVINCI_VPFE_H
-#define DAVINCI_VPFE_H
-#ifdef __KERNEL__
-#include <media/v4l2-dev.h>
-#endif
-
-#include <media/ccdc_davinci.h>
-#include <media/tvp5146.h>
-
-#define TRUE 1
-#define FALSE 0
-
-/* vpfe specific video standards */
-#define VPFE_STD_625_50_SQP ((V4L2_STD_625_50)<<32)
-#define VPFE_STD_525_60_SQP ((V4L2_STD_525_60)<<32)
-#define VPFE_STD_AUTO ((v4l2_std_id)(0x1000000000000000ULL))
-#define VPFE_STD_AUTO_SQP ((v4l2_std_id)(0x2000000000000000ULL))
-
-#define VPFE_CMD_CONFIG_CCDC _IOW('V',BASE_VIDIOC_PRIVATE + 1,ccdc_params_ycbcr)
-#define VPFE_CMD_LATEST_FRM_ONLY   _IOW('V',BASE_VIDIOC_PRIVATE + 2,int)
-#define VPFE_CMD_CONFIG_TVP5146 _IOW('V',BASE_VIDIOC_PRIVATE + 3,tvp5146_params)
-
-/* settings for commonly used video formats */
-#define VPFE_WIN_NTSC    {0,0,720,480}
-#define VPFE_WIN_PAL     {0,0,720,576}
-#define VPFE_WIN_NTSC_SP {0,0,640,480}	/* ntsc square pixel */
-#define VPFE_WIN_PAL_SP  {0,0,768,576}	/* pal square pixel */
-#define VPFE_WIN_CIF     {0,0,352,288}
-#define VPFE_WIN_QCIF    {0,0,176,144}
-#define VPFE_WIN_QVGA    {0,0,320,240}
-#define VPFE_WIN_SIF     {0,0,352,240}
-
-
-#ifdef __KERNEL__
-
-#include <media/video-buf.h>
-
-#define VPFE_MAJOR_RELEASE 0
-#define VPFE_MINOR_RELEASE 0
-#define VPFE_BUILD         1
-
-#define VPFE_VERSION_CODE \
-     (VPFE_MAJOR_RELEASE<<16)  | (VPFE_MINOR_RELEASE<<8) | VPFE_BUILD
-
-/* By default, the driver is setup for auto-swich mode */
-#define VPFE_DEFAULT_STD VPFE_STD_AUTO
-
-#define VPFE_PIXELASPECT_NTSC {11, 10}
-#define VPFE_PIXELASPECT_PAL  {54, 59}
-#define VPFE_PIXELASPECT_NTSC_SP    {1, 1}
-#define VPFE_PIXELASPECT_PAL_SP     {1, 1}
-#define VPFE_PIXELASPECT_DEFAULT    {1, 1}
-
-#define VPFE_MAX_FRAME_WIDTH      768	/* account for PAL Square pixel mode */
-#define VPFE_MAX_FRAME_HEIGHT     576	/* account for PAL                   */
-/* 4:2:2 data */
-#define VPFE_MAX_FBUF_SIZE       (VPFE_MAX_FRAME_WIDTH*VPFE_MAX_FRAME_HEIGHT*2)
-/* frame buffers allocate at driver initialization time */
-#define VPFE_DEFNUM_FBUFS             3
-
-#define VPFE_MAX_FBUF_ORDER \
-   get_order(roundup_pow_of_two(VPFE_MAX_FBUF_SIZE))
-
-/* device object */
-typedef struct vpfe_obj {
-	struct video_device *video_dev;
-	struct videobuf_queue bufqueue;/* queue with frame buffers      */
-	struct list_head dma_queue;
-	u32 latest_only;		/* indicate whether to return the most */
-					/* recent captured buffers only        */
-	u32 usrs;
-	u32 io_usrs;
-	struct v4l2_prio_state prio;
-	v4l2_std_id std;
-	struct v4l2_rect vwin;
-	struct v4l2_rect bounds;
-	struct v4l2_fract pixelaspect;
-       	spinlock_t irqlock;
-	struct semaphore lock;
-	enum v4l2_field field;
-	u32 pixelfmt;
-	u32 numbuffers;
-	u8* fbuffers[VIDEO_MAX_FRAME];
-	struct videobuf_buffer *curFrm;
-	struct videobuf_buffer *nextFrm;
-	int field_id;
-	int mode_changed;
-	int started;
-	int field_offset;
-	tvp5146_params tvp5146_params;
-	ccdc_params_ycbcr ccdc_params;
-} vpfe_obj;
-
-/* file handle */
-typedef struct vpfe_fh {
-	struct vpfe_obj *dev;
-	int io_allowed;
-	enum v4l2_priority prio;
-} vpfe_fh;
-#endif
-
-#endif /* DAVINCI_VPFE_H */
Index: linux-2.6.29/include/media/mt9v113_davinci.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.29/include/media/mt9v113_davinci.h	2009-11-20 10:08:11.630224921 -0600
@@ -0,0 +1,80 @@
+/*
+ * drivers/media/video/mt9v113.h
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Contributors:
+ *     Sivaraj R <sivaraj@ti.com>
+ *     Brijesh R Jadav <brijesh.j@ti.com>
+ *     Hardik Shah <hardik.shah@ti.com>
+ *     Manjunath Hadli <mrh@ti.com>
+ *     Karicheri Muralidharan <m-karicheri2@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef _MT9V113_H
+#define _MT9V113_H
+
+/*
+ * Other macros
+ */
+#define MT9V113_MODULE_NAME		"mt9v113"
+
+/* Number of pixels and number of lines per frame for different standards */
+#define VGA_NUM_ACTIVE_PIXELS		(640*2)
+#define VGA_NUM_ACTIVE_LINES		(480)
+#define QVGA_NUM_ACTIVE_PIXELS	(320*2)
+#define QVGA_NUM_ACTIVE_LINES		(240)
+
+/**
+ * struct mt9v113_platform_data - Platform data values and access functions.
+ * @power_set: Power state access function, zero is off, non-zero is on.
+ * @ifparm: Interface parameters access function.
+ * @priv_data_set: Device private data (pointer) access function.
+ * @clk_polarity: Clock polarity of the current interface.
+ * @ hs_polarity: HSYNC Polarity configuration for current interface.
+ * @ vs_polarity: VSYNC Polarity configuration for current interface.
+ */
+struct mt9v113_platform_data {
+	char *master;
+	int (*power_set) (enum v4l2_power on);
+	int (*ifparm) (struct v4l2_ifparm *p);
+	int (*priv_data_set) (void *);
+	/* Interface control params */
+	bool clk_polarity;
+	bool hs_polarity;
+	bool vs_polarity;
+};
+
+// new
+
+/*i2c adress for MT9V113*/
+#define MT9V113_I2C_ADDR  		(0x78 >>1)
+
+#define I2C_ONE_BYTE_TRANSFER		(1)
+#define I2C_TWO_BYTE_TRANSFER		(2)
+#define I2C_THREE_BYTE_TRANSFER		(3)
+#define I2C_FOUR_BYTE_TRANSFER		(4)
+#define I2C_TXRX_DATA_MASK		(0x00FF)
+#define I2C_TXRX_DATA_MASK_UPPER	(0xFF00)
+#define I2C_TXRX_DATA_SHIFT		(8)
+
+#define MT9V113_VGA_30FPS  (1130)
+#define MT9V113_QVGA_30FPS  (1131)
+
+#endif				/* ifndef _MT9V113_H */
+
Index: linux-2.6.29/include/media/v4l2-int-device.h
===================================================================
--- linux-2.6.29.orig/include/media/v4l2-int-device.h	2009-11-20 10:07:08.310077970 -0600
+++ linux-2.6.29/include/media/v4l2-int-device.h	2009-11-20 10:07:18.510465233 -0600
@@ -111,6 +111,7 @@
 	 * on certain image sensors.
 	 */
 	V4L2_IF_TYPE_BT656,
+	V4L2_IF_TYPE_PARALLEL, // parallel interface using pixel_clk, frame_valid, line_viade and data[n..0]
 };
 
 enum v4l2_if_type_bt656_mode {
@@ -157,10 +158,36 @@
 	u32 clock_curr;
 };
 
+struct v4l2_if_type_parallel {
+	/*
+	 * 0: Frame begins when vsync is high.
+	 * 1: Frame begins when vsync changes from low to high.
+	 */
+	unsigned frame_start_on_rising_vs:1;
+	/* Swap every two adjacent image data elements. */
+	unsigned swap:1;
+	/* Inverted latch clock polarity from slave. */
+	unsigned latch_clk_inv:1;
+	/* Hs polarity. 0 is active high, 1 active low. */
+	unsigned no_hs_inv:1;
+	/* Vs polarity. 0 is active high, 1 active low. */
+	unsigned no_vs_inv:1;
+	/* Minimum accepted bus clock for slave (in Hz). */
+	u32 clock_min;
+	/* Maximum accepted bus clock for slave. */
+	u32 clock_max;
+	/*
+	 * Current wish of the slave. May only change in response to
+	 * ioctls that affect image capture.
+	 */
+	u32 clock_curr;
+};
+
 struct v4l2_ifparm {
 	enum v4l2_if_type if_type;
 	union {
 		struct v4l2_if_type_bt656 bt656;
+		struct v4l2_if_type_parallel parallel;
 	} u;
 };
 
Index: linux-2.6.29/include/video/davincifb.h
===================================================================
--- linux-2.6.29.orig/include/video/davincifb.h	2009-11-20 10:07:08.358157834 -0600
+++ linux-2.6.29/include/video/davincifb.h	2009-11-20 10:08:11.509845898 -0600
@@ -13,7 +13,7 @@
 #ifndef _DAVINCIFB_H_
 #define _DAVINCIFB_H_
 
-#include <mach/io.h>
+//#include <mach/io.h>
 
 /* Base registers */
 #define	VPBE_REG_BASE				0x01c72780
